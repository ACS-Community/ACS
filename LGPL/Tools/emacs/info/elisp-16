This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is the edition 2.3 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 19.23.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Prefix Keys,  Next: Active Keymaps,  Prev: Inheritance and Keymaps,  Up: Keymaps

Prefix Keys
===========

   A "prefix key" has an associated keymap that defines what to do with
key sequences that start with the prefix key.  For example, `C-x' is a
prefix key, and it uses a keymap that is also stored in the variable
`ctl-x-map'.  Here is a list of the standard prefix keys of Emacs and
their keymaps:

   * `esc-map' is used for events that follow ESC.  Thus, the global
     definitions of all meta characters are actually found here.  This
     map is also the function definition of `ESC-prefix'.

   * `help-map' is used for events that follow `C-h'.

   * `mode-specific-map' is for events that follow `C-c'.  This map is
     not actually mode specific; its name was chosen to be informative
     for the user in `C-h b' (`display-bindings'), where it describes
     the main use of the `C-c' prefix key.

   * `ctl-x-map' is the map used for events that follow `C-x'.  This
     map is also the function definition of `Control-X-prefix'.

   * `ctl-x-4-map' is used for events that follow `C-x 4'.

   * `ctl-x-5-map' is used for events that follow `C-x 5'.

   * The prefix keys `C-x n', `C-x r' and `C-x a' use keymaps that have
     no special name.

   The binding of a prefix key is the keymap to use for looking up the
events that follow the prefix key.  (It may instead be a symbol whose
function definition is a keymap.  The effect is the same, but the symbol
serves as a name for the prefix key.)  Thus, the binding of `C-x' is
the symbol `Control-X-prefix', whose function definition is the keymap
for `C-x' commands.  (The same keymap is also the value of `ctl-x-map'.)

   Prefix key definitions can appear in any active keymap.  The
definitions of `C-c', `C-x', `C-h' and ESC as prefix keys appear in the
global map, so these prefix keys are always available.  Major and minor
modes can redefine a key as a prefix by putting a prefix key definition
for it in the local map or the minor mode's map.  *Note Active
Keymaps::.

   If a key is defined as a prefix in more than one active map, then its
various definitions are in effect merged: the commands defined in the
minor mode keymaps come first, followed by those in the local map's
prefix definition, and then by those from the global map.

   In the following example, we make `C-p' a prefix key in the local
keymap, in such a way that `C-p' is identical to `C-x'.  Then the
binding for `C-p C-f' is the function `find-file', just like `C-x C-f'.
The key sequence `C-p 6' is not found in any active keymap.

     (use-local-map (make-sparse-keymap))
         => nil
     (local-set-key "\C-p" ctl-x-map)
         => nil
     (key-binding "\C-p\C-f")
         => find-file
     
     (key-binding "\C-p6")
         => nil

 - Function: define-prefix-command SYMBOL
     This function defines SYMBOL as a prefix command: it creates a
     full keymap and stores it as SYMBOL's function definition.
     Storing the symbol as the binding of a key makes the key a prefix
     key that has a name.  The function also sets SYMBOL as a variable,
     to have the keymap as its value.  It returns SYMBOL.

     In Emacs version 18, only the function definition of SYMBOL was
     set, not the value as a variable.


File: elisp,  Node: Active Keymaps,  Next: Key Lookup,  Prev: Prefix Keys,  Up: Keymaps

Active Keymaps
==============

   Emacs normally contains many keymaps; at any given time, just a few
of them are "active" in that they participate in the interpretation of
user input.  These are the global keymap, the current buffer's local
keymap, and the keymaps of any enabled minor modes.

   The "global keymap" holds the bindings of keys that are defined
regardless of the current buffer, such as `C-f'.  The variable
`global-map' holds this keymap, which is always active.

   Each buffer may have another keymap, its "local keymap", which may
contain new or overriding definitions for keys.  The current buffer's
local keymap is always active except when `overriding-local-map'
overrides it.  Text properties can specify an alternative local map for
certain parts of the buffer; see *Note Special Properties::.

   Each minor mode may have a keymap; if it does, the keymap is active
when the minor mode is enabled.

   The variable `overriding-local-map', if non-`nil', specifies another
local keymap that overrides the buffer's local map and all the minor
mode keymaps.

   All the active keymaps are used together to determine what command to
execute when a key is entered.  Emacs searches these maps one by one, in
order of decreasing precedence, until it finds a binding in one of the
maps.

   Normally, Emacs *first* searches for the key in the minor mode maps
(one map at a time); if they do not supply a binding for the key, Emacs
searches the local map; if that too has no binding, Emacs then searches
the global map.  However, if `overriding-local-map' is non-`nil', Emacs
searches that map first, followed by the global map.

   The procedure for searching a single keymap is called "key lookup";
see *Note Key Lookup::.

   Since every buffer that uses the same major mode normally uses the
same local keymap, you can think of the keymap as local to the mode.  A
change to the local keymap of a buffer (using `local-set-key', for
example) is seen also in the other buffers that share that keymap.

   The local keymaps that are used for Lisp mode, C mode, and several
other major modes exist even if they have not yet been used.  These
local maps are the values of the variables `lisp-mode-map',
`c-mode-map', and so on.  For most other modes, which are less
frequently used, the local keymap is constructed only when the mode is
used for the first time in a session.

   The minibuffer has local keymaps, too; they contain various
completion and exit commands.  *Note Intro to Minibuffers::.

   *Note Standard Keymaps::, for a list of standard keymaps.

 - Variable: global-map
     This variable contains the default global keymap that maps Emacs
     keyboard input to commands.  The global keymap is normally this
     keymap.  The default global keymap is a full keymap that binds
     `self-insert-command' to all of the printing characters.

     It is normal practice to change the bindings in the global map,
     but you should not assign this variable any value other than the
     keymap it starts out with.

 - Function: current-global-map
     This function returns the current global keymap.  This is the same
     as the value of `global-map' unless you change one or the other.

          (current-global-map)
          => (keymap [set-mark-command beginning-of-line ...
                      delete-backward-char])

 - Function: current-local-map
     This function returns the current buffer's local keymap, or `nil'
     if it has none.  In the following example, the keymap for the
     `*scratch*' buffer (using Lisp Interaction mode) is a sparse keymap
     in which the entry for ESC, ASCII code 27, is another sparse
     keymap.

          (current-local-map)
          => (keymap
              (10 . eval-print-last-sexp)
              (9 . lisp-indent-line)
              (127 . backward-delete-char-untabify)
              (27 keymap
                  (24 . eval-defun)
                  (17 . indent-sexp)))

 - Function: current-minor-mode-maps
     This function returns a list of the keymaps of currently enabled
     minor modes.

 - Function: use-global-map KEYMAP
     This function makes KEYMAP the new current global keymap.  It
     returns `nil'.

     It is very unusual to change the global keymap.

 - Function: use-local-map KEYMAP
     This function makes KEYMAP the new local keymap of the current
     buffer.  If KEYMAP is `nil', then the buffer has no local keymap.
     `use-local-map' returns `nil'.  Most major mode commands use this
     function.

 - Variable: minor-mode-map-alist
     This variable is an alist describing keymaps that may or may not be
     active according to the values of certain variables.  Its elements
     look like this:

          (VARIABLE . KEYMAP)

     The keymap KEYMAP is active whenever VARIABLE has a non-`nil'
     value.  Typically VARIABLE is the variable that enables or
     disables a minor mode.  *Note Keymaps and Minor Modes::.

     Note that elements of `minor-mode-map-alist' do not have the same
     structure as elements of `minor-mode-alist'.  The map must be the
     CDR of the element; a list with the map as the second element will
     not do.

     What's more, the keymap itself must appear in the CDR.  It does not
     work to store a variable in the CDR and make the map the value of
     that variable.

     When more than one minor mode keymap is active, their order of
     priority is the order of `minor-mode-map-alist'.  But you should
     design minor modes so that they don't interfere with each other.
     If you do this properly, the order will not matter.

     See also `minor-mode-key-binding' in *Note Functions for Key
     Lookup::.  See *Note Keymaps and Minor Modes::, for more
     information about minor modes.

 - Variable: overriding-local-map
     If non-`nil', this variable holds a keymap to use instead of the
     buffer's local keymap and instead of all the minor mode keymaps.
     This keymap, if any, overrides all other maps that would have been
     active, except for the current global map.


File: elisp,  Node: Key Lookup,  Next: Functions for Key Lookup,  Prev: Active Keymaps,  Up: Keymaps

Key Lookup
==========

   "Key lookup" is the process of finding the binding of a key sequence
from a given keymap.  Actual execution of the binding is not part of
key lookup.

   Key lookup uses just the event type of each event in the key
sequence; the rest of the event is ignored.  In fact, a key sequence
used for key lookup may designate mouse events with just their types
(symbols) instead of with entire mouse events (lists).  *Note Input
Events::.  Such a pseudo-key-sequence is insufficient for
`command-execute', but it is sufficient for looking up or rebinding a
key.

   When the key sequence consists of multiple events, key lookup
processes the events sequentially: the binding of the first event is
found, and must be a keymap; then the second event's binding is found in
that keymap, and so on until all the events in the key sequence are used
up.  (The binding thus found for the last event may or may not be a
keymap.)  Thus, the process of key lookup is defined in terms of a
simpler process for looking up a single event in a keymap.  How that is
done depends on the type of object associated with the event in that
keymap.

   Let's use the term "keymap entry" to describe the value found by
looking up an event type in a keymap.  (This doesn't include the item
string and other extra elements in menu key bindings because
`lookup-key' and other key lookup functions don't include them in the
returned value.)  While any Lisp object may be stored in a keymap as a
keymap entry, not all make sense for key lookup.  Here is a list of the
meaningful kinds of keymap entries:

`nil'
     `nil' means that the events used so far in the lookup form an
     undefined key.  When a keymap fails to mention an event type at
     all, and has no default binding, that is equivalent to a binding
     of `nil' for that event type.

KEYMAP
     The events used so far in the lookup form a prefix key.  The next
     event of the key sequence is looked up in KEYMAP.

COMMAND
     The events used so far in the lookup form a complete key, and
     COMMAND is its binding.  *Note What Is a Function::.

STRING
VECTOR
     The events used so far in the lookup form a complete key, whose
     binding is a keyboard macro.  See *Note Keyboard Macros::, for more
     information.

LIST
     The meaning of a list depends on the types of the elements of the
     list.

        * If the CAR of LIST is the symbol `keymap', then the list is a
          keymap, and is treated as a keymap (see above).

        * If the CAR of LIST is `lambda', then the list is a lambda
          expression.  This is presumed to be a command, and is treated
          as such (see above).

        * If the CAR of LIST is a keymap and the CDR is an event type,
          then this is an "indirect entry":

               (OTHERMAP . OTHERTYPE)

          When key lookup encounters an indirect entry, it looks up
          instead the binding of OTHERTYPE in OTHERMAP and uses that.

          This feature permits you to define one key as an alias for
          another key.  For example, an entry whose CAR is the keymap
          called `esc-map' and whose CDR is 32 (the code for space)
          means, "Use the global binding of `Meta-SPC', whatever that
          may be."

SYMBOL
     The function definition of SYMBOL is used in place of SYMBOL.  If
     that too is a symbol, then this process is repeated, any number of
     times.  Ultimately this should lead to an object that is a keymap,
     a command or a keyboard macro.  A list is allowed if it is a
     keymap or a command, but indirect entries are not understood when
     found via symbols.

     Note that keymaps and keyboard macros (strings and vectors) are not
     valid functions, so a symbol with a keymap, string, or vector as
     its function definition is invalid as a function.  It is, however,
     valid as a key binding.  If the definition is a keyboard macro,
     then the symbol is also valid as an argument to `command-execute'
     (*note Interactive Call::.).

     The symbol `undefined' is worth special mention: it means to treat
     the key as undefined.  Strictly speaking, the key is defined, and
     its binding is the command `undefined'; but that command does the
     same thing that is done automatically for an undefined key: it
     rings the bell (by calling `ding') but does not signal an error.

     `undefined' is used in local keymaps to override a global key
     binding and make the key "undefined" locally.  A local binding of
     `nil' would fail to do this because it would not override the
     global binding.

ANYTHING ELSE
     If any other type of object is found, the events used so far in the
     lookup form a complete key, and the object is its binding, but the
     binding is not executable as a command.

   In short, a keymap entry may be a keymap, a command, a keyboard
macro, a symbol that leads to one of them, or an indirection or `nil'.
Here is an example of a sparse keymap with two characters bound to
commands and one bound to another keymap.  This map is the normal value
of `emacs-lisp-mode-map'.  Note that 9 is the code for TAB, 127 for
DEL, 27 for ESC, 17 for `C-q' and 24 for `C-x'.

     (keymap (9 . lisp-indent-line)
             (127 . backward-delete-char-untabify)
             (27 keymap (17 . indent-sexp) (24 . eval-defun)))


File: elisp,  Node: Functions for Key Lookup,  Next: Changing Key Bindings,  Prev: Key Lookup,  Up: Keymaps

Functions for Key Lookup
========================

   Here are the functions and variables pertaining to key lookup.

 - Function: lookup-key KEYMAP KEY &optional ACCEPT-DEFAULTS
     This function returns the definition of KEY in KEYMAP.  If the
     string or vector KEY is not a valid key sequence according to the
     prefix keys specified in KEYMAP (which means it is "too long" and
     has extra events at the end), then the value is a number, the
     number of events at the front of KEY that compose a complete key.

     If ACCEPT-DEFAULTS is non-`nil', then `lookup-key' considers
     default bindings as well as bindings for the specific events in
     KEY.  Otherwise, `lookup-key' reports only bindings for the
     specific sequence KEY, ignoring default bindings except when you
     explicitly ask about them.  (To do this, supply `t' as an element
     of KEY; see *Note Format of Keymaps::.)

     All the other functions described in this chapter that look up
     keys use `lookup-key'.

          (lookup-key (current-global-map) "\C-x\C-f")
              => find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              => 2

     If KEY contains a meta character, that character is implicitly
     replaced by a two-character sequence: the value of
     `meta-prefix-char', followed by the corresponding non-meta
     character.  Thus, the first example below is handled by conversion
     into the second example.

          (lookup-key (current-global-map) "\M-f")
              => forward-word
          (lookup-key (current-global-map) "\ef")
              => forward-word

     Unlike `read-key-sequence', this function does not modify the
     specified events in ways that discard information (*note Key
     Sequence Input::.).  In particular, it does not convert letters to
     lower case and it does not change drag events to clicks.

 - Command: undefined
     Used in keymaps to undefine keys.  It calls `ding', but does not
     cause an error.

 - Function: key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns the binding for KEY in the current keymaps,
     trying all the active keymaps.  The result is `nil' if KEY is
     undefined in the keymaps.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

     An error is signaled if KEY is not a string or a vector.

          (key-binding "\C-x\C-f")
              => find-file

 - Function: local-key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns the binding for KEY in the current local
     keymap, or `nil' if it is undefined there.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

 - Function: global-key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns the binding for command KEY in the current
     global keymap, or `nil' if it is undefined there.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

 - Function: minor-mode-key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns a list of all the active minor mode bindings
     of KEY.  More precisely, it returns an alist of pairs `(MODENAME .
     BINDING)', where MODENAME is the variable that enables the minor
     mode, and BINDING is KEY's binding in that mode.  If KEY has no
     minor-mode bindings, the value is `nil'.

     If the first binding is not a prefix command, all subsequent
     bindings from other minor modes are omitted, since they would be
     completely shadowed.  Similarly, the list omits non-prefix
     bindings that follow prefix bindings.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

 - Variable: meta-prefix-char
     This variable is the meta-prefix character code.  It is used when
     translating a meta character to a two-character sequence so it can
     be looked up in a keymap.  For useful results, the value should be
     a prefix event (*note Prefix Keys::.).  The default value is 27,
     which is the ASCII code for ESC.

     As long as the value of `meta-prefix-char' remains 27, key lookup
     translates `M-b' into `ESC b', which is normally defined as the
     `backward-word' command.  However, if you set `meta-prefix-char'
     to 24, the code for `C-x', then Emacs will translate `M-b' into
     `C-x b', whose standard binding is the `switch-to-buffer' command.

          meta-prefix-char                    ; The default value.
               => 27

          (key-binding "\M-b")
               => backward-word

          ?\C-x                               ; The print representation
               => 24                          ;   of a character.

          (setq meta-prefix-char 24)
               => 24

          (key-binding "\M-b")
               => switch-to-buffer            ; Now, typing `M-b' is
                                              ;   like typing `C-x b'.
          
          (setq meta-prefix-char 27)          ; Avoid confusion!
               => 27                          ; Restore the default value!


File: elisp,  Node: Changing Key Bindings,  Next: Key Binding Commands,  Prev: Functions for Key Lookup,  Up: Keymaps

Changing Key Bindings
=====================

   The way to rebind a key is to change its entry in a keymap.  If you
change a binding in the global keymap, the change is effective in all
buffers (though it has no direct effect in buffers that shadow the
global binding with a local one).  If you change the current buffer's
local map, that usually affects all buffers using the same major mode.
The `global-set-key' and `local-set-key' functions are convenient
interfaces for these operations (*note Key Binding Commands::.).  You
can also use `define-key', a more general function; then you must
specify explicitly the map to change.

   In writing the key sequence to rebind, it is good to use the special
escape sequences for control and meta characters (*note String Type::.).
The syntax `\C-' means that the following character is a control
character and `\M-' means that the following character is a meta
character.  Thus, the string `"\M-x"' is read as containing a single
`M-x', `"\C-f"' is read as containing a single `C-f', and `"\M-\C-x"'
and `"\C-\M-x"' are both read as containing a single `C-M-x'.  You can
also use this escape syntax in vectors, as well as others that aren't
allowed in strings; one example is `[?\C-\H-x home]'.  *Note Character
Type::.

   For the functions below, an error is signaled if KEYMAP is not a
keymap or if KEY is not a string or vector representing a key sequence.
You can use event types (symbols) as shorthand for events that are
lists.

 - Function: define-key KEYMAP KEY BINDING
     This function sets the binding for KEY in KEYMAP.  (If KEY is more
     than one event long, the change is actually made in another keymap
     reached from KEYMAP.)  The argument BINDING can be any Lisp
     object, but only certain types are meaningful.  (For a list of
     meaningful types, see *Note Key Lookup::.) The value returned by
     `define-key' is BINDING.

     Every prefix of KEY must be a prefix key (i.e., bound to a keymap)
     or undefined; otherwise an error is signaled.

     If some prefix of KEY is undefined, then `define-key' defines it
     as a prefix key so that the rest of KEY may be defined as
     specified.

   Here is an example that creates a sparse keymap and makes a number of
bindings in it:

     (setq map (make-sparse-keymap))
         => (keymap)

     (define-key map "\C-f" 'forward-char)
         => forward-char

     map
         => (keymap (6 . forward-char))

     ;; Build sparse submap for `C-x' and bind `f' in that.
     (define-key map "\C-xf" 'forward-word)
         => forward-word

     map
     => (keymap
         (24 keymap                ; `C-x'
             (102 . forward-word)) ;      `f'
         (6 . forward-char))       ; `C-f'

     ;; Bind `C-p' to the `ctl-x-map'.
     (define-key map "\C-p" ctl-x-map)
     ;; `ctl-x-map'
     => [nil ... find-file ... backward-kill-sentence]

     ;; Bind `C-f' to `foo' in the `ctl-x-map'.
     (define-key map "\C-p\C-f" 'foo)
     => 'foo

     map
     => (keymap     ; Note `foo' in `ctl-x-map'.
         (16 keymap [nil ... foo ... backward-kill-sentence])
         (24 keymap
             (102 . forward-word))
         (6 . forward-char))

Note that storing a new binding for `C-p C-f' actually works by
changing an entry in `ctl-x-map', and this has the effect of changing
the bindings of both `C-p C-f' and `C-x C-f' in the default global map.

 - Function: substitute-key-definition OLDDEF NEWDEF KEYMAP &optional
          OLDMAP
     This function replaces OLDDEF with NEWDEF for any keys in KEYMAP
     that were bound to OLDDEF.  In other words, OLDDEF is replaced
     with NEWDEF wherever it appears.  The function returns `nil'.

     For example, this redefines `C-x C-f', if you do it in an Emacs
     with standard bindings:

          (substitute-key-definition
           'find-file 'find-file-read-only (current-global-map))

     If OLDMAP is non-`nil', then its bindings determine which keys to
     rebind.  The rebindings still happen in NEWMAP, not in OLDMAP.
     Thus, you can change one map under the control of the bindings in
     another.  For example,

          (substitute-key-definition
            'delete-backward-char 'my-funny-delete
            my-map global-map)

     puts the special deletion command in `my-map' for whichever keys
     are globally bound to the standard deletion command.

     Here is an example showing a keymap before and after substitution:

          (setq map '(keymap
                      (?1 . olddef-1)
                      (?2 . olddef-2)
                      (?3 . olddef-1)))
          => (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))

          (substitute-key-definition 'olddef-1 'newdef map)
          => nil

          map
          => (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

 - Function: suppress-keymap KEYMAP &optional NODIGITS
     This function changes the contents of the full keymap KEYMAP by
     making all the printing characters undefined.  More precisely, it
     binds them to the command `undefined'.  This makes ordinary
     insertion of text impossible.  `suppress-keymap' returns `nil'.

     If NODIGITS is `nil', then `suppress-keymap' defines digits to run
     `digit-argument', and `-' to run `negative-argument'.  Otherwise
     it makes them undefined like the rest of the printing characters.

     The `suppress-keymap' function does not make it impossible to
     modify a buffer, as it does not suppress commands such as `yank'
     and `quoted-insert'.  To prevent any modification of a buffer, make
     it read-only (*note Read Only Buffers::.).

     Since this function modifies KEYMAP, you would normally use it on
     a newly created keymap.  Operating on an existing keymap that is
     used for some other purpose is likely to cause trouble; for
     example, suppressing `global-map' would make it impossible to use
     most of Emacs.

     Most often, `suppress-keymap' is used to initialize local keymaps
     of modes such as Rmail and Dired where insertion of text is not
     desirable and the buffer is read-only.  Here is an example taken
     from the file `emacs/lisp/dired.el', showing how the local keymap
     for Dired mode is set up:

          ...
            (setq dired-mode-map (make-keymap))
            (suppress-keymap dired-mode-map)
            (define-key dired-mode-map "r" 'dired-rename-file)
            (define-key dired-mode-map "\C-d" 'dired-flag-file-deleted)
            (define-key dired-mode-map "d" 'dired-flag-file-deleted)
            (define-key dired-mode-map "v" 'dired-view-file)
            (define-key dired-mode-map "e" 'dired-find-file)
            (define-key dired-mode-map "f" 'dired-find-file)
            ...


File: elisp,  Node: Key Binding Commands,  Next: Scanning Keymaps,  Prev: Changing Key Bindings,  Up: Keymaps

Commands for Binding Keys
=========================

   This section describes some convenient interactive interfaces for
changing key bindings.  They work by calling `define-key'.

   People often use `global-set-key' in their `.emacs' file for simple
customization.  For example,

     (global-set-key "\C-x\C-\\" 'next-line)

or

     (global-set-key [?\C-x ?\C-\\] 'next-line)

redefines `C-x C-\' to move down a line.

     (global-set-key [M-mouse-1] 'mouse-set-point)

redefines the first (leftmost) mouse button, typed with the Meta key, to
set point where you click.

 - Command: global-set-key KEY DEFINITION
     This function sets the binding of KEY in the current global map to
     DEFINITION.

          (global-set-key KEY DEFINITION)
          ==
          (define-key (current-global-map) KEY DEFINITION)

 - Command: global-unset-key KEY
     This function removes the binding of KEY from the current global
     map.

     One use of this function is in preparation for defining a longer
     key that uses KEY as a prefix--which would not be allowed if KEY
     has a non-prefix binding.  For example:

          (global-unset-key "\C-l")
              => nil

          (global-set-key "\C-l\C-l" 'redraw-display)
              => nil

     This function is implemented simply using `define-key':

          (global-unset-key KEY)
          ==
          (define-key (current-global-map) KEY nil)

 - Command: local-set-key KEY DEFINITION
     This function sets the binding of KEY in the current local keymap
     to DEFINITION.

          (local-set-key KEY DEFINITION)
          ==
          (define-key (current-local-map) KEY DEFINITION)

 - Command: local-unset-key KEY
     This function removes the binding of KEY from the current local
     map.

          (local-unset-key KEY)
          ==
          (define-key (current-local-map) KEY nil)


File: elisp,  Node: Scanning Keymaps,  Next: Menu Keymaps,  Prev: Key Binding Commands,  Up: Keymaps

Scanning Keymaps
================

   This section describes functions used to scan all the current keymaps
for the sake of printing help information.

 - Function: accessible-keymaps KEYMAP &optional PREFIX
     This function returns a list of all the keymaps that can be
     accessed (via prefix keys) from KEYMAP.  The value is an
     association list with elements of the form `(KEY . MAP)', where
     KEY is a prefix key whose definition in KEYMAP is MAP.

     The elements of the alist are ordered so that the KEY increases in
     length.  The first element is always `("" . KEYMAP)', because the
     specified keymap is accessible from itself with a prefix of no
     events.

     If PREFIX is given, it should be a prefix key sequence; then
     `accessible-keymaps' includes only the submaps whose prefixes start
     with PREFIX.  These elements look just as they do in the value of
     `(accessible-keymaps)'; the only difference is that some elements
     are omitted.

     In the example below, the returned alist indicates that the key
     ESC, which is displayed as `^[', is a prefix key whose definition
     is the sparse keymap `(keymap (83 . center-paragraph) (115 .
     foo))'.

          (accessible-keymaps (current-local-map))
          =>(("" keymap
                (27 keymap   ; Note this keymap for ESC is repeated below.
                    (83 . center-paragraph)
                    (115 . center-line))
                (9 . tab-to-tab-stop))

          ("^[" keymap
              (83 . center-paragraph)
              (115 . foo)))

     In the following example, `C-h' is a prefix key that uses a sparse
     keymap starting with `(keymap (118 . describe-variable)...)'.
     Another prefix, `C-x 4', uses a keymap which is also the value of
     the variable `ctl-x-4-map'.  The event `mode-line' is one of
     several dummy events used as prefixes for mouse actions in special
     parts of a window.

          (accessible-keymaps (current-global-map))
          => (("" keymap [set-mark-command beginning-of-line ...
                             delete-backward-char])

          ("^H" keymap (118 . describe-variable) ...
               (8 . help-for-help))

          ("^X" keymap [x-flush-mouse-queue ...
               backward-kill-sentence])

          ("^[" keymap [mark-sexp backward-sexp ...
               backward-kill-word])
              ("^X4" keymap (15 . display-buffer) ...)
          ([mode-line] keymap
               (S-mouse-2 . mouse-split-window-horizontally) ...))

     These are not all the keymaps you would see in an actual case.

 - Function: where-is-internal COMMAND &optional KEYMAP FIRSTONLY
          NOINDIRECT
     This function returns a list of key sequences (of any length) that
     are bound to COMMAND in a set of keymaps.

     The argument COMMAND can be any object; it is compared with all
     keymap entries using `eq'.

     If KEYMAP is `nil', then the maps used are the current active
     keymaps, disregarding `overriding-local-map' (that is, pretending
     its value is `nil').  If KEYMAP is non-`nil', then the maps
     searched are KEYMAP and the global keymap.

     Usually it's best to use `overriding-local-map' as the expression
     for KEYMAP.  Then `where-is-internal' searches precisely the
     keymaps that are active.  To search only the global map, pass
     `(keymap)' (an empty keymap) as KEYMAP.

     If FIRSTONLY is `non-ascii', then the value is a single string
     representing the first key sequence found, rather than a list of
     all possible key sequences.  If FIRSTONLY is `t', then the value
     is the first key sequence, except that key sequences consisting
     entirely of ASCII characters (or meta variants of ASCII
     characters) are preferred to all other key sequences.

     If NOINDIRECT is non-`nil', `where-is-internal' doesn't follow
     indirect keymap bindings.  This makes it possible to search for an
     indirect definition itself.

     This function is used by `where-is' (*note Help: (emacs)Help.).

          (where-is-internal 'describe-function)
              => ("\^hf" "\^hd")

 - Command: describe-bindings PREFIX
     This function creates a listing of all defined keys and their
     definitions.  It writes the listing in a buffer named `*Help*' and
     displays it in a window.

     If PREFIX is non-`nil', it should be a prefix key; then the
     listing includes only keys that start with PREFIX.

     The listing describes meta characters as ESC followed by the
     corresponding non-meta character.

     When several characters with consecutive ASCII codes have the same
     definition, they are shown together, as `FIRSTCHAR..LASTCHAR'.  In
     this instance, you need to know the ASCII codes to understand
     which characters this means.  For example, in the default global
     map, the characters `SPC .. ~' are described by a single line.
     SPC is ASCII 32, `~' is ASCII 126, and the characters between them
     include all the normal printing characters, (e.g., letters,
     digits, punctuation, etc.); all these characters are bound to
     `self-insert-command'.


File: elisp,  Node: Menu Keymaps,  Prev: Scanning Keymaps,  Up: Keymaps

Menu Keymaps
============

   A keymap can define a menu as well as bindings for keyboard keys and
mouse button.  Menus are usually actuated with the mouse, but they can
work with the keyboard also.

* Menu:

* Defining Menus::		How to make a keymap that defines a menu.
* Mouse Menus::			How users actuate the menu with the mouse.
* Keyboard Menus::		How they actuate it with the keyboard.
* Menu Example::		Making a simple menu.
* Menu Bar::			How to customize the menu bar.
* Modifying Menus::             How to add new items to a menu.


File: elisp,  Node: Defining Menus,  Next: Mouse Menus,  Up: Menu Keymaps

Defining Menus
--------------

   A keymap is suitable for menu use if it has an "overall prompt
string", which is a string that appears as an element of the keymap.
(*Note Format of Keymaps::.)  The string should describe the purpose of
the menu.  The easiest way to construct a keymap with a prompt string is
to specify the string as an argument when you call `make-keymap' or
`make-sparse-keymap' (*note Creating Keymaps::.).

   The individual bindings in the menu keymap should have item strings;
these strings become the items displayed in the menu.  A binding with
an item string looks like this:

     (STRING . REAL-BINDING)

   The item string for a binding should be short--one or two words.  It
should describe the action of the command it corresponds to.

   As far as `define-key' is concerned, STRING is part of the event's
binding.  However, `lookup-key' returns just REAL-BINDING, and only
REAL-BINDING is used for executing the key.

   You can also supply a second string, called the help string, as
follows:

     (STRING HELP-STRING . REAL-BINDING)

   Currently Emacs does not actually use HELP-STRING; it knows only how
to ignore HELP-STRING in order to extract REAL-BINDING.  In the future
we hope to make HELP-STRING serve as extended documentation for the
menu item, available on request.

   If REAL-BINDING is `nil', then STRING appears in the menu but cannot
be selected.

   If REAL-BINDING is a symbol and has a non-`nil' `menu-enable'
property, that property is an expression that controls whether the menu
item is enabled.  Every time the keymap is used to display a menu,
Emacs evaluates the expression, and it enables the menu item only if
the expression's value is non-`nil'.  When a menu item is disabled, it
is displayed in a "fuzzy" fashion, and cannot be selected with the
mouse.

   The order of items in the menu is the same as the order of bindings
in the keymap.  Since `define-key' puts new bindings at the front, you
should define the menu items starting at the bottom of the menu and
moving to the top, if you care about the order.  When you add an item to
an existing menu, you can specify its position in the menu using
`define-key-after' (*note Modifying Menus::.).

   You've probably noticed that menu items show the equivalent keyboard
key sequence (if any) to invoke the same command.  To save time on
recalculation, menu display caches this information in a sublist in the
binding, like this:

     (STRING [HELP-STRING] (KEY-BINDING-DATA) . REAL-BINDING)

   Don't put these sublists in the menu item yourself; menu display
calculates them automatically.  Don't add keyboard equivalents to the
item strings in a mouse menu, since that is redundant.


File: elisp,  Node: Mouse Menus,  Next: Keyboard Menus,  Prev: Defining Menus,  Up: Menu Keymaps

Menus and the Mouse
-------------------

   The way to make a menu keymap produce a menu is to make it the
definition of a prefix key.

   If the prefix key ends with a mouse event, Emacs handles the menu
keymap by popping up a visible menu, so that the user can select a
choice with the mouse.  When the user clicks on a menu item, the event
generated is whatever character or symbol has the binding that brought
about that menu item.  (A menu item may generate a series of events if
the menu has multiple levels or comes from the menu bar.)

   It's often best to use a button-down event to trigger the menu.  Then
the user can select a menu item by releasing the button.

   A single keymap can appear as multiple menu panes, if you explicitly
arrange for this.  The way to do this is to make a keymap for each pane,
then create a binding for each of those maps in the main keymap of the
menu.  Give each of these bindings an item string that starts with `@'.
The rest of the item string becomes the name of the pane.  See the
file `lisp/mouse.el' for an example of this.  Any ordinary bindings
with `@'-less item strings are grouped into one pane, which appears
along with the other panes explicitly created for the submaps.

   X toolkit menus don't have panes; instead, they can have submenus.
Every nested keymap becomes a submenu, whether the item string starts
with `@' or not.  In a toolkit version of Emacs, the only thing special
about `@' at the beginning of an item string is that the `@' doesn't
appear in the menu item.

   You can also get multiple panes from separate keymaps.  The full
definition of a prefix key always comes from merging the definitions
supplied by the various active keymaps (minor mode, local, and global).
When more than one of these keymaps is a menu, each of them makes a
separate pane or panes.  *Note Active Keymaps::.

   In toolkit versions of Emacs, menus don't have panes, so submenus are
used to represent the separate keymaps.  Each keymap's contribution
becomes one submenu.

   A Lisp program can explicitly pop up a menu and receive the user's
choice.  You can use keymaps for this also.  *Note Pop-Up Menus::.


File: elisp,  Node: Keyboard Menus,  Next: Menu Example,  Prev: Mouse Menus,  Up: Menu Keymaps

Menus and the Keyboard
----------------------

   When a prefix key ending with a keyboard event (a character or
function key) has a definition that is a menu keymap, the user can use
the keyboard to choose a menu item.

   Emacs displays the menu alternatives (the item strings of the
bindings) in the echo area.  If they don't all fit at once, the user
can type SPC to see the next line of alternatives.  Successive uses of
SPC eventually get to the end of the menu and then cycle around to the
beginning.  (The variable `menu-prompt-more-char' specifies which
character is used for this; SPC is the default.)

   When the user has found the desired alternative from the menu, he or
she should type the corresponding character--the one whose binding is
that alternative.

   In a menu intended for keyboard use, each menu item must clearly
indicate what character to type.  The best convention to use is to make
the character the first letter of the item string.  That is something
users will understand without being told.

   This way of using menus in an Emacs-like editor was inspired by the
Hierarkey system.

 - Variable: menu-prompt-more-char
     This variable specifies the character to use to ask to see the
     next line of a menu.  Its initial value is 32, the code for SPC.


File: elisp,  Node: Menu Example,  Next: Menu Bar,  Prev: Keyboard Menus,  Up: Menu Keymaps

Menu Example
------------

   Here is a simple example of how to set up a menu for mouse use.

     (defvar my-menu-map
       (make-sparse-keymap "Key Commands <==> Functions"))
     (fset 'help-for-keys my-menu-map)
     
     (define-key my-menu-map [bindings]
       '("List all keystroke commands" . describe-bindings))
     (define-key my-menu-map [key]
       '("Describe key briefly" . describe-key-briefly))
     (define-key my-menu-map [key-verbose]
       '("Describe key verbose" . describe-key))
     (define-key my-menu-map [function]
       '("Describe Lisp function" . describe-function))
     (define-key my-menu-map [where-is]
       '("Where is this command" . where-is))
     
     (define-key global-map [C-S-down-mouse-1] 'help-for-keys)

   The symbols used in the key sequences bound in the menu are
fictitious "function keys"; they don't appear on the keyboard, but that
doesn't stop you from using them in the menu.  Their names were chosen
to be mnemonic, because they show up in the output of `where-is' and
`apropos' to identify the corresponding menu items.

   However, if you want the menu to be usable from the keyboard as well,
you must bind real ASCII characters as well as fictitious function keys.


File: elisp,  Node: Menu Bar,  Next: Modifying Menus,  Prev: Menu Example,  Up: Menu Keymaps

The Menu Bar
------------

   Most window systems allow each frame to have a "menu bar"--a
permanently displayed menu stretching horizontally across the top of the
frame.  The items of the menu bar are the subcommands of the fake
"function key" `menu-bar', as defined by all the active keymaps.

   To add an item to the menu bar, invent a fake "function key" of your
own (let's call it KEY), and make a binding for the key sequence
`[menu-bar KEY]'.  Most often, the binding is a menu keymap, so that
pressing a button on the menu bar item leads to another menu.

   When more than one active keymap defines the same fake function key
for the menu bar, the item appears just once.  If the user clicks on
that menu bar item, it brings up a single, combined submenu containing
all the subcommands of that item--the global subcommands, the local
subcommands, and the minor mode subcommands, all together.

   In order for a frame to display a menu bar, its `menu-bar-lines'
parameter must be greater than zero.  Emacs uses just one line for the
menu bar itself; if you specify more than one line, the other lines
serve to separate the menu bar from the windows in the frame.  We
recommend you try 1 or 2 as the value of `menu-bar-lines'.  *Note X
Frame Parameters::.

   Here's an example of setting up a menu bar item:

     (modify-frame-parameters (selected-frame)
                              '((menu-bar-lines . 2)))
     
     ;; Make a menu keymap (with a prompt string)
     ;; and make it the menu bar item's definition.
     (define-key global-map [menu-bar words]
       (cons "Words" (make-sparse-keymap "Words")))
     
     ;; Define specific subcommands in the item's menu.
     (define-key global-map
       [menu-bar words forward]
       '("Forward word" . forward-word))
     (define-key global-map
       [menu-bar words backward]
       '("Backward word" . backward-word))

   A local keymap can cancel a menu bar item made by the global keymap
by rebinding the same fake function key with `undefined' as the
binding.  For example, this is how Dired suppresses the `Edit' menu bar
item:

     (define-key dired-mode-map [menu-bar edit] 'undefined)

`edit' is the fake function key used by the global map for the `Edit'
menu bar item.  The main reason to suppress a global menu bar item is
to regain space for mode-specific items.

 - Variable: menu-bar-final-items
     Normally the menu bar shows global items followed by items defined
     by the local maps.

     This variable holds a list of fake function keys for items to
     display at the end of the menu bar rather than in normal sequence.
     The default value is `(help)'; thus, the `Help' menu item
     normally appears at the end of the menu bar, following local menu
     items.


File: elisp,  Node: Modifying Menus,  Prev: Menu Bar,  Up: Menu Keymaps

Modifying Menus
---------------

   When you insert a new item in an existing menu, you probably want to
put it in a particular place among the menu's existing items.  If you
use `define-key' to add the item, it normally goes at the front of the
menu.  To put it elsewhere, use `define-key-after':

 - Function: define-key-after MAP KEY BINDING AFTER
     Define a binding in MAP for KEY, with value BINDING, just like
     `define-key', but position the binding in MAP after the binding
     for the event AFTER.  For example,

          (define-key-after my-menu [drink]
                            '("Drink" . drink-command) 'eat)

     makes a binding for the fake function key drink and puts it right
     after the binding for eat.

     Here is how to insert an item called `Work' in the `Signals' menu
     of Shell mode, after the item `break':

          (define-key-after
            (lookup-key shell-mode-map [menu-bar signals])
            [work] '("Work" . work-command) 'break)

     Note that KEY is a sequence containing just one event type, but
     AFTER is just an event type (not a sequence).


File: elisp,  Node: Modes,  Next: Documentation,  Prev: Keymaps,  Up: Top

Major and Minor Modes
*********************

   A "mode" is a set of definitions that customize Emacs and can be
turned on and off while you edit.  There are two varieties of modes:
"major modes", which are mutually exclusive and used for editing
particular kinds of text, and "minor modes", which provide features
that users can enable individually.

   This chapter describes how to write both major and minor modes, how
to indicate them in the mode line, and how they run hooks supplied by
the user.  For related topics such as keymaps and syntax tables, see
*Note Keymaps::, and *Note Syntax Tables::.

* Menu:

* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Hooks::              How to use hooks; how to write code that provides hooks.

