This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is the edition 2.3 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 19.23.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: File Locks,  Next: Information about Files,  Prev: Writing to Files,  Up: Files

File Locks
==========

   When two users edit the same file at the same time, they are likely
to interfere with each other.  Emacs tries to prevent this situation
from arising by recording a "file lock" when a file is being modified.
Emacs can then detect the first attempt to modify a buffer visiting a
file that is locked by another Emacs job, and ask the user what to do.

   File locks do not work properly when multiple machines can share
file systems, such as with NFS.  Perhaps a better file locking system
will be implemented in the future.  When file locks do not work, it is
possible for two users to make changes simultaneously, but Emacs can
still warn the user who saves second.  Also, the detection of
modification of a buffer visiting a file changed on disk catches some
cases of simultaneous editing; see *Note Modification Time::.

 - Function: file-locked-p FILENAME
     This function returns `nil' if the file FILENAME is not locked by
     this Emacs process.  It returns `t' if it is locked by this Emacs,
     and it returns the name of the user who has locked it if it is
     locked by someone else.

          (file-locked-p "foo")
               => nil

 - Function: lock-buffer &optional FILENAME
     This function locks the file FILENAME, if the current buffer is
     modified.  The argument FILENAME defaults to the current buffer's
     visited file.  Nothing is done if the current buffer is not
     visiting a file, or is not modified.

 - Function: unlock-buffer
     This function unlocks the file being visited in the current buffer,
     if the buffer is modified.  If the buffer is not modified, then
     the file should not be locked, so this function does nothing.  It
     also does nothing if the current buffer is not visiting a file.

 - Function: ask-user-about-lock FILE OTHER-USER
     This function is called when the user tries to modify FILE, but it
     is locked by another user named OTHER-USER.  The value it returns
     determines what happens next:

        * A value of `t' says to grab the lock on the file.  Then this
          user may edit the file and OTHER-USER loses the lock.

        * A value of `nil' says to ignore the lock and let this user
          edit the file anyway.

        * This function may instead signal a `file-locked' error, in
          which case the change that the user was about to make does
          not take place.

          The error message for this error looks like this:

               error--> File is locked: FILE OTHER-USER

          where `file' is the name of the file and OTHER-USER is the
          name of the user who has locked the file.

     The default definition of this function asks the user to choose
     what to do.  If you wish, you can replace the `ask-user-about-lock'
     function with your own version that decides in another way.  The
     code for its usual definition is in `userlock.el'.


File: elisp,  Node: Information about Files,  Next: Changing File Attributes,  Prev: File Locks,  Up: Files

Information about Files
=======================

   The functions described in this section all operate on strings that
designate file names.  All the functions have names that begin with the
word `file'.  These functions all return information about actual files
or directories, so their arguments must all exist as actual files or
directories unless otherwise noted.

* Menu:

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A symbolic link?
* Truenames::		    Eliminating symbolic links from a file name.
* File Attributes::         How large is it?  Any other names?  Etc.


File: elisp,  Node: Testing Accessibility,  Next: Kinds of Files,  Up: Information about Files

Testing Accessibility
---------------------

   These functions test for permission to access a file in specific
ways.

 - Function: file-exists-p FILENAME
     This function returns `t' if a file named FILENAME appears to
     exist.  This does not mean you can necessarily read the file, only
     that you can find out its attributes.  (On Unix, this is true if
     the file exists and you have execute permission on the containing
     directories, regardless of the protection of the file itself.)

     If the file does not exist, or if fascist access control policies
     prevent you from finding the attributes of the file, this function
     returns `nil'.

 - Function: file-readable-p FILENAME
     This function returns `t' if a file named FILENAME exists and you
     can read it.  It returns `nil' otherwise.

          (file-readable-p "files.texi")
               => t
          (file-exists-p "/usr/spool/mqueue")
               => t
          (file-readable-p "/usr/spool/mqueue")
               => nil

 - Function: file-executable-p FILENAME
     This function returns `t' if a file named FILENAME exists and you
     can execute it.  It returns `nil' otherwise.  If the file is a
     directory, execute permission means you can check the existence and
     attributes of files inside the directory, and open those files if
     their modes permit.

 - Function: file-writable-p FILENAME
     This function returns `t' if the file FILENAME can be written or
     created by you, and `nil' otherwise.  A file is writable if the
     file exists and you can write it.  It is creatable if it does not
     exist, but the specified directory does exist and you can write in
     that directory.

     In the third example below, `foo' is not writable because the
     parent directory does not exist, even though the user could create
     such a directory.

          (file-writable-p "~/foo")
               => t
          (file-writable-p "/foo")
               => nil
          (file-writable-p "~/no-such-dir/foo")
               => nil

 - Function: file-accessible-directory-p DIRNAME
     This function returns `t' if you have permission to open existing
     files in the directory whose name as a file is DIRNAME; otherwise
     (or if there is no such directory), it returns `nil'.  The value
     of DIRNAME may be either a directory name or the file name of a
     directory.

     Example: after the following,

          (file-accessible-directory-p "/foo")
               => nil

     we can deduce that any attempt to read a file in `/foo/' will give
     an error.

 - Function: file-newer-than-file-p FILENAME1 FILENAME2
     This function returns `t' if the file FILENAME1 is newer than file
     FILENAME2.  If FILENAME1 does not exist, it returns `nil'.  If
     FILENAME2 does not exist, it returns `t'.

     In the following example, assume that the file `aug-19' was written
     on the 19th, `aug-20' was written on the 20th, and the file
     `no-file' doesn't exist at all.

          (file-newer-than-file-p "aug-19" "aug-20")
               => nil
          (file-newer-than-file-p "aug-20" "aug-19")
               => t
          (file-newer-than-file-p "aug-19" "no-file")
               => t
          (file-newer-than-file-p "no-file" "aug-19")
               => nil

     You can use `file-attributes' to get a file's last modification
     time as a list of two numbers.  *Note File Attributes::.


File: elisp,  Node: Kinds of Files,  Next: Truenames,  Prev: Testing Accessibility,  Up: Information about Files

Distinguishing Kinds of Files
-----------------------------

   This section describes how to distinguish directories and symbolic
links from ordinary files.

 - Function: file-symlink-p FILENAME
     If the file FILENAME is a symbolic link, the `file-symlink-p'
     function returns the file name to which it is linked.  This may be
     the name of a text file, a directory, or even another symbolic
     link, or it may be a nonexistent file name.

     If the file FILENAME is not a symbolic link (or there is no such
     file), `file-symlink-p' returns `nil'.

          (file-symlink-p "foo")
               => nil
          (file-symlink-p "sym-link")
               => "foo"
          (file-symlink-p "sym-link2")
               => "sym-link"
          (file-symlink-p "/bin")
               => "/pub/bin"


 - Function: file-directory-p FILENAME
     This function returns `t' if FILENAME is the name of an existing
     directory, `nil' otherwise.

          (file-directory-p "~rms")
               => t
          (file-directory-p "~rms/lewis/files.texi")
               => nil
          (file-directory-p "~rms/lewis/no-such-file")
               => nil
          (file-directory-p "$HOME")
               => nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               => t


File: elisp,  Node: Truenames,  Next: File Attributes,  Prev: Kinds of Files,  Up: Information about Files

Truenames
---------

   The "truename" of a file is the name that you get by following
symbolic links until none remain, then expanding to get rid of `.' and
`..' as components.  Strictly speaking, a file need not have a unique
truename; the number of distinct truenames a file has is equal to the
number of hard links to the file.  However, truenames are useful
because they eliminate symbolic links as a cause of name variation.

 - Function: file-truename FILENAME
     The function `file-truename' returns the true name of the file
     FILENAME.  This is the name that you get by following symbolic
     links until none remain.  The argument must be an absolute file
     name.

   *Note Buffer File Name::, for related information.


File: elisp,  Node: File Attributes,  Prev: Truenames,  Up: Information about Files

Other Information about Files
-----------------------------

   This section describes the functions for getting detailed information
about a file, other than its contents.  This information includes the
mode bits that control access permission, the owner and group numbers,
the number of names, the inode number, the size, and the times of access
and modification.

 - Function: file-modes FILENAME
     This function returns the mode bits of FILENAME, as an integer.
     The mode bits are also called the file permissions, and they
     specify access control in the usual Unix fashion.  If the
     low-order bit is 1, then the file is executable by all users, if
     the second-lowest-order bit is 1, then the file is writable by all
     users, etc.

     The highest value returnable is 4095 (7777 octal), meaning that
     everyone has read, write, and execute permission, that the SUID bit
     is set for both others and group, and that the sticky bit is set.

          (file-modes "~/junk/diffs")
               => 492               ; Decimal integer.
          (format "%o" 492)
               => "754"             ; Convert to octal.
          
          (set-file-modes "~/junk/diffs" 438)
               => nil
          
          (format "%o" 438)
               => "666"             ; Convert to octal.
          
          % ls -l diffs
            -rw-rw-rw-  1 lewis 0 3063 Oct 30 16:00 diffs

 - Function: file-nlinks FILENAME
     This functions returns the number of names (i.e., hard links) that
     file FILENAME has.  If the file does not exist, then this function
     returns `nil'.  Note that symbolic links have no effect on this
     function, because they are not considered to be names of the files
     they link to.

          % ls -l foo*
          -rw-rw-rw-  2 rms       4 Aug 19 01:27 foo
          -rw-rw-rw-  2 rms       4 Aug 19 01:27 foo1
          
          (file-nlinks "foo")
               => 2
          (file-nlinks "doesnt-exist")
               => nil

 - Function: file-attributes FILENAME
     This function returns a list of attributes of file FILENAME.  If
     the specified file cannot be opened, it returns `nil'.

     The elements of the list, in order, are:

       0. `t' for a directory, a string for a symbolic link (the name
          linked to), or `nil' for a text file.

       1. The number of names the file has.  Alternate names, also
          known as hard links, can be created by using the
          `add-name-to-file' function (*note Changing File
          Attributes::.).

       2. The file's UID.

       3. The file's GID.

       4. The time of last access, as a list of two integers.  The
          first integer has the high-order 16 bits of time, the second
          has the low 16 bits.  (This is similar to the value of
          `current-time'; see *Note Time of Day::.)

       5. The time of last modification as a list of two integers (as
          above).

       6. The time of last status change as a list of two integers (as
          above).

       7. The size of the file in bytes.

       8. The file's modes, as a string of ten letters or dashes, as in
          `ls -l'.

       9. `t' if the file's GID would change if file were deleted and
          recreated; `nil' otherwise.

      10. The file's inode number.

      11. The file system number of the file system that the file is
          in.  This element and the file's inode number together give
          enough information to distinguish any two files on the
          system--no two files can have the same values for both of
          these numbers.

     For example, here are the file attributes for `files.texi':

          (file-attributes "files.texi")
               =>  (nil
                    1
                    2235
                    75
                    (8489 20284)
                    (8489 20284)
                    (8489 20285)
                    14906
                    "-rw-rw-rw-"
                    nil
                    129500
                    -32252)

     and here is how the result is interpreted:

    `nil'
          is neither a directory nor a symbolic link.

    `1'
          has only one name (the name `files.texi' in the current
          default directory).

    `2235'
          is owned by the user with UID 2235.

    `75'
          is in the group with GID 75.

    `(8489 20284)'
          was last accessed on Aug 19 00:09.  Unfortunately, you cannot
          convert this number into a time string in Emacs.

    `(8489 20284)'
          was last modified on Aug 19 00:09.

    `(8489 20285)'
          last had its inode changed on Aug 19 00:09.

    `14906'
          is 14906 characters long.

    `"-rw-rw-rw-"'
          has a mode of read and write access for the owner, group, and
          world.

    `nil'
          would retain the same GID if it were recreated.

    `129500'
          has an inode number of 129500.

    `-32252'
          is on file system number -32252.


File: elisp,  Node: Changing File Attributes,  Next: File Names,  Prev: Information about Files,  Up: Files

Changing File Names and Attributes
==================================

   The functions in this section rename, copy, delete, link, and set the
modes of files.

   In the functions that have an argument NEWNAME, if a file by the
name of NEWNAME already exists, the actions taken depend on the value
of the argument OK-IF-ALREADY-EXISTS:

   * Signal a `file-already-exists' error if OK-IF-ALREADY-EXISTS is
     `nil'.

   * Request confirmation if OK-IF-ALREADY-EXISTS is a number.

   * Replace the old file without confirmation if OK-IF-ALREADY-EXISTS
     is any other value.

 - Function: add-name-to-file OLDNAME NEWNAME &optional
          OK-IF-ALREADY-EXISTS
     This function gives the file named OLDNAME the additional name
     NEWNAME.  This means that NEWNAME becomes a new "hard link" to
     OLDNAME.

     In the first part of the following example, we list two files,
     `foo' and `foo3'.

          % ls -l fo*
          -rw-rw-rw-  1 rms       29 Aug 18 20:32 foo
          -rw-rw-rw-  1 rms       24 Aug 18 20:31 foo3

     Then we evaluate the form `(add-name-to-file "~/lewis/foo"
     "~/lewis/foo2")'.  Again we list the files.  This shows two names,
     `foo' and `foo2'.

          (add-name-to-file "~/lewis/foo1" "~/lewis/foo2")
               => nil
          
          % ls -l fo*
          -rw-rw-rw-  2 rms       29 Aug 18 20:32 foo
          -rw-rw-rw-  2 rms       29 Aug 18 20:32 foo2
          -rw-rw-rw-  1 rms       24 Aug 18 20:31 foo3

     Finally, we evaluate the following:

          (add-name-to-file "~/lewis/foo" "~/lewis/foo3" t)

     and list the files again.  Now there are three names for one file:
     `foo', `foo2', and `foo3'.  The old contents of `foo3' are lost.

          (add-name-to-file "~/lewis/foo1" "~/lewis/foo3")
               => nil
          
          % ls -l fo*
          -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo
          -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo2
          -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo3

     This function is meaningless on VMS, where multiple names for one
     file are not allowed.

     See also `file-nlinks' in *Note File Attributes::.

 - Command: rename-file FILENAME NEWNAME &optional OK-IF-ALREADY-EXISTS
     This command renames the file FILENAME as NEWNAME.

     If FILENAME has additional names aside from FILENAME, it continues
     to have those names.  In fact, adding the name NEWNAME with
     `add-name-to-file' and then deleting FILENAME has the same effect
     as renaming, aside from momentary intermediate states.

     In an interactive call, this function prompts for FILENAME and
     NEWNAME in the minibuffer; also, it requests confirmation if
     NEWNAME already exists.

 - Command: copy-file OLDNAME NEWNAME &optional OK-IF-EXISTS TIME
     This command copies the file OLDNAME to NEWNAME.  An error is
     signaled if OLDNAME does not exist.

     If TIME is non-`nil', then this functions gives the new file the
     same last-modified time that the old one has.  (This works on only
     some operating systems.)

     In an interactive call, this function prompts for FILENAME and
     NEWNAME in the minibuffer; also, it requests confirmation if
     NEWNAME already exists.

 - Command: delete-file FILENAME
     This command deletes the file FILENAME, like the shell command `rm
     FILENAME'.  If the file has multiple names, it continues to exist
     under the other names.

     A suitable kind of `file-error' error is signaled if the file does
     not exist, or is not deletable.  (On Unix, a file is deletable if
     its directory is writable.)

     See also `delete-directory' in *Note Create/Delete Dirs::.

 - Command: make-symbolic-link FILENAME NEWNAME &optional OK-IF-EXISTS
     This command makes a symbolic link to FILENAME, named NEWNAME.
     This is like the shell command `ln -s FILENAME NEWNAME'.

     In an interactive call, this function prompts for FILENAME and
     NEWNAME in the minibuffer; also, it requests confirmation if
     NEWNAME already exists.

 - Function: define-logical-name VARNAME STRING
     This function defines the logical name NAME to have the value
     STRING.  It is available only on VMS.

 - Function: set-file-modes FILENAME MODE
     This function sets mode bits of FILENAME to MODE (which must be an
     integer).  Only the low 12 bits of MODE are used.

 - Function: set-default-file-modes MODE
     This function sets the default file protection for new files
     created by Emacs and its subprocesses.  Every file created with
     Emacs initially has this protection.  On Unix, the default
     protection is the bitwise complement of the "umask" value.

     The argument MODE must be an integer.  Only the low 9 bits of MODE
     are used.

     Saving a modified version of an existing file does not count as
     creating the file; it does not change the file's mode, and does
     not use the default file protection.

 - Function: default-file-modes
     This function returns the current default protection value.

   On MS-DOS, there is no such thing as an "executable" file mode bit.
So Emacs considers a file executable if its name ends in `.com', `.bat'
or `.exe'.  This is reflected in the values returned by `file-modes'
and `file-attributes'.


File: elisp,  Node: File Names,  Next: Contents of Directories,  Prev: Changing File Attributes,  Up: Files

File Names
==========

   Files are generally referred to by their names, in Emacs as
elsewhere.  File names in Emacs are represented as strings.  The
functions that operate on a file all expect a file name argument.

   In addition to operating on files themselves, Emacs Lisp programs
often need to operate on the names; i.e., to take them apart and to use
part of a name to construct related file names.  This section describes
how to manipulate file names.

   The functions in this section do not actually access files, so they
can operate on file names that do not refer to an existing file or
directory.

   On VMS, all these functions understand both VMS file-name syntax and
Unix syntax.  This is so that all the standard Lisp libraries can
specify file names in Unix syntax and work properly on VMS without
change.  On MS-DOS, these functions understand MS-DOS file-name syntax
as well as Unix syntax.

* Menu:

* File Name Components::  The directory part of a file name, and the rest.
* Directory Names::       A directory's name as a directory
                            is different from its name as a file.
* Relative File Names::   Some file names are relative to a current directory.
* File Name Expansion::   Converting relative file names to absolute ones.
* Unique File Names::     Generating names for temporary files.
* File Name Completion::  Finding the completions for a given file name.


File: elisp,  Node: File Name Components,  Next: Directory Names,  Up: File Names

File Name Components
--------------------

   The operating system groups files into directories.  To specify a
file, you must specify the directory and the file's name within that
directory.  Therefore, Emacs considers a file name as having two main
parts: the "directory name" part, and the "nondirectory" part (or "file
name within the directory").  Either part may be empty.  Concatenating
these two parts reproduces the original file name.

   On Unix, the directory part is everything up to and including the
last slash; the nondirectory part is the rest.  The rules in VMS syntax
are complicated.

   For some purposes, the nondirectory part is further subdivided into
the name proper and the "version number".  On Unix, only backup files
have version numbers in their names; on VMS, every file has a version
number, but most of the time the file name actually used in Emacs omits
the version number.  Version numbers are found mostly in directory
lists.

 - Function: file-name-directory FILENAME
     This function returns the directory part of FILENAME (or `nil' if
     FILENAME does not include a directory part).  On Unix, the
     function returns a string ending in a slash.  On VMS, it returns a
     string ending in one of the three characters `:', `]', or `>'.

          (file-name-directory "lewis/foo")  ; Unix example
               => "lewis/"
          (file-name-directory "foo")        ; Unix example
               => nil
          (file-name-directory "[X]FOO.TMP") ; VMS example
               => "[X]"

 - Function: file-name-nondirectory FILENAME
     This function returns the nondirectory part of FILENAME.

          (file-name-nondirectory "lewis/foo")
               => "foo"
          (file-name-nondirectory "foo")
               => "foo"
          ;; The following example is accurate only on VMS.
          (file-name-nondirectory "[X]FOO.TMP")
               => "FOO.TMP"

 - Function: file-name-sans-versions FILENAME
     This function returns FILENAME without any file version numbers,
     backup version numbers, or trailing tildes.

          (file-name-sans-versions "~rms/foo.~1~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               => "~rms/foo"
          ;; The following example applies to VMS only.
          (file-name-sans-versions "foo;23")
               => "foo"


File: elisp,  Node: Directory Names,  Next: Relative File Names,  Prev: File Name Components,  Up: File Names

Directory Names
---------------

   A "directory name" is the name of a directory.  A directory is a
kind of file, and it has a file name, which is related to the directory
name but not identical to it.  (This is not quite the same as the usual
Unix terminology.)  These two different names for the same entity are
related by a syntactic transformation.  On Unix, this is simple: a
directory name ends in a slash, whereas the directory's name as a file
lacks that slash.  On VMS, the relationship is more complicated.

   The difference between a directory name and its name as a file is
subtle but crucial.  When an Emacs variable or function argument is
described as being a directory name, a file name of a directory is not
acceptable.

   The following two functions convert between directory names and file
names.  They do nothing special with environment variable substitutions
such as `$HOME', and the constructs `~', and `..'.

 - Function: file-name-as-directory FILENAME
     This function returns a string representing FILENAME in a form
     that the operating system will interpret as the name of a
     directory.  In Unix, this means appending a slash to the string.
     On VMS, the function converts a string of the form `[X]Y.DIR.1' to
     the form `[X.Y]'.

          (file-name-as-directory "~rms/lewis")
               => "~rms/lewis/"

 - Function: directory-file-name DIRNAME
     This function returns a string representing DIRNAME in a form that
     the operating system will interpret as the name of a file.  On
     Unix, this means removing a final slash from the string.  On VMS,
     the function converts a string of the form `[X.Y]' to `[X]Y.DIR.1'.

          (directory-file-name "~lewis/")
               => "~lewis"

   Directory name abbreviations are useful for directories that are
normally accessed through symbolic links.  Sometimes the users recognize
primarily the link's name as "the name" of the directory, and find it
annoying to see the directory's "real" name.  If you define the link
name as an abbreviation for the "real" name, Emacs shows users the
abbreviation instead.

 - Variable: directory-abbrev-alist
     The variable `directory-abbrev-alist' contains an alist of
     abbreviations to use for file directories.  Each element has the
     form `(FROM . TO)', and says to replace FROM with TO when it
     appears in a directory name.  The FROM string is actually a
     regular expression; it should always start with `^'.  The function
     `abbreviate-file-name' performs these substitutions.

     You can set this variable in `site-init.el' to describe the
     abbreviations appropriate for your site.

     Here's an example, from a system on which file system `/home/fsf'
     and so on are normally accessed through symbolic links named `/fsf'
     and so on.

          (("^/home/fsf" . "/fsf")
           ("^/home/gp" . "/gp")
           ("^/home/gd" . "/gd"))

   To convert a directory name to its abbreviation, use this function:

 - Function: abbreviate-file-name DIRNAME
     This function applies abbreviations from `directory-abbrev-alist'
     to its argument, and substitutes `~' for the user's home directory.


File: elisp,  Node: Relative File Names,  Next: File Name Expansion,  Prev: Directory Names,  Up: File Names

Absolute and Relative File Names
--------------------------------

   All the directories in the file system form a tree starting at the
root directory.  A file name can specify all the directory names
starting from the root of the tree; then it is called an "absolute"
file name.  Or it can specify the position of the file in the tree
relative to a default directory; then it is called a "relative" file
name.  On Unix, an absolute file name starts with a slash or a tilde
(`~'), and a relative one does not.  The rules on VMS are complicated.

 - Function: file-name-absolute-p FILENAME
     This function returns `t' if file FILENAME is an absolute file
     name, `nil' otherwise.  On VMS, this function understands both
     Unix syntax and VMS syntax.

          (file-name-absolute-p "~rms/foo")
               => t
          (file-name-absolute-p "rms/foo")
               => nil
          (file-name-absolute-p "/user/rms/foo")
               => t


File: elisp,  Node: File Name Expansion,  Next: Unique File Names,  Prev: Relative File Names,  Up: File Names

Functions that Expand Filenames
-------------------------------

   "Expansion" of a file name means converting a relative file name to
an absolute one.  Since this is done relative to a default directory,
you must specify the default directory name as well as the file name to
be expanded.  Expansion also simplifies file names by eliminating
redundancies such as `./' and `NAME/../'.

 - Function: expand-file-name FILENAME &optional DIRECTORY
     This function converts FILENAME to an absolute file name.  If
     DIRECTORY is supplied, it is the directory to start with if
     FILENAME is relative.  (The value of DIRECTORY should itself be an
     absolute directory name; it may start with `~'.) Otherwise, the
     current buffer's value of `default-directory' is used.  For
     example:

          (expand-file-name "foo")
               => "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               => "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               => "/usr/spool/foo"
          (expand-file-name "$HOME/foo")
               => "/xcssun/users/rms/lewis/$HOME/foo"

     Filenames containing `.' or `..' are simplified to their canonical
     form:

          (expand-file-name "bar/../foo")
               => "/xcssun/users/rms/lewis/foo"

     `~/' is expanded into the user's home directory.  A `/' or `~'
     following a `/' is taken to be the start of an absolute file name
     that overrides what precedes it, so everything before that `/' or
     `~' is deleted.  For example:

          (expand-file-name
           "/a1/gnu//usr/local/lib/emacs/etc/MACHINES")
               => "/usr/local/lib/emacs/etc/MACHINES"
          (expand-file-name "/a1/gnu/~/foo")
               => "/xcssun/users/rms/foo"

     In both cases, `/a1/gnu/' is discarded because an absolute file
     name follows it.

     Note that `expand-file-name' does *not* expand environment
     variables; only `substitute-in-file-name' does that.

 - Function: file-relative-name FILENAME DIRECTORY
     This function does the inverse of expansion--it tries to return a
     relative name that is equivalent to FILENAME when interpreted
     relative to DIRECTORY.  (If such a relative name would be longer
     than the absolute name, it returns the absolute name instead.)

          (file-relative-name "/foo/bar" "/foo/")
               => "bar")
          (file-relative-name "/foo/bar" "/hack/")
               => "/foo/bar")

 - Variable: default-directory
     The value of this buffer-local variable is the default directory
     for the current buffer.  It should be an absolute directory name;
     it may start with `~'.  This variable is local in every buffer.

     `expand-file-name' uses the default directory when its second
     argument is `nil'.

     On Unix systems, the value is always a string ending with a slash.

          default-directory
               => "/user/lewis/manual/"

 - Function: substitute-in-file-name FILENAME
     This function replaces environment variables references in
     FILENAME with the environment variable values.  Following standard
     Unix shell syntax, `$' is the prefix to substitute an environment
     variable value.

     The environment variable name is the series of alphanumeric
     characters (including underscores) that follow the `$'.  If the
     character following the `$' is a `{', then the variable name is
     everything up to the matching `}'.

     Here we assume that the environment variable `HOME', which holds
     the user's home directory name, has value `/xcssun/users/rms'.

          (substitute-in-file-name "$HOME/foo")
               => "/xcssun/users/rms/foo"

     If a `~' or a `/' appears following a `/', after substitution,
     everything before the following `/' is discarded:

          (substitute-in-file-name "bar/~/foo")
               => "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               => "/xcssun/users/rms/foo"

     On VMS, `$' substitution is not done, so this function does nothing
     on VMS except discard superfluous initial components as shown
     above.


File: elisp,  Node: Unique File Names,  Next: File Name Completion,  Prev: File Name Expansion,  Up: File Names

Generating Unique File Names
----------------------------

   Some programs need to write temporary files.  Here is the usual way
to construct a name for such a file:

     (make-temp-name (concat "/tmp/" NAME-OF-APPLICATION))

Here we use the directory `/tmp/' because that is the standard place on
Unix for temporary files.  The job of `make-temp-name' is to prevent
two different users or two different jobs from trying to use the same
name.

 - Function: make-temp-name STRING
     This function generates string that can be used as a unique name.
     The name starts with STRING, and ends with a number that is
     different in each Emacs job.

          (make-temp-name "/tmp/foo")
               => "/tmp/foo021304"

     To prevent conflicts among different libraries running in the same
     Emacs, each Lisp program that uses `make-temp-name' should have its
     own STRING.  The number added to the end of the name distinguishes
     between the same application running in different Emacs jobs.


File: elisp,  Node: File Name Completion,  Prev: Unique File Names,  Up: File Names

File Name Completion
--------------------

   This section describes low-level subroutines for completing a file
name.  For other completion functions, see *Note Completion::.

 - Function: file-name-all-completions PARTIAL-FILENAME DIRECTORY
     This function returns a list of all possible completions for a file
     whose name starts with PARTIAL-FILENAME in directory DIRECTORY.
     The order of the completions is the order of the files in the
     directory, which is unpredictable and conveys no useful
     information.

     The argument PARTIAL-FILENAME must be a file name containing no
     directory part and no slash.  The current buffer's default
     directory is prepended to DIRECTORY, if DIRECTORY is not absolute.

     In the following example, suppose that the current default
     directory, `~rms/lewis', has five files whose names begin with `f':
     `foo', `file~', `file.c', `file.c.~1~', and `file.c.~2~'.

          (file-name-all-completions "f" "")
               => ("foo" "file~" "file.c.~2~"
                          "file.c.~1~" "file.c")
          
          (file-name-all-completions "fo" "")
               => ("foo")

 - Function: file-name-completion FILENAME DIRECTORY
     This function completes the file name FILENAME in directory
     DIRECTORY.  It returns the longest prefix common to all file names
     in directory DIRECTORY that start with FILENAME.

     If only one match exists and FILENAME matches it exactly, the
     function returns `t'.  The function returns `nil' if directory
     DIRECTORY contains no name starting with FILENAME.

     In the following example, suppose that the current default
     directory has five files whose names begin with `f': `foo',
     `file~', `file.c', `file.c.~1~', and `file.c.~2~'.

          (file-name-completion "fi" "")
               => "file"
          
          (file-name-completion "file.c.~1" "")
               => "file.c.~1~"
          
          (file-name-completion "file.c.~1~" "")
               => t
          
          (file-name-completion "file.c.~3" "")
               => nil

 - User Option: completion-ignored-extensions
     `file-name-completion' usually ignores file names that end in any
     string in this list.  It does not ignore them when all the possible
     completions end in one of these suffixes or when a buffer showing
     all possible completions is displayed.

     A typical value might look like this:

          completion-ignored-extensions
               => (".o" ".elc" "~" ".dvi")


File: elisp,  Node: Contents of Directories,  Next: Create/Delete Dirs,  Prev: File Names,  Up: Files

Contents of Directories
=======================

   A directory is a kind of file that contains other files entered under
various names.  Directories are a feature of the file system.

   Emacs can list the names of the files in a directory as a Lisp list,
or display the names in a buffer using the `ls' shell command.  In the
latter case, it can optionally display information about each file,
depending on the options passed to the `ls' command.

 - Function: directory-files DIRECTORY &optional FULL-NAME MATCH-REGEXP
          NOSORT
     This function returns a list of the names of the files in the
     directory DIRECTORY.  By default, the list is in alphabetical
     order.

     If FULL-NAME is non-`nil', the function returns the files'
     absolute file names.  Otherwise, it returns the names relative to
     the specified directory.

     If MATCH-REGEXP is non-`nil', this function returns only those
     file names that contain a match for that regular expression--the
     other file names are excluded from the list.

     If NOSORT is non-`nil', `directory-files' does not sort the list,
     so you get the file names in no particular order.  Use this if you
     want the utmost possible speed and don't care what order the files
     are processed in.  If the order of processing is visible to the
     user, then the user will probably be happier if you do sort the
     names.

          (directory-files "~lewis")
               => ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi"
                   "files.texi.~1~")

     An error is signaled if DIRECTORY is not the name of a directory
     that can be read.

 - Function: file-name-all-versions FILE DIRNAME
     This function returns a list of all versions of the file named
     FILE in directory DIRNAME.

 - Function: insert-directory FILE SWITCHES &optional WILDCARD
          FULL-DIRECTORY-P
     This function inserts (in the current buffer) a directory listing
     for directory FILE, formatted with `ls' according to SWITCHES.  It
     leaves point after the inserted text.

     The argument FILE may be either a directory name or a file
     specification including wildcard characters.  If WILDCARD is
     non-`nil', that means treat FILE as a file specification with
     wildcards.

     If FULL-DIRECTORY-P is non-`nil', that means FILE is a directory
     and switches do not contain `-d', so that the listing should show
     the full contents of the directory.  (The `-d' option to `ls' says
     to describe a directory itself rather than its contents.)

     This function works by running a directory listing program whose
     name is in the variable `insert-directory-program'.  If WILDCARD is
     non-`nil', it also runs the shell specified by `shell-file-name',
     to expand the wildcards.

 - Variable: insert-directory-program
     This variable's value is the program to run to generate a
     directory listing for the function `insert-directory'.


File: elisp,  Node: Create/Delete Dirs,  Next: Magic File Names,  Prev: Contents of Directories,  Up: Files

Creating and Deleting Directories
=================================

 - Function: make-directory DIRNAME
     This function creates a directory named DIRNAME.

 - Function: delete-directory DIRNAME
     This function deletes the directory named DIRNAME.  The function
     `delete-file' does not work for files that are directories; you
     must use `delete-directory' in that case.


File: elisp,  Node: Magic File Names,  Next: Files and MS-DOS,  Prev: Create/Delete Dirs,  Up: Files

Making Certain File Names "Magic"
=================================

   You can implement special handling for certain file names.  This is
called making those names "magic".  You must supply a regular
expression to define the class of names (all those that match the
regular expression), plus a handler that implements all the primitive
Emacs file operations for file names that do match.

   The variable `file-name-handler-alist' holds a list of handlers,
together with regular expressions that determine when to apply each
handler.  Each element has this form:

     (REGEXP . HANDLER)

All the Emacs primitives for file access and file name transformation
check the given file name against `file-name-handler-alist'.  If the
file name matches REGEXP, the primitives handle that file by calling
HANDLER.

   The first argument given to HANDLER is the name of the primitive;
the remaining arguments are the arguments that were passed to that
operation.  (The first of these arguments is typically the file name
itself.)  For example, if you do this:

     (file-exists-p FILENAME)

and FILENAME has handler HANDLER, then HANDLER is called like this:

     (funcall HANDLER 'file-exists-p FILENAME)

   Here are the operations that a magic file name handler gets to
handle:

`add-name-to-file', `copy-file', `delete-directory', `delete-file',
`directory-file-name', `diff-latest-backup-file', `directory-files',
`dired-compress-file', `dired-uncache', `expand-file-name',
`file-accessible-directory-p', `file-attributes', `file-directory-p',
`file-executable-p', `file-exists-p', `file-local-copy', `file-modes',
`file-name-all-completions', `file-name-as-directory',
`file-name-completion', `file-name-directory', `file-name-nondirectory',
`file-name-sans-versions', `file-newer-than-file-p', `file-readable-p',
`file-symlink-p', `file-truename', `file-writable-p',
`insert-directory',
`insert-file-contents', `load', `make-directory', `make-symbolic-link',
`rename-file', `set-file-modes', `set-visited-file-modtime',
`unhandled-file-name-directory', `verify-visited-file-modtime',
`write-region'.

   The handler function must handle all of the above operations, and
possibly others to be added in the future.  It need not implement all
these operations itself--when it has nothing special to do for a
certain operation, it can reinvoke the primitive, to handle the
operation "in the usual way".  It should always reinvoke the primitive
for an operation it does not recognize.  Here's one way to do this:

     (defun my-file-handler (operation &rest args)
       ;; First check for the specific operations
       ;; that we have special handling for.
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; Handle any operation we don't know about.
             (t (let ((inhibit-file-name-handlers
                      (cons 'my-file-handler
                            (and (eq inhibit-file-name-operation operation)
                                 inhibit-file-name-handlers)))
                     (inhibit-file-name-operation operation))
                  (apply operation args)))))

   When a handler function decides to call the ordinary Emacs primitive
for the operation at hand, it needs to prevent the primitive from
calling the same handler once again, thus leading to an infinite
recursion.  The example above shows how to do this, with the variables
`inhibit-file-name-handlers' and `inhibit-file-name-operation'.  Be
careful to use them exactly as shown above; the details are crucial for
proper behavior in the case of multiple handlers, and for operations
that have two file names that may each have handlers.

 - Variable: inhibit-file-name-handlers
     This variable holds a list of handlers whose use is presently
     inhibited for a certain operation.

 - Variable: inhibit-file-name-operation
     The operation for which certain handlers are presently inhibited.

 - Function: find-file-name-handler FILE OPERATION
     This function returns the handler function for file name FILE, or
     `nil' if there is none.  The argument OPERATION should be the
     operation to be performed on the file--the value you will pass to
     the handler as its first argument when you call it.  The operation
     is needed for comparison with `inhibit-file-name-operation'.

 - Function: file-local-copy FILENAME
     This function copies file FILENAME to an ordinary non-magic file,
     if it isn't one already.

     If FILENAME specifies a "magic" file name, which programs outside
     Emacs cannot directly read or write, this copies the contents to
     an ordinary file and returns that file's name.

     If FILENAME is an ordinary file name, not magic, then this function
     does nothing and returns `nil'.

 - Function: unhandled-file-name-directory FILENAME
     This function returns the name of a directory that is not magic.
     It uses the directory part of FILENAME if that is not magic.
     Otherwise, it asks the handler what to do.

     This is useful for running a subprocess; every subprocess must
     have a non-magic directory to serve as its current directory, and
     this function is a good way to come up with one.


File: elisp,  Node: Files and MS-DOS,  Prev: Magic File Names,  Up: Files

Files and MS-DOS
================

   Emacs on MS-DOS makes a distinction between text files and binary
files.  This is necessary because ordinary text files on MS-DOS use a
two character sequence between lines: carriage-return and linefeed
(CRLF).  Emacs expects just a newline character (a linefeed) between
lines.  When Emacs reads or writes a text file on MS-DOS, it needs to
convert the line separators.  This means it needs to know which files
are text files and which are binary.  It makes this decision when
visiting a file, and records the decision in the variable
`buffer-file-type' for use when the file is saved.

   *Note MS-DOS Subprocesses::, for a related feature for subprocesses.

 - Variable: buffer-file-type
     This variable, automatically local in each buffer, records the
     file type of the buffer's visited file.  The value is `nil' for
     text, `t' for binary.

 - Function: find-buffer-file-type FILENAME
     This function determines whether file FILENAME is a text file or a
     binary file.  It returns `nil' for text, `t' for binary.

 - User Option: file-name-buffer-file-type-alist
     This variable holds an alist for distinguishing text files from
     binary files.  Each element has the form (REGEXP . TYPE), where
     REGEXP is matched against the file name, and TYPE may be is `nil'
     for text, `t' for binary, or a function to call to compute which.
     If it is a function, then it is called with a single argument (the
     file name) and should return `t' or `nil'.

 - User Option: default-buffer-file-type
     This variable specifies the default file type for files whose names
     don't indicate anything in particular.  Its value should be `nil'
     for text, or `t' for binary.

 - Command: find-file-text FILENAME
     Like `find-file', but treat the file as text regardless of its
     name.

 - Command: find-file-binary FILENAME
     Like `find-file', but treat the file as binary regardless of its
     name.


File: elisp,  Node: Backups and Auto-Saving,  Next: Buffers,  Prev: Files,  Up: Top

Backups and Auto-Saving
***********************

   Backup files and auto-save files are two methods by which Emacs tries
to protect the user from the consequences of crashes or of the user's
own errors.  Auto-saving preserves the text from earlier in the current
editing session; backup files preserve file contents prior to the
current session.

* Menu:

* Backup Files::   How backup files are made; how their names are chosen.
* Auto-Saving::    How auto-save files are made; how their names are chosen.
* Reverting::      `revert-buffer', and how to customize what it does.


File: elisp,  Node: Backup Files,  Next: Auto-Saving,  Up: Backups and Auto-Saving

Backup Files
============

   A "backup file" is a copy of the old contents of a file you are
editing.  Emacs makes a backup file the first time you save a buffer
into its visited file.  Normally, this means that the backup file
contains the contents of the file as it was before the current editing
session.  The contents of the backup file normally remain unchanged once
it exists.

   Backups are usually made by renaming the visited file to a new name.
Optionally, you can specify that backup files should be made by copying
the visited file.  This choice makes a difference for files with
multiple names; it also can affect whether the edited file remains owned
by the original owner or becomes owned by the user editing it.

   By default, Emacs makes a single backup file for each file edited.
You can alternatively request numbered backups; then each new backup
file gets a new name.  You can delete old numbered backups when you
don't want them any more, or Emacs can delete them automatically.

* Menu:

* Making Backups::     How Emacs makes backup files, and when.
* Rename or Copy::     Two alternatives: renaming the old file or copying it.
* Numbered Backups::   Keeping multiple backups for each source file.
* Backup Names::       How backup file names are computed; customization.

