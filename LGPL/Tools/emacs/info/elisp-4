This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is the edition 2.3 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 19.23.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Float Basics,  Next: Predicates on Numbers,  Prev: Integer Basics,  Up: Numbers

Floating Point Basics
=====================

   Emacs version 19 supports floating point numbers, if compiled with
the macro `LISP_FLOAT_TYPE' defined.  The precise range of floating
point numbers is machine-specific; it is the same as the range of the C
data type `double' on the machine in question.

   The printed representation for floating point numbers requires either
a decimal point (with at least one digit following), an exponent, or
both.  For example, `1500.0', `15e2', `15.0e2', `1.5e3', and `.15e4'
are five ways of writing a floating point number whose value is 1500.
They are all equivalent.  You can also use a minus sign to write
negative floating point numbers, as in `-1.0'.

   Most modern computers support the IEEE floating point standard, which
provides for positive infinity and negative infinity as floating point
values.  It also provides for a class of values called NaN or
"not-a-number"; numerical functions return such values in cases where
there is no correct answer.  For example, `(sqrt -1.0)' returns a NaN.
For practical purposes, there's no significant difference between
different NaN values in Emacs Lisp, and there's no rule for precisely
which NaN value should be used in a particular case, so this manual
doesn't try to distinguish them.  Emacs Lisp has no read syntax for NaNs
or infinities; perhaps we should create a syntax in the future.

   You can use `logb' to extract the binary exponent of a floating
point number (or estimate the logarithm of an integer):

 - Function: logb NUMBER
     This function returns the binary exponent of NUMBER.  More
     precisely, the value is the logarithm of NUMBER base 2, rounded
     down to an integer.


File: elisp,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Float Basics,  Up: Numbers

Type Predicates for Numbers
===========================

   The functions in this section test whether the argument is a number
or whether it is a certain sort of number.  The functions `integerp'
and `floatp' can take any type of Lisp object as argument (the
predicates would not be of much use otherwise); but the `zerop'
predicate requires a number as its argument.  See also
`integer-or-marker-p' and `number-or-marker-p', in *Note Predicates on
Markers::.

 - Function: floatp OBJECT
     This predicate tests whether its argument is a floating point
     number and returns `t' if so, `nil' otherwise.

     `floatp' does not exist in Emacs versions 18 and earlier.

 - Function: integerp OBJECT
     This predicate tests whether its argument is an integer, and
     returns `t' if so, `nil' otherwise.

 - Function: numberp OBJECT
     This predicate tests whether its argument is a number (either
     integer or floating point), and returns `t' if so, `nil' otherwise.

 - Function: wholenump OBJECT
     The `wholenump' predicate (whose name comes from the phrase
     "whole-number-p") tests to see whether its argument is a
     nonnegative integer, and returns `t' if so, `nil' otherwise.  0 is
     considered non-negative.

     `natnump' is an obsolete synonym for `wholenump'.

 - Function: zerop NUMBER
     This predicate tests whether its argument is zero, and returns `t'
     if so, `nil' otherwise.  The argument must be a number.

     These two forms are equivalent: `(zerop x)' == `(= x 0)'.


File: elisp,  Node: Comparison of Numbers,  Next: Numeric Conversions,  Prev: Predicates on Numbers,  Up: Numbers

Comparison of Numbers
=====================

   To test numbers for numerical equality, you should normally use `=',
not `eq'.  There can be many distinct floating point number objects
with the same numeric value.  If you use `eq' to compare them, then you
test whether two values are the same *object*.  By contrast, `='
compares only the numeric values of the objects.

   At present, each integer value has a unique Lisp object in Emacs
Lisp.  Therefore, `eq' is equivalent `=' where integers are concerned.
It is sometimes convenient to use `eq' for comparing an unknown value
with an integer, because `eq' does not report an error if the unknown
value is not a number--it accepts arguments of any type.  By contrast,
`=' signals an error if the arguments are not numbers or markers.
However, it is a good idea to use `=' if you can, even for comparing
integers, just in case we change the representation of integers in a
future Emacs version.

   There is another wrinkle: because floating point arithmetic is not
exact, it is often a bad idea to check for equality of two floating
point values.  Usually it is better to test for approximate equality.
Here's a function to do this:

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (< (/ (abs (- x y))
             (max (abs x) (abs y)))
          fuzz-factor))

     Common Lisp note: Comparing numbers in Common Lisp always requires
     `=' because Common Lisp implements multi-word integers, and two
     distinct integer objects can have the same numeric value.  Emacs
     Lisp can have just one integer object for any given value because
     it has a limited range of integer values.

 - Function: = NUMBER-OR-MARKER1 NUMBER-OR-MARKER2
     This function tests whether its arguments are numerically equal,
     and returns `t' if so, `nil' otherwise.

 - Function: /= NUMBER-OR-MARKER1 NUMBER-OR-MARKER2
     This function tests whether its arguments are numerically equal,
     and returns `t' if they are not, and `nil' if they are.

 - Function: < NUMBER-OR-MARKER1 NUMBER-OR-MARKER2
     This function tests whether its first argument is strictly less
     than its second argument.  It returns `t' if so, `nil' otherwise.

 - Function: <= NUMBER-OR-MARKER1 NUMBER-OR-MARKER2
     This function tests whether its first argument is less than or
     equal to its second argument.  It returns `t' if so, `nil'
     otherwise.

 - Function: > NUMBER-OR-MARKER1 NUMBER-OR-MARKER2
     This function tests whether its first argument is strictly greater
     than its second argument.  It returns `t' if so, `nil' otherwise.

 - Function: >= NUMBER-OR-MARKER1 NUMBER-OR-MARKER2
     This function tests whether its first argument is greater than or
     equal to its second argument.  It returns `t' if so, `nil'
     otherwise.

 - Function: max NUMBER-OR-MARKER &rest NUMBERS-OR-MARKERS
     This function returns the largest of its arguments.

          (max 20)
               => 20
          (max 1 2.5)
               => 2.5
          (max 1 3 2.5)
               => 3

 - Function: min NUMBER-OR-MARKER &rest NUMBERS-OR-MARKERS
     This function returns the smallest of its arguments.

          (min -4 1)
               => -4


File: elisp,  Node: Numeric Conversions,  Next: Arithmetic Operations,  Prev: Comparison of Numbers,  Up: Numbers

Numeric Conversions
===================

   To convert an integer to floating point, use the function `float'.

 - Function: float NUMBER
     This returns NUMBER converted to floating point.  If NUMBER is
     already a floating point number, `float' returns it unchanged.

   There are four functions to convert floating point numbers to
integers; they differ in how they round.  These functions accept
integer arguments also, and return such arguments unchanged.

 - Function: truncate NUMBER
     This returns NUMBER, converted to an integer by rounding towards
     zero.

 - Function: floor NUMBER &optional DIVISOR
     This returns NUMBER, converted to an integer by rounding downward
     (towards negative infinity).

     If DIVISOR is specified, NUMBER is divided by DIVISOR before the
     floor is taken; this is the division operation that corresponds to
     `mod'.  An `arith-error' results if DIVISOR is 0.

 - Function: ceiling NUMBER
     This returns NUMBER, converted to an integer by rounding upward
     (towards positive infinity).

 - Function: round NUMBER
     This returns NUMBER, converted to an integer by rounding towards
     the nearest integer.


File: elisp,  Node: Arithmetic Operations,  Next: Rounding Operations,  Prev: Numeric Conversions,  Up: Numbers

Arithmetic Operations
=====================

   Emacs Lisp provides the traditional four arithmetic operations:
addition, subtraction, multiplication, and division.  Remainder and
modulus functions supplement the division functions.  The functions to
add or subtract 1 are provided because they are traditional in Lisp and
commonly used.

   All of these functions except `%' return a floating point value if
any argument is floating.

   It is important to note that in GNU Emacs Lisp, arithmetic functions
do not check for overflow.  Thus `(1+ 8388607)' may evaluate to
-8388608, depending on your hardware.

 - Function: 1+ NUMBER-OR-MARKER
     This function returns NUMBER-OR-MARKER plus 1.  For example,

          (setq foo 4)
               => 4
          (1+ foo)
               => 5

     This function is not analogous to the C operator `++'--it does not
     increment a variable.  It just computes a sum.  Thus,

          foo
               => 4

     If you want to increment the variable, you must use `setq', like
     this:

          (setq foo (1+ foo))
               => 5

 - Function: 1- NUMBER-OR-MARKER
     This function returns NUMBER-OR-MARKER minus 1.

 - Function: abs NUMBER
     This returns the absolute value of NUMBER.

 - Function: + &rest NUMBERS-OR-MARKERS
     This function adds its arguments together.  When given no
     arguments, `+' returns 0.  It does not check for overflow.

          (+)
               => 0
          (+ 1)
               => 1
          (+ 1 2 3 4)
               => 10

 - Function: - &optional NUMBER-OR-MARKER &rest OTHER-NUMBERS-OR-MARKERS
     The `-' function serves two purposes: negation and subtraction.
     When `-' has a single argument, the value is the negative of the
     argument.  When there are multiple arguments, `-' subtracts each of
     the OTHER-NUMBERS-OR-MARKERS from NUMBER-OR-MARKER, cumulatively.
     If there are no arguments, the result is 0.  This function does
     not check for overflow.

          (- 10 1 2 3 4)
               => 0
          (- 10)
               => -10
          (-)
               => 0

 - Function: * &rest NUMBERS-OR-MARKERS
     This function multiplies its arguments together, and returns the
     product.  When given no arguments, `*' returns 1.  It does not
     check for overflow.

          (*)
               => 1
          (* 1)
               => 1
          (* 1 2 3 4)
               => 24

 - Function: / DIVIDEND DIVISOR &rest DIVISORS
     This function divides DIVIDEND by DIVISOR and returns the
     quotient.  If there are additional arguments DIVISORS, then it
     divides DIVIDEND by each divisor in turn.  Each argument may be a
     number or a marker.

     If all the arguments are integers, then the result is an integer
     too.  This means the result has to be rounded.  On most machines,
     the result is rounded towards zero after each division, but some
     machines may round differently with negative arguments.  This is
     because the Lisp function `/' is implemented using the C division
     operator, which also permits machine-dependent rounding.  As a
     practical matter, all known machines round in the standard fashion.

     If you divide by 0, an `arith-error' error is signaled.  (*Note
     Errors::.)

          (/ 6 2)
               => 3
          (/ 5 2)
               => 2
          (/ 25 3 2)
               => 4
          (/ -17 6)
               => -2

     The result of `(/ -17 6)' could in principle be -3 on some
     machines.

 - Function: % DIVIDEND DIVISOR
     This function returns the integer remainder after division of
     DIVIDEND by DIVISOR.  The arguments must be integers or markers.

     For negative arguments, the remainder is in principle
     machine-dependent since the quotient is; but in practice, all
     known machines behave alike.

     An `arith-error' results if DIVISOR is 0.

          (% 9 4)
               => 1
          (% -9 4)
               => -1
          (% 9 -4)
               => 1
          (% -9 -4)
               => -1

     For any two integers DIVIDEND and DIVISOR,

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND.

 - Function: mod DIVIDEND DIVISOR
     This function returns the value of DIVIDEND modulo DIVISOR; in
     other words, the remainder after division of DIVIDEND by DIVISOR,
     but with the same sign as DIVISOR.  The arguments must be numbers
     or markers.

     Unlike `%', `mod' returns a well-defined result for negative
     arguments.  It also permits floating point arguments; it rounds the
     quotient downward (towards minus infinity) to an integer, and uses
     that quotient to compute the remainder.

     An `arith-error' results if DIVISOR is 0.

          (mod 9 4)
               => 1
          (mod -9 4)
               => 3
          (mod 9 -4)
               => -3
          (mod -9 -4)
               => -1
          (mod 5.5 2.5)
               => .5

     For any two numbers DIVIDEND and DIVISOR,

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND, subject to rounding error if either
     argument is floating point.


File: elisp,  Node: Rounding Operations,  Next: Bitwise Operations,  Prev: Arithmetic Operations,  Up: Numbers

Rounding Operations
===================

   The functions `ffloor', `fceil', `fround' and `ftruncate' take a
floating point argument and return a floating point result whose value
is a nearby integer.  `ffloor' returns the nearest integer below;
`fceil', the nearest integer above; `ftruncate', the nearest integer in
the direction towards zero; `fround', the nearest integer.

 - Function: ffloor FLOAT
     This function rounds FLOAT to the next lower integral value, and
     returns that value as a floating point number.

 - Function: fceil FLOAT
     This function rounds FLOAT to the next higher integral value, and
     returns that value as a floating point number.

 - Function: ftruncate FLOAT
     This function rounds FLOAT towards zero to an integral value, and
     returns that value as a floating point number.

 - Function: fround FLOAT
     This function rounds FLOAT to the nearest integral value, and
     returns that value as a floating point number.


File: elisp,  Node: Bitwise Operations,  Next: Transcendental Functions,  Prev: Rounding Operations,  Up: Numbers

Bitwise Operations on Integers
==============================

   In a computer, an integer is represented as a binary number, a
sequence of "bits" (digits which are either zero or one).  A bitwise
operation acts on the individual bits of such a sequence.  For example,
"shifting" moves the whole sequence left or right one or more places,
reproducing the same pattern "moved over".

   The bitwise operations in Emacs Lisp apply only to integers.

 - Function: lsh INTEGER1 COUNT
     `lsh', which is an abbreviation for "logical shift", shifts the
     bits in INTEGER1 to the left COUNT places, or to the right if
     COUNT is negative, bringing zeros into the vacated bits.  If COUNT
     is negative, `lsh' shifts zeros into the leftmost
     (most-significant) bit, producing a positive result even if
     INTEGER1 is negative.  Contrast this with `ash', below.

     Here are two examples of `lsh', shifting a pattern of bits one
     place to the left.  We show only the low-order eight bits of the
     binary pattern; the rest are all zero.

          (lsh 5 1)
               => 10
          ;; Decimal 5 becomes decimal 10.
          00000101 => 00001010
          
          (lsh 7 1)
               => 14
          ;; Decimal 7 becomes decimal 14.
          00000111 => 00001110

     As the examples illustrate, shifting the pattern of bits one place
     to the left produces a number that is twice the value of the
     previous number.

     The function `lsh', like all Emacs Lisp arithmetic functions, does
     not check for overflow, so shifting left can discard significant
     bits and change the sign of the number.  For example, left
     shifting 8,388,607 produces -2 on a 24-bit machine:

          (lsh 8388607 1)          ; left shift
               => -2

     In binary, in the 24-bit implementation, the argument looks like
     this:

          ;; Decimal 8,388,607
          0111 1111  1111 1111  1111 1111

     which becomes the following when left shifted:

          ;; Decimal -2
          1111 1111  1111 1111  1111 1110

     Shifting the pattern of bits two places to the left produces
     results like this (with 8-bit binary numbers):

          (lsh 3 2)
               => 12
          ;; Decimal 3 becomes decimal 12.
          00000011 => 00001100

     On the other hand, shifting the pattern of bits one place to the
     right looks like this:

          (lsh 6 -1)
               => 3
          ;; Decimal 6 becomes decimal 3.
          00000110 => 00000011
          
          (lsh 5 -1)
               => 2
          ;; Decimal 5 becomes decimal 2.
          00000101 => 00000010

     As the example illustrates, shifting the pattern of bits one place
     to the right divides the value of the binary number by two,
     rounding downward.

 - Function: ash INTEGER1 COUNT
     `ash' ("arithmetic shift") shifts the bits in INTEGER1 to the left
     COUNT places, or to the right if COUNT is negative.

     `ash' gives the same results as `lsh' except when INTEGER1 and
     COUNT are both negative.  In that case, `ash' puts a one in the
     leftmost position, while `lsh' puts a zero in the leftmost
     position.

     Thus, with `ash', shifting the pattern of bits one place to the
     right looks like this:

          (ash -6 -1) => -3
          ;; Decimal -6 becomes decimal -3.
          1111 1111  1111 1111  1111 1010
               =>
          1111 1111  1111 1111  1111 1101

     In contrast, shifting the pattern of bits one place to the right
     with `lsh' looks like this:

          (lsh -6 -1) => 8388605
          ;; Decimal -6 becomes decimal 8,388,605.
          1111 1111  1111 1111  1111 1010
               =>
          0111 1111  1111 1111  1111 1101

     Here are other examples:

          ;               24-bit binary values
          
          (lsh 5 2)          ;   5  =  0000 0000  0000 0000  0000 0101
               => 20         ;      =  0000 0000  0000 0000  0001 0100

          (ash 5 2)
               => 20
          (lsh -5 2)         ;  -5  =  1111 1111  1111 1111  1111 1011
               => -20        ;      =  1111 1111  1111 1111  1110 1100
          (ash -5 2)
               => -20

          (lsh 5 -2)         ;   5  =  0000 0000  0000 0000  0000 0101
               => 1          ;      =  0000 0000  0000 0000  0000 0001

          (ash 5 -2)
               => 1

          (lsh -5 -2)        ;  -5  =  1111 1111  1111 1111  1111 1011
               => 4194302    ;      =  0011 1111  1111 1111  1111 1110

          (ash -5 -2)        ;  -5  =  1111 1111  1111 1111  1111 1011
               => -2         ;      =  1111 1111  1111 1111  1111 1110

 - Function: logand &rest INTS-OR-MARKERS
     This function returns the "logical and" of the arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in
     all the arguments.  ("Set" means that the value of the bit is 1
     rather than 0.)

     For example, using 4-bit binary numbers, the "logical and" of 13
     and 12 is 12: 1101 combined with 1100 produces 1100.  In both the
     binary numbers, the leftmost two bits are set (i.e., they are
     1's), so the leftmost two bits of the returned value are set.
     However, for the rightmost two bits, each is zero in at least one
     of the arguments, so the rightmost two bits of the returned value
     are 0's.

     Therefore,

          (logand 13 12)
               => 12

     If `logand' is not passed any argument, it returns a value of -1.
     This number is an identity element for `logand' because its binary
     representation consists entirely of ones.  If `logand' is passed
     just one argument, it returns that argument.

          ;                24-bit binary values
          
          (logand 14 13)     ; 14  =  0000 0000  0000 0000  0000 1110
                             ; 13  =  0000 0000  0000 0000  0000 1101
               => 12         ; 12  =  0000 0000  0000 0000  0000 1100

          (logand 14 13 4)   ; 14  =  0000 0000  0000 0000  0000 1110
                             ; 13  =  0000 0000  0000 0000  0000 1101
                             ;  4  =  0000 0000  0000 0000  0000 0100
               => 4          ;  4  =  0000 0000  0000 0000  0000 0100

          (logand)
               => -1         ; -1  =  1111 1111  1111 1111  1111 1111

 - Function: logior &rest INTS-OR-MARKERS
     This function returns the "inclusive or" of its arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in at
     least one of the arguments.  If there are no arguments, the result
     is zero, which is an identity element for this operation.  If
     `logior' is passed just one argument, it returns that argument.

          ;               24-bit binary values
          
          (logior 12 5)      ; 12  =  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000 0000  0000 0000  0000 0101
               => 13         ; 13  =  0000 0000  0000 0000  0000 1101

          (logior 12 5 7)    ; 12  =  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000 0000  0000 0000  0000 0101
                             ;  7  =  0000 0000  0000 0000  0000 0111
               => 15         ; 15  =  0000 0000  0000 0000  0000 1111

 - Function: logxor &rest INTS-OR-MARKERS
     This function returns the "exclusive or" of its arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in an
     odd number of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     `logxor' is passed just one argument, it returns that argument.

          ;               24-bit binary values
          
          (logxor 12 5)      ; 12  =  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000 0000  0000 0000  0000 0101
               => 9          ;  9  =  0000 0000  0000 0000  0000 1001

          (logxor 12 5 7)    ; 12  =  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000 0000  0000 0000  0000 0101
                             ;  7  =  0000 0000  0000 0000  0000 0111
               => 14         ; 14  =  0000 0000  0000 0000  0000 1110

 - Function: lognot INTEGER
     This function returns the logical complement of its argument: the
     Nth bit is one in the result if, and only if, the Nth bit is zero
     in INTEGER, and vice-versa.

          (lognot 5)
               => -6
          ;;  5  =  0000 0000  0000 0000  0000 0101
          ;; becomes
          ;; -6  =  1111 1111  1111 1111  1111 1010


File: elisp,  Node: Transcendental Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

Transcendental Functions
========================

   These mathematical functions are available if floating point is
supported.  They allow integers as well as floating point numbers as
arguments.

 - Function: sin ARG
 - Function: cos ARG
 - Function: tan ARG
     These are the ordinary trigonometric functions, with argument
     measured in radians.

 - Function: asin ARG
     The value of `(asin ARG)' is a number between -pi/2 and pi/2
     (inclusive) whose sine is ARG; if, however, ARG is out of range
     (outside [-1, 1]), then the result is a NaN.

 - Function: acos ARG
     The value of `(acos ARG)' is a number between 0 and pi (inclusive)
     whose cosine is ARG; if, however, ARG is out of range (outside
     [-1, 1]), then the result is a NaN.

 - Function: atan ARG
     The value of `(atan ARG)' is a number between -pi/2 and pi/2
     (exclusive) whose tangent is ARG.

 - Function: exp ARG
     This is the exponential function; it returns e to the power ARG.
     e is a fundamental mathematical constant also called the base of
     natural logarithms.

 - Function: log ARG &optional BASE
     This function returns the logarithm of ARG, with base BASE.  If
     you don't specify BASE, the base E is used.  If ARG is negative,
     the result is a NaN.

 - Function: log10 ARG
     This function returns the logarithm of ARG, with base 10.  If ARG
     is negative, the result is a NaN.  `(log10 X)' == `(log X 10)', at
     least approximately.

 - Function: expt X Y
     This function returns X raised to power Y.

 - Function: sqrt ARG
     This returns the square root of ARG.  If ARG is negative, the
     value is a NaN.


File: elisp,  Node: Random Numbers,  Prev: Transcendental Functions,  Up: Numbers

Random Numbers
==============

   A deterministic computer program cannot generate true random numbers.
For most purposes, "pseudo-random numbers" suffice.  A series of
pseudo-random numbers is generated in a deterministic fashion.  The
numbers are not truly random, but they have certain properties that
mimic a random series.  For example, all possible values occur equally
often in a pseudo-random series.

   In Emacs, pseudo-random numbers are generated from a "seed" number.
Starting from any given seed, the `random' function always generates
the same sequence of numbers.  Emacs always starts with the same seed
value, so the sequence of values of `random' is actually the same in
each Emacs run!  For example, in one operating system, the first call
to `(random)' after you start Emacs always returns -1457731, and the
second one always returns -7692030.  This repeatability is helpful for
debugging.

   If you want truly unpredictable random numbers, execute `(random
t)'.  This chooses a new seed based on the current time of day and on
Emacs's process ID number.

 - Function: random &optional LIMIT
     This function returns a pseudo-random integer.  Repeated calls
     return a series of pseudo-random integers.

     If LIMIT is `nil', then the value may in principle be any integer.
     If LIMIT is a positive integer, the value is chosen to be
     nonnegative and less than LIMIT (only in Emacs 19).

     If LIMIT is `t', it means to choose a new seed based on the
     current time of day and on Emacs's process ID number.

     On some machines, any integer representable in Lisp may be the
     result of `random'.  On other machines, the result can never be
     larger than a certain maximum or less than a certain (negative)
     minimum.


File: elisp,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

Strings and Characters
**********************

   A string in Emacs Lisp is an array that contains an ordered sequence
of characters.  Strings are used as names of symbols, buffers, and
files, to send messages to users, to hold text being copied between
buffers, and for many other purposes.  Because strings are so important,
Emacs Lisp has many functions expressly for manipulating them.  Emacs
Lisp programs use strings more often than individual characters.

   *Note Strings of Events::, for special considerations for strings of
keyboard character events.

* Menu:

* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting characters or strings and vice versa.
* Formatting Strings::        `format': Emacs's analog of `printf'.
* Character Case::            Case conversion functions.
* Case Table::		      Customizing case conversion.


File: elisp,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

String and Character Basics
===========================

   Strings in Emacs Lisp are arrays that contain an ordered sequence of
characters.  Characters are represented in Emacs Lisp as integers;
whether an integer was intended as a character or not is determined only
by how it is used.  Thus, strings really contain integers.

   The length of a string (like any array) is fixed and independent of
the string contents, and cannot be altered.  Strings in Lisp are *not*
terminated by a distinguished character code.  (By contrast, strings in
C are terminated by a character with ASCII code 0.) This means that any
character, including the null character (ASCII code 0), is a valid
element of a string.

   Since strings are considered arrays, you can operate on them with the
general array functions.  (*Note Sequences Arrays Vectors::.)  For
example, you can access or change individual characters in a string
using the functions `aref' and `aset' (*note Array Functions::.).

   Each character in a string is stored in a single byte.  Therefore,
numbers not in the range 0 to 255 are truncated when stored into a
string.  This means that a string takes up much less memory than a
vector of the same length.

   Sometimes key sequences are represented as strings.  When a string is
a key sequence, string elements in the range 128 to 255 represent meta
characters (which are extremely large integers) rather than keyboard
events in the range 128 to 255.

   Strings cannot hold characters that have the hyper, super or alt
modifiers; they can hold ASCII control characters, but no other control
characters.  They do not distinguish case in ASCII control characters.
*Note Character Type::, for more information about representation of
meta and other modifiers for keyboard input characters.

   Like a buffer, a string can contain text properties for the
characters in it, as well as the characters themselves.  *Note Text
Properties::.

   *Note Text::, for information about functions that display strings or
copy them into buffers.  *Note Character Type::, and *Note String
Type::, for information about the syntax of characters and strings.


File: elisp,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

The Predicates for Strings
==========================

   For more information about general sequence and array predicates,
see *Note Sequences Arrays Vectors::, and *Note Arrays::.

 - Function: stringp OBJECT
     This function returns `t' if OBJECT is a string, `nil' otherwise.

 - Function: char-or-string-p OBJECT
     This function returns `t' if OBJECT is a string or a character
     (i.e., an integer), `nil' otherwise.


File: elisp,  Node: Creating Strings,  Next: Text Comparison,  Prev: Predicates for Strings,  Up: Strings and Characters

Creating Strings
================

   The following functions create strings, either from scratch, or by
putting strings together, or by taking them apart.

 - Function: make-string COUNT CHARACTER
     This function returns a string made up of COUNT repetitions of
     CHARACTER.  If COUNT is negative, an error is signaled.

          (make-string 5 ?x)
               => "xxxxx"
          (make-string 0 ?x)
               => ""

     Other functions to compare with this one include `char-to-string'
     (*note String Conversion::.), `make-vector' (*note Vectors::.), and
     `make-list' (*note Building Lists::.).

 - Function: substring STRING START &optional END
     This function returns a new string which consists of those
     characters from STRING in the range from (and including) the
     character at the index START up to (but excluding) the character
     at the index END.  The first character is at index zero.

          (substring "abcdefg" 0 3)
               => "abc"

     Here the index for `a' is 0, the index for `b' is 1, and the index
     for `c' is 2.  Thus, three letters, `abc', are copied from the
     string `"abcdefg"'.  The index 3 marks the character position up
     to which the substring is copied.  The character whose index is 3
     is actually the fourth character in the string.

     A negative number counts from the end of the string, so that -1
     signifies the index of the last character of the string.  For
     example:

          (substring "abcdefg" -3 -1)
               => "ef"

     In this example, the index for `e' is -3, the index for `f' is -2,
     and the index for `g' is -1.  Therefore, `e' and `f' are included,
     and `g' is excluded.

     When `nil' is used as an index, it stands for the length of the
     string.  Thus,

          (substring "abcdefg" -3 nil)
               => "efg"

     Omitting the argument END is equivalent to specifying `nil'.  It
     follows that `(substring STRING 0)' returns a copy of all of
     STRING.

          (substring "abcdefg" 0)
               => "abcdefg"

     But we recommend `copy-sequence' for this purpose (*note Sequence
     Functions::.).

     A `wrong-type-argument' error is signaled if either START or END
     is not an integer or `nil'.  An `args-out-of-range' error is
     signaled if START indicates a character following END, or if
     either integer is out of range for STRING.

     Contrast this function with `buffer-substring' (*note Buffer
     Contents::.), which returns a string containing a portion of the
     text in the current buffer.  The beginning of a string is at index
     0, but the beginning of a buffer is at index 1.

 - Function: concat &rest SEQUENCES
     This function returns a new string consisting of the characters in
     the arguments passed to it.  The arguments may be strings, lists
     of numbers, or vectors of numbers; they are not themselves
     changed.  If `concat' receives no arguments, it returns an empty
     string.

          (concat "abc" "-def")
               => "abc-def"
          (concat "abc" (list 120 (+ 256 121)) [122])
               => "abcxyz"
          ;; `nil' is an empty sequence.
          (concat "abc" nil "-def")
               => "abc-def"
          (concat "The " "quick brown " "fox.")
               => "The quick brown fox."
          (concat)
               => ""

     The second example above shows how characters stored in strings are
     taken modulo 256.  In other words, each character in the string is
     stored in one byte.

     The `concat' function always constructs a new string that is not
     `eq' to any existing string.

     When an argument is an integer (not a sequence of integers), it is
     converted to a string of digits making up the decimal printed
     representation of the integer.  This special case exists for
     compatibility with Mocklisp, and we don't recommend you take
     advantage of it.  If you want to convert an integer to digits in
     this way, use `format' (*note Formatting Strings::.) or
     `number-to-string' (*note String Conversion::.).

          (concat 137)
               => "137"
          (concat 54 321)
               => "54321"

     For information about other concatenation functions, see the
     description of `mapconcat' in *Note Mapping Functions::, `vconcat'
     in *Note Vectors::, and `append' in *Note Building Lists::.


File: elisp,  Node: Text Comparison,  Next: String Conversion,  Prev: Creating Strings,  Up: Strings and Characters

Comparison of Characters and Strings
====================================

 - Function: char-equal CHARACTER1 CHARACTER2
     This function returns `t' if the arguments represent the same
     character, `nil' otherwise.  This function ignores differences in
     case if `case-fold-search' is non-`nil'.

          (char-equal ?x ?x)
               => t
          (char-to-string (+ 256 ?x))
               => "x"
          (char-equal ?x  (+ 256 ?x))
               => t

 - Function: string= STRING1 STRING2
     This function returns `t' if the characters of the two strings
     match exactly; case is significant.

          (string= "abc" "abc")
               => t
          (string= "abc" "ABC")
               => nil
          (string= "ab" "ABC")
               => nil

 - Function: string-equal STRING1 STRING2
     `string-equal' is another name for `string='.

 - Function: string< STRING1 STRING2
     This function compares two strings a character at a time.  First it
     scans both the strings at once to find the first pair of
     corresponding characters that do not match.  If the lesser
     character of those two is the character from STRING1, then STRING1
     is less, and this function returns `t'.  If the lesser character
     is the one from STRING2, then STRING1 is greater, and this
     function returns `nil'.  If the two strings match entirely, the
     value is `nil'.

     Pairs of characters are compared by their ASCII codes.  Keep in
     mind that lower case letters have higher numeric values in the
     ASCII character set than their upper case counterparts; numbers and
     many punctuation characters have a lower numeric value than upper
     case letters.

          (string< "abc" "abd")
               => t
          (string< "abd" "abc")
               => nil
          (string< "123" "abc")
               => t

     When the strings have different lengths, and they match up to the
     length of STRING1, then the result is `t'.  If they match up to
     the length of STRING2, the result is `nil'.  A string of no
     characters is less than any other string.

          (string< "" "abc")
               => t
          (string< "ab" "abc")
               => t
          (string< "abc" "")
               => nil
          (string< "abc" "ab")
               => nil
          (string< "" "")
               => nil

 - Function: string-lessp STRING1 STRING2
     `string-lessp' is another name for `string<'.

   See also `compare-buffer-substrings' in *Note Comparing Text::, for
a way to compare text in buffers.  The function `string-match', which
matches a regular expression against a string, can be used for a kind
of string comparison; see *Note Regexp Search::.


File: elisp,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

Conversion of Characters and Strings
====================================

   This section describes functions for conversions between characters,
strings and integers.  `format' and `prin1-to-string' (*note Output
Functions::.) can also convert Lisp objects into strings.
`read-from-string' (*note Input Functions::.) can "convert" a string
representation of a Lisp object into an object.

   *Note Documentation::, for functions that produce textual
descriptions of text characters and general input events
(`single-key-description' and `text-char-description').  These
functions are used primarily for making help messages.

 - Function: char-to-string CHARACTER
     This function returns a new string with a length of one character.
     The value of CHARACTER, modulo 256, is used to initialize the
     element of the string.

     This function is similar to `make-string' with an integer argument
     of 1.  (*Note Creating Strings::.)  This conversion can also be
     done with `format' using the `%c' format specification.  (*Note
     Formatting Strings::.)

          (char-to-string ?x)
               => "x"
          (char-to-string (+ 256 ?x))
               => "x"
          (make-string 1 ?x)
               => "x"

 - Function: string-to-char STRING
     This function returns the first character in STRING.  If the
     string is empty, the function returns 0.  The value is also 0 when
     the first character of STRING is the null character, ASCII code 0.

          (string-to-char "ABC")
               => 65
          (string-to-char "xyz")
               => 120
          (string-to-char "")
               => 0
          (string-to-char "\000")
               => 0

     This function may be eliminated in the future if it does not seem
     useful enough to retain.

 - Function: number-to-string NUMBER
     This function returns a string consisting of the printed
     representation of NUMBER, which may be an integer or a floating
     point number.  The value starts with a sign if the argument is
     negative.

          (number-to-string 256)
               => "256"
          (number-to-string -23)
               => "-23"
          (number-to-string -23.5)
               => "-23.5"

     `int-to-string' is a semi-obsolete alias for this function.

     See also the function `format' in *Note Formatting Strings::.

 - Function: string-to-number STRING
     This function returns the numeric value of the characters in
     STRING, read in base ten.  It skips spaces and tabs at the
     beginning of STRING, then reads as much of STRING as it can
     interpret as a number.  (On some systems it ignores other
     whitespace at the beginning, not just spaces and tabs.)  If the
     first character after the ignored whitespace is not a digit or a
     minus sign, this function returns 0.

          (string-to-number "256")
               => 256
          (string-to-number "25 is a perfect square.")
               => 25
          (string-to-number "X256")
               => 0
          (string-to-number "-4.5")
               => -4.5

     `string-to-int' is an obsolete alias for this function.


File: elisp,  Node: Formatting Strings,  Next: Character Case,  Prev: String Conversion,  Up: Strings and Characters

Formatting Strings
==================

   "Formatting" means constructing a string by substitution of computed
values at various places in a constant string.  This string controls
how the other values are printed as well as where they appear; it is
called a "format string".

   Formatting is often useful for computing messages to be displayed.
In fact, the functions `message' and `error' provide the same
formatting feature described here; they differ from `format' only in
how they use the result of formatting.

 - Function: format STRING &rest OBJECTS
     This function returns a new string that is made by copying STRING
     and then replacing any format specification in the copy with
     encodings of the corresponding OBJECTS.  The arguments OBJECTS are
     the computed values to be formatted.

   A format specification is a sequence of characters beginning with a
`%'.  Thus, if there is a `%d' in STRING, the `format' function
replaces it with the printed representation of one of the values to be
formatted (one of the arguments OBJECTS).  For example:

     (format "The value of fill-column is %d." fill-column)
          => "The value of fill-column is 72."

   If STRING contains more than one format specification, the format
specifications correspond with successive values from OBJECTS.  Thus,
the first format specification in STRING uses the first such value, the
second format specification uses the second such value, and so on.  Any
extra format specifications (those for which there are no corresponding
values) cause unpredictable behavior.  Any extra values to be formatted
are ignored.

   Certain format specifications require values of particular types.
However, no error is signaled if the value actually supplied fails to
have the expected type.  Instead, the output is likely to be
meaningless.

   Here is a table of valid format specifications:

`%s'
     Replace the specification with the printed representation of the
     object, made without quoting.  Thus, strings are represented by
     their contents alone, with no `"' characters, and symbols appear
     without `\' characters.

     If there is no corresponding object, the empty string is used.

`%S'
     Replace the specification with the printed representation of the
     object, made with quoting.  Thus, strings are enclosed in `"'
     characters, and `\' characters appear where necessary before
     special characters.

     If there is no corresponding object, the empty string is used.

`%o'
     Replace the specification with the base-eight representation of an
     integer.

`%d'
     Replace the specification with the base-ten representation of an
     integer.

`%x'
     Replace the specification with the base-sixteen representation of
     an integer.

`%c'
     Replace the specification with the character which is the value
     given.

`%e'
     Replace the specification with the exponential notation for a
     floating point number.

`%f'
     Replace the specification with the decimal-point notation for a
     floating point number.

`%g'
     Replace the specification with notation for a floating point
     number, using either exponential notation or decimal-point
     notation whichever is shorter.

`%%'
     A single `%' is placed in the string.  This format specification is
     unusual in that it does not use a value.  For example, `(format "%%
     %d" 30)' returns `"% 30"'.

   Any other format character results in an `Invalid format operation'
error.

   Here are several examples:

     (format "The name of this buffer is %s." (buffer-name))
          => "The name of this buffer is strings.texi."
     
     (format "The buffer object prints as %s." (current-buffer))
          => "The buffer object prints as #<buffer strings.texi>."
     
     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          => "The octal value of 18 is 22,
              and the hex value is 12."

   All the specification characters allow an optional numeric prefix
between the `%' and the character.  The optional numeric prefix defines
the minimum width for the object.  If the printed representation of the
object contains fewer characters than this, then it is padded.  The
padding is on the left if the prefix is positive (or starts with zero)
and on the right if the prefix is negative.  The padding character is
normally a space, but if the numeric prefix starts with a zero, zeros
are used for padding.

     (format "%06d is padded on the left with zeros" 123)
          => "000123 is padded on the left with zeros"
     
     (format "%-6d is padded on the right" 123)
          => "123    is padded on the right"

   `format' never truncates an object's printed representation, no
matter what width you specify.  Thus, you can use a numeric prefix to
specify a minimum spacing between columns with no risk of losing
information.

   In the following three examples, `%7s' specifies a minimum width of
7.  In the first case, the string inserted in place of `%7s' has only 3
letters, so 4 blank spaces are inserted for padding.  In the second
case, the string `"specification"' is 13 letters wide but is not
truncated.  In the third case, the padding is on the right.

     (format "The word `%7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `    foo' actually has 3 letters in it."

     (format "The word `%7s' actually has %d letters in it."
             "specification" (length "specification"))
          => "The word `specification' actually has 13 letters in it."

     (format "The word `%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `foo    ' actually has 3 letters in it."

