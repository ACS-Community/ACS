This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is the edition 2.3 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 19.23.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Accessing Events,  Next: Strings of Events,  Prev: Classifying Events,  Up: Input Events

Accessing Events
----------------

   This section describes convenient functions for accessing the data in
a mouse button or motion event.

   These two functions return the starting or ending position of a
mouse-button event.  The position is a list of this form:

     (WINDOW BUFFER-POSITION (X . Y) TIMESTAMP)

 - Function: event-start EVENT
     This returns the starting position of EVENT.

     If EVENT is a click or button-down event, this returns the
     location of the event.  If EVENT is a drag event, this returns the
     drag's starting position.

 - Function: event-end EVENT
     This returns the ending position of EVENT.

     If EVENT is a drag event, this returns the position where the user
     released the mouse button.  If EVENT is a click or button-down
     event, the value is actually the starting position, which is the
     only position such events have.

   These four functions take a position as described above, and return
various parts of it.

 - Function: posn-window POSITION
     Return the window that POSITION is in.

 - Function: posn-point POSITION
     Return the buffer position in POSITION.  This is an integer.

 - Function: posn-x-y POSITION
     Return the pixel-based x and y coordinates in POSITION, as a cons
     cell `(X . Y)'.

 - Function: posn-col-row POSITION
     Return the row and column (in units of characters) of POSITION, as
     a cons cell `(COL . ROW)'.  These are computed from the X and Y
     values actually found in POSITION.

 - Function: posn-timestamp POSITION
     Return the timestamp in POSITION.

 - Function: scroll-bar-event-ratio EVENT
     This function returns the fractional vertical position of a scroll
     bar event within the scroll bar.  The value is a cons cell
     `(PORTION . WHOLE)' containing two integers whose ratio is the
     fractional position.

 - Function: scroll-bar-scale RATIO TOTAL
     This function multiplies (in effect) RATIO by TOTAL, rounding the
     result to an integer.  The argument RATIO is not a number, but
     rather a pair `(NUM . DENOM)'--typically a value returned by
     `scroll-bar-event-ratio'.

     This function is handy for scaling a position on a scroll bar into
     a buffer position.  Here's how to do that:

          (+ (point-min)
             (scroll-bar-scale
                (posn-x-y (event-start event))
                (- (point-max) (point-min))))

     Recall that scroll bar events have two integers forming ratio in
     place of a pair of x and y coordinates.


File: elisp,  Node: Strings of Events,  Prev: Accessing Events,  Up: Input Events

Putting Keyboard Events in Strings
----------------------------------

   In most of the places where strings are used, we conceptualize the
string as containing text characters--the same kind of characters found
in buffers or files.  Occasionally Lisp programs use strings that
conceptually contain keyboard characters; for example, they may be key
sequences or keyboard macro definitions.  There are special rules for
how to put keyboard characters into a string, because they are not
limited to the range of 0 to 255 as text characters are.

   A keyboard character typed using the META key is called a "meta
character".  The numeric code for such an event includes the 2**23 bit;
it does not even come close to fitting in a string.  However, earlier
Emacs versions used a different representation for these characters,
which gave them codes in the range of 128 to 255.  That did fit in a
string, and many Lisp programs contain string constants that use `\M-'
to express meta characters, especially as the argument to `define-key'
and similar functions.

   We provide backward compatibility to run those programs using special
rules for how to put a keyboard character event in a string.  Here are
the rules:

   * If the keyboard character value is in the range of 0 to 127, it
     can go in the string unchanged.

   * The meta variants of those characters, with codes in the range of
     2**23 to 2**23+127, can also go in the string, but you must change
     their numeric values.  You must set the 2**7 bit instead of the
     2**23 bit, resulting in a value between 128 and 255.

   * Other keyboard character events cannot fit in a string.  This
     includes keyboard events in the range of 128 to 255.

   Functions such as `read-key-sequence' that can construct strings of
keyboard input characters follow these rules.  They construct vectors
instead of strings, when the events won't fit in a string.

   When you use the read syntax `\M-' in a string, it produces a code
in the range of 128 to 255--the same code that you get if you modify
the corresponding keyboard event to put it in the string.  Thus, meta
events in strings work consistently regardless of how they get into the
strings.

   The reason we changed the representation of meta characters as
keyboard events is to make room for basic character codes beyond 127,
and support meta variants of such larger character codes.

   New programs can avoid dealing with these special compatibility rules
by using vectors instead of strings for key sequences when there is any
possibility that they might contain meta characters, and by using
`listify-key-sequence' to access a string of events.

 - Function: listify-key-sequence KEY
     This function converts the string or vector KEY to a list of
     events, which you can put in `unread-command-events'.  Converting a
     vector is simple, but converting a string is tricky because of the
     special representation used for meta characters in a string.


File: elisp,  Node: Reading Input,  Next: Waiting,  Prev: Input Events,  Up: Command Loop

Reading Input
=============

   The editor command loop reads keyboard input using the function
`read-key-sequence', which uses `read-event'.  These and other
functions for keyboard input are also available for use in Lisp
programs.  See also `momentary-string-display' in *Note Temporary
Displays::, and `sit-for' in *Note Waiting::.  *Note Terminal Input::,
for functions and variables for controlling terminal input modes and
debugging terminal input.

   For higher-level input facilities, see *Note Minibuffers::.

* Menu:

* Key Sequence Input::		How to read one key sequence.
* Reading One Event::		How to read just one event.
* Quoted Character Input::	Asking the user to specify a character.
* Event Input Misc::    	How to reread or throw away input events.


File: elisp,  Node: Key Sequence Input,  Next: Reading One Event,  Up: Reading Input

Key Sequence Input
------------------

   The command loop reads input a key sequence at a time, by calling
`read-key-sequence'.  Lisp programs can also call this function; for
example, `describe-key' uses it to read the key to describe.

 - Function: read-key-sequence PROMPT
     This function reads a key sequence and returns it as a string or
     vector.  It keeps reading events until it has accumulated a full
     key sequence; that is, enough to specify a non-prefix command
     using the currently active keymaps.

     If the events are all characters and all can fit in a string, then
     `read-key-sequence' returns a string (*note Strings of Events::.).
     Otherwise, it returns a vector, since a vector can hold all kinds
     of events--characters, symbols, and lists.  The elements of the
     string or vector are the events in the key sequence.

     The function `read-key-sequence' suppresses quitting: `C-g' typed
     while reading with this function works like any other character,
     and does not set `quit-flag'.  *Note Quitting::.

     The argument PROMPT is either a string to be displayed in the echo
     area as a prompt, or `nil', meaning not to display a prompt.

     In the example below, the prompt `?' is displayed in the echo area,
     and the user types `C-x C-f'.

          (read-key-sequence "?")
          
          ---------- Echo Area ----------
          ?`C-x C-f'
          ---------- Echo Area ----------
          
               => "^X^F"

 - Variable: num-input-keys
     This variable's value is the number of key sequences processed so
     far in this Emacs session.  This includes key sequences read from
     the terminal and key sequences read from keyboard macros being
     executed.

   If an input character is an upper-case letter and has no key binding,
but its lower-case equivalent has one, then `read-key-sequence'
converts the character to lower case.  Note that `lookup-key' does not
perform case conversion in this way.

   The function `read-key-sequence' also transforms some mouse events.
It converts unbound drag events into click events, and discards unbound
button-down events entirely.  It also reshuffles focus events so that
they never appear in a key sequence with any other events.

   When mouse events occur in special parts of a window, such as a mode
line or a scroll bar, the event type shows nothing special--it is the
same symbol that would normally represent that combination of mouse
button and modifier keys.  The information about the window part is
kept elsewhere in the event--in the coordinates.  But
`read-key-sequence' translates this information into imaginary prefix
keys, all of which are symbols: `mode-line', `vertical-line',
`horizontal-scroll-bar' and `vertical-scroll-bar'.

   You can define meanings for mouse clicks in special window parts by
defining key sequences using these imaginary prefix keys.

   For example, if you call `read-key-sequence' and then click the
mouse on the window's mode line, you get an event like this:

     (read-key-sequence "Click on the mode line: ")
          => [mode-line
              (mouse-1
               (#<window 6 on NEWS> mode-line
                (40 . 63) 5959987))]


File: elisp,  Node: Reading One Event,  Next: Quoted Character Input,  Prev: Key Sequence Input,  Up: Reading Input

Reading One Event
-----------------

   The lowest level functions for command input are those that read a
single event.

 - Function: read-event
     This function reads and returns the next event of command input,
     waiting if necessary until an event is available.  Events can come
     directly from the user or from a keyboard macro.

     The function `read-event' does not display any message to indicate
     it is waiting for input; use `message' first, if you wish to
     display one.  If you have not displayed a message, `read-event'
     prompts by echoing: it displays descriptions of the events that
     led to or were read by the current command.  *Note The Echo Area::.

     If `cursor-in-echo-area' is non-`nil', then `read-event' moves the
     cursor temporarily to the echo area, to the end of any message
     displayed there.  Otherwise `read-event' does not move the cursor.

     Here is what happens if you call `read-event' and then press the
     right-arrow function key:

          (read-event)
               => right

 - Function: read-char
     This function reads and returns a character of command input.  It
     discards any events that are not characters, until it gets a
     character.

     In the first example, the user types the character `1' (ASCII code
     49).  The second example shows a keyboard macro definition that
     calls `read-char' from the minibuffer using `eval-expression'.
     `read-char' reads the keyboard macro's very next character, which
     is `1'.  Then `eval-expression' displays its return value in the
     echo area.

          (read-char)
               => 49
          
          (symbol-function 'foo)
               => "^[^[(read-char)^M1"
          (execute-kbd-macro 'foo)
               -| 49
               => nil


File: elisp,  Node: Quoted Character Input,  Next: Event Input Misc,  Prev: Reading One Event,  Up: Reading Input

Quoted Character Input
----------------------

   You can use the function `read-quoted-char' to ask the user to
specify a character, and allow the user to specify a control or meta
character conveniently, either literally or as an octal character code.
The command `quoted-insert' uses this function.

 - Function: read-quoted-char &optional PROMPT
     This function is like `read-char', except that if the first
     character read is an octal digit (0-7), it reads up to two more
     octal digits (but stopping if a non-octal digit is found) and
     returns the character represented by those digits in octal.

     Quitting is suppressed when the first character is read, so that
     the user can enter a `C-g'.  *Note Quitting::.

     If PROMPT is supplied, it specifies a string for prompting the
     user.  The prompt string is always displayed in the echo area,
     followed by a single `-'.

     In the following example, the user types in the octal number 177
     (which is 127 in decimal).

          (read-quoted-char "What character")
          
          ---------- Echo Area ----------
          What character-`177'
          ---------- Echo Area ----------
          
               => 127


File: elisp,  Node: Event Input Misc,  Prev: Quoted Character Input,  Up: Reading Input

Miscellaneous Event Input Features
----------------------------------

   This section describes how to "peek ahead" at events without using
them up, how to check for pending input, and how to discard pending
input.

 - Variable: unread-command-events
     This variable holds a list of events waiting to be read as command
     input.  The events are used in the order they appear in the list,
     and removed one by one as they are used.

     The variable is needed because in some cases a function reads a
     event and then decides not to use it.  Storing the event in this
     variable causes it to be processed normally, by the command loop
     or by the functions to read command input.

     For example, the function that implements numeric prefix arguments
     reads any number of digits.  When it finds a non-digit event, it
     must unread the event so that it can be read normally by the
     command loop.  Likewise, incremental search uses this feature to
     unread events with no special meaning in a search, because these
     events should exit the search and then execute normally.

     The reliable and easy way to extract events from a key sequence so
     as to put them in `unread-command-events' is to use
     `listify-key-sequence' (*note Strings of Events::.).

 - Variable: unread-command-char
     This variable holds a character to be read as command input.  A
     value of -1 means "empty".

     This variable is mostly obsolete now that you can use
     `unread-command-events' instead; it exists only to support programs
     written for Emacs versions 18 and earlier.

 - Function: input-pending-p
     This function determines whether any command input is currently
     available to be read.  It returns immediately, with value `t' if
     there is available input, `nil' otherwise.  On rare occasions it
     may return `t' when no input is available.

 - Variable: last-input-event
     This variable records the last terminal input event read, whether
     as part of a command or explicitly by a Lisp program.

     In the example below, the Lisp program reads the character `1',
     ASCII code 49.  It becomes the value of `last-input-event', while
     `C-e' (from the `C-x C-e' command used to evaluate this
     expression) remains the value of `last-command-event'.

          (progn (print (read-char))
                 (print last-command-event)
                 last-input-event)
               -| 49
               -| 5
               => 49

     The alias `last-input-char' exists for compatibility with Emacs
     version 18.

 - Function: discard-input
     This function discards the contents of the terminal input buffer
     and cancels any keyboard macro that might be in the process of
     definition.  It returns `nil'.

     In the following example, the user may type a number of characters
     right after starting the evaluation of the form.  After the
     `sleep-for' finishes sleeping, `discard-input' discards any
     characters typed during the sleep.

          (progn (sleep-for 2)
                 (discard-input))
               => nil


File: elisp,  Node: Waiting,  Next: Quitting,  Prev: Reading Input,  Up: Command Loop

Waiting for Elapsed Time or Input
=================================

   The wait functions are designed to wait for a certain amount of time
to pass or until there is input.  For example, you may wish to pause in
the middle of a computation to allow the user time to view the display.
`sit-for' pauses and updates the screen, and returns immediately if
input comes in, while `sleep-for' pauses without updating the screen.

 - Function: sit-for SECONDS &optional MILLISEC NODISP
     This function performs redisplay (provided there is no pending
     input from the user), then waits SECONDS seconds, or until input is
     available.  The value is `t' if `sit-for' waited the full time
     with no input arriving (see `input-pending-p' in *Note Event Input
     Misc::).  Otherwise, the value is `nil'.

     The optional argument MILLISEC specifies an additional waiting
     period measured in milliseconds.  This adds to the period
     specified by SECONDS.  Not all operating systems support waiting
     periods other than multiples of a second; on those that do not,
     you get an error if you specify nonzero MILLISEC.

     Redisplay is always preempted if input arrives, and does not
     happen at all if input is available before it starts.  Thus, there
     is no way to force screen updating if there is pending input;
     however, if there is no input pending, you can force an update
     with no delay by using `(sit-for 0)'.

     If NODISP is non-`nil', then `sit-for' does not redisplay, but it
     still returns as soon as input is available (or when the timeout
     elapses).

     The usual purpose of `sit-for' is to give the user time to read
     text that you display.

 - Function: sleep-for SECONDS &optional MILLISEC
     This function simply pauses for SECONDS seconds without updating
     the display.  It pays no attention to available input.  It returns
     `nil'.

     The optional argument MILLISEC specifies an additional waiting
     period measured in milliseconds.  This adds to the period
     specified by SECONDS.  Not all operating systems support waiting
     periods other than multiples of a second; on those that do not,
     you get an error if you specify nonzero MILLISEC.

     Use `sleep-for' when you wish to guarantee a delay.

   *Note Time of Day::, for functions to get the current time.


File: elisp,  Node: Quitting,  Next: Prefix Command Arguments,  Prev: Waiting,  Up: Command Loop

Quitting
========

   Typing `C-g' while a Lisp function is running causes Emacs to "quit"
whatever it is doing.  This means that control returns to the innermost
active command loop.

   Typing `C-g' while the command loop is waiting for keyboard input
does not cause a quit; it acts as an ordinary input character.  In the
simplest case, you cannot tell the difference, because `C-g' normally
runs the command `keyboard-quit', whose effect is to quit.  However,
when `C-g' follows a prefix key, the result is an undefined key.  The
effect is to cancel the prefix key as well as any prefix argument.

   In the minibuffer, `C-g' has a different definition: it aborts out
of the minibuffer.  This means, in effect, that it exits the minibuffer
and then quits.  (Simply quitting would return to the command loop
*within* the minibuffer.)  The reason why `C-g' does not quit directly
when the command reader is reading input is so that its meaning can be
redefined in the minibuffer in this way.  `C-g' following a prefix key
is not redefined in the minibuffer, and it has its normal effect of
canceling the prefix key and prefix argument.  This too would not be
possible if `C-g' always quit directly.

   When `C-g' does directly quit, it does so by setting the variable
`quit-flag' to `t'.  Emacs checks this variable at appropriate times
and quits if it is not `nil'.  Setting `quit-flag' non-`nil' in any way
thus causes a quit.

   At the level of C code, quitting cannot happen just anywhere; only
at the special places that check `quit-flag'.  The reason for this is
that quitting at other places might leave an inconsistency in Emacs's
internal state.  Because quitting is delayed until a safe place,
quitting cannot make Emacs crash.

   Certain functions such as `read-key-sequence' or `read-quoted-char'
prevent quitting entirely even though they wait for input.  Instead of
quitting, `C-g' serves as the requested input.  In the case of
`read-key-sequence', this serves to bring about the special behavior of
`C-g' in the command loop.  In the case of `read-quoted-char', this is
so that `C-q' can be used to quote a `C-g'.

   You can prevent quitting for a portion of a Lisp function by binding
the variable `inhibit-quit' to a non-`nil' value.  Then, although `C-g'
still sets `quit-flag' to `t' as usual, the usual result of this--a
quit--is prevented.  Eventually, `inhibit-quit' will become `nil'
again, such as when its binding is unwound at the end of a `let' form.
At that time, if `quit-flag' is still non-`nil', the requested quit
happens immediately.  This behavior is ideal when you wish to make sure
that quitting does not happen within a "critical section" of the
program.

   In some functions (such as `read-quoted-char'), `C-g' is handled in
a special way that does not involve quitting.  This is done by reading
the input with `inhibit-quit' bound to `t', and setting `quit-flag' to
`nil' before `inhibit-quit' becomes `nil' again.  This excerpt from the
definition of `read-quoted-char' shows how this is done; it also shows
that normal quitting is permitted after the first character of input.

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((count 0) (code 0) char)
         (while (< count 3)
           (let ((inhibit-quit (zerop count))
                 (help-form nil))
             (and prompt (message "%s-" prompt))
             (setq char (read-char))
             (if inhibit-quit (setq quit-flag nil)))
           ...)
         (logand 255 code)))

 - Variable: quit-flag
     If this variable is non-`nil', then Emacs quits immediately, unless
     `inhibit-quit' is non-`nil'.  Typing `C-g' ordinarily sets
     `quit-flag' non-`nil', regardless of `inhibit-quit'.

 - Variable: inhibit-quit
     This variable determines whether Emacs should quit when `quit-flag'
     is set to a value other than `nil'.  If `inhibit-quit' is
     non-`nil', then `quit-flag' has no special effect.

 - Command: keyboard-quit
     This function signals the `quit' condition with `(signal 'quit
     nil)'.  This is the same thing that quitting does.  (See `signal'
     in *Note Errors::.)

   You can specify a character other than `C-g' to use for quitting.
See the function `set-input-mode' in *Note Terminal Input::.


File: elisp,  Node: Prefix Command Arguments,  Next: Recursive Editing,  Prev: Quitting,  Up: Command Loop

Prefix Command Arguments
========================

   Most Emacs commands can use a "prefix argument", a number specified
before the command itself.  (Don't confuse prefix arguments with prefix
keys.)  The prefix argument is at all times represented by a value,
which may be `nil', meaning there is currently no prefix argument.
Each command may use the prefix argument or ignore it.

   There are two representations of the prefix argument: "raw" and
"numeric".  The editor command loop uses the raw representation
internally, and so do the Lisp variables that store the information, but
commands can request either representation.

   Here are the possible values of a raw prefix argument:

   * `nil', meaning there is no prefix argument.  Its numeric value is
     1, but numerous commands make a distinction between `nil' and the
     integer 1.

   * An integer, which stands for itself.

   * A list of one element, which is an integer.  This form of prefix
     argument results from one or a succession of `C-u''s with no
     digits.  The numeric value is the integer in the list, but some
     commands make a distinction between such a list and an integer
     alone.

   * The symbol `-'.  This indicates that `M--' or `C-u -' was typed,
     without following digits.  The equivalent numeric value is -1, but
     some commands make a distinction between the integer -1 and the
     symbol `-'.

   We illustrate these possibilities by calling the following function
with various prefixes:

     (defun display-prefix (arg)
       "Display the value of the raw prefix arg."
       (interactive "P")
       (message "%s" arg))

Here are the results of calling `display-prefix' with various raw
prefix arguments:

             M-x display-prefix  -| nil
     
     C-u     M-x display-prefix  -| (4)
     
     C-u C-u M-x display-prefix  -| (16)
     
     C-u 3   M-x display-prefix  -| 3
     
     M-3     M-x display-prefix  -| 3      ; (Same as `C-u 3'.)
     
     C-u -   M-x display-prefix  -| -
     
     M--     M-x display-prefix  -| -      ; (Same as `C-u -'.)
     
     C-u - 7 M-x display-prefix  -| -7
     
     M-- 7   M-x display-prefix  -| -7     ; (Same as `C-u -7'.)

   Emacs uses two variables to store the prefix argument: `prefix-arg'
and `current-prefix-arg'.  Commands such as `universal-argument' that
set up prefix arguments for other commands store them in `prefix-arg'.
In contrast, `current-prefix-arg' conveys the prefix argument to the
current command, so setting it has no effect on the prefix arguments
for future commands.

   Normally, commands specify which representation to use for the prefix
argument, either numeric or raw, in the `interactive' declaration.
(*Note Using Interactive::.)  Alternatively, functions may look at the
value of the prefix argument directly in the variable
`current-prefix-arg', but this is less clean.

 - Function: prefix-numeric-value ARG
     This function returns the numeric meaning of a valid raw prefix
     argument value, ARG.  The argument may be a symbol, a number, or a
     list.  If it is `nil', the value 1 is returned; if it is any other
     symbol, the value -1 is returned; if it is a number, that number is
     returned; if it is a list, the CAR of that list (which should be a
     number) is returned.

 - Variable: current-prefix-arg
     This variable holds the raw prefix argument for the *current*
     command.  Commands may examine it directly, but the usual way to
     access it is with `(interactive "P")'.

 - Variable: prefix-arg
     The value of this variable is the raw prefix argument for the
     *next* editing command.  Commands that specify prefix arguments for
     the following command work by setting this variable.

   Do not call the functions `universal-argument', `digit-argument', or
`negative-argument' unless you intend to let the user enter the prefix
argument for the *next* command.

 - Command: universal-argument
     This command reads input and specifies a prefix argument for the
     following command.  Don't call this command yourself unless you
     know what you are doing.

 - Command: digit-argument ARG
     This command adds to the prefix argument for the following
     command.  The argument ARG is the raw prefix argument as it was
     before this command; it is used to compute the updated prefix
     argument.  Don't call this command yourself unless you know what
     you are doing.

 - Command: negative-argument ARG
     This command adds to the numeric argument for the next command.
     The argument ARG is the raw prefix argument as it was before this
     command; its value is negated to form the new prefix argument.
     Don't call this command yourself unless you know what you are
     doing.


File: elisp,  Node: Recursive Editing,  Next: Disabling Commands,  Prev: Prefix Command Arguments,  Up: Command Loop

Recursive Editing
=================

   The Emacs command loop is entered automatically when Emacs starts up.
This top-level invocation of the command loop never exits; it keeps
running as long as Emacs does.  Lisp programs can also invoke the
command loop.  Since this makes more than one activation of the command
loop, we call it "recursive editing".  A recursive editing level has
the effect of suspending whatever command invoked it and permitting the
user to do arbitrary editing before resuming that command.

   The commands available during recursive editing are the same ones
available in the top-level editing loop and defined in the keymaps.
Only a few special commands exit the recursive editing level; the others
return to the recursive editing level when they finish.  (The special
commands for exiting are always available, but they do nothing when
recursive editing is not in progress.)

   All command loops, including recursive ones, set up all-purpose error
handlers so that an error in a command run from the command loop will
not exit the loop.

   Minibuffer input is a special kind of recursive editing.  It has a
few special wrinkles, such as enabling display of the minibuffer and the
minibuffer window, but fewer than you might suppose.  Certain keys
behave differently in the minibuffer, but that is only because of the
minibuffer's local map; if you switch windows, you get the usual Emacs
commands.

   To invoke a recursive editing level, call the function
`recursive-edit'.  This function contains the command loop; it also
contains a call to `catch' with tag `exit', which makes it possible to
exit the recursive editing level by throwing to `exit' (*note Catch and
Throw::.).  If you throw a value other than `t', then `recursive-edit'
returns normally to the function that called it.  The command `C-M-c'
(`exit-recursive-edit') does this.  Throwing a `t' value causes
`recursive-edit' to quit, so that control returns to the command loop
one level up.  This is called "aborting", and is done by `C-]'
(`abort-recursive-edit').

   Most applications should not use recursive editing, except as part of
using the minibuffer.  Usually it is more convenient for the user if you
change the major mode of the current buffer temporarily to a special
major mode, which should have a command to go back to the previous mode.
(The `e' command in Rmail uses this technique.)  Or, if you wish to
give the user different text to edit "recursively", create and select a
new buffer in a special mode.  In this mode, define a command to
complete the processing and go back to the previous buffer.  (The `m'
command in Rmail does this.)

   Recursive edits are useful in debugging.  You can insert a call to
`debug' into a function definition as a sort of breakpoint, so that you
can look around when the function gets there.  `debug' invokes a
recursive edit but also provides the other features of the debugger.

   Recursive editing levels are also used when you type `C-r' in
`query-replace' or use `C-x q' (`kbd-macro-query').

 - Function: recursive-edit
     This function invokes the editor command loop.  It is called
     automatically by the initialization of Emacs, to let the user begin
     editing.  When called from a Lisp program, it enters a recursive
     editing level.

     In the following example, the function `simple-rec' first advances
     point one word, then enters a recursive edit, printing out a
     message in the echo area.  The user can then do any editing
     desired, and then type `C-M-c' to exit and continue executing
     `simple-rec'.

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress")
            (recursive-edit)
            (forward-word 1))
               => simple-rec
          (simple-rec)
               => nil

 - Command: exit-recursive-edit
     This function exits from the innermost recursive edit (including
     minibuffer input).  Its definition is effectively `(throw 'exit
     nil)'.

 - Command: abort-recursive-edit
     This function aborts the command that requested the innermost
     recursive edit (including minibuffer input), by signaling `quit'
     after exiting the recursive edit.  Its definition is effectively
     `(throw 'exit t)'.  *Note Quitting::.

 - Command: top-level
     This function exits all recursive editing levels; it does not
     return a value, as it jumps completely out of any computation
     directly back to the main command loop.

 - Function: recursion-depth
     This function returns the current depth of recursive edits.  When
     no recursive edit is active, it returns 0.


File: elisp,  Node: Disabling Commands,  Next: Command History,  Prev: Recursive Editing,  Up: Command Loop

Disabling Commands
==================

   "Disabling a command" marks the command as requiring user
confirmation before it can be executed.  Disabling is used for commands
which might be confusing to beginning users, to prevent them from using
the commands by accident.

   The low-level mechanism for disabling a command is to put a
non-`nil' `disabled' property on the Lisp symbol for the command.
These properties are normally set up by the user's `.emacs' file with
Lisp expressions such as this:

     (put 'upcase-region 'disabled t)

For a few commands, these properties are present by default and may be
removed by the `.emacs' file.

   If the value of the `disabled' property is a string, the message
saying the command is disabled includes that string.  For example:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

   *Note Disabling: (emacs)Disabling, for the details on what happens
when a disabled command is invoked interactively.  Disabling a command
has no effect on calling it as a function from Lisp programs.

 - Command: enable-command COMMAND
     Allow COMMAND to be executed without special confirmation from now
     on, and (if the user confirms) alter the user's `.emacs' file so
     that this will apply to future sessions.

 - Command: disable-command COMMAND
     Require special confirmation to execute COMMAND from now on, and
     (if the user confirms) alter the user's `.emacs' file so that this
     will apply to future sessions.

 - Variable: disabled-command-hook
     This normal hook is run instead of a disabled command, when the
     user invokes the disabled command interactively.  The hook
     functions can use `this-command-keys' to determine what the user
     typed to run the command, and thus find the command itself.  *Note
     Hooks::.

     By default, `disabled-command-hook' contains a function that asks
     the user whether to proceed.


File: elisp,  Node: Command History,  Next: Keyboard Macros,  Prev: Disabling Commands,  Up: Command Loop

Command History
===============

   The command loop keeps a history of the complex commands that have
been executed, to make it convenient to repeat these commands.  A
"complex command" is one for which the interactive argument reading
uses the minibuffer.  This includes any `M-x' command, any `M-ESC'
command, and any command whose `interactive' specification reads an
argument from the minibuffer.  Explicit use of the minibuffer during
the execution of the command itself does not cause the command to be
considered complex.

 - Variable: command-history
     This variable's value is a list of recent complex commands, each
     represented as a form to evaluate.  It continues to accumulate all
     complex commands for the duration of the editing session, but all
     but the first (most recent) thirty elements are deleted when a
     garbage collection takes place (*note Garbage Collection::.).

          command-history
          => ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

   This history list is actually a special case of minibuffer history
(*note Minibuffer History::.), with one special twist: the elements are
expressions rather than strings.

   There are a number of commands devoted to the editing and recall of
previous commands.  The commands `repeat-complex-command', and
`list-command-history' are described in the user manual (*note
Repetition: (emacs)Repetition.).  Within the minibuffer, the history
commands used are the same ones available in any minibuffer.


File: elisp,  Node: Keyboard Macros,  Prev: Command History,  Up: Command Loop

Keyboard Macros
===============

   A "keyboard macro" is a canned sequence of input events that can be
considered a command and made the definition of a key.  The Lisp
representation of a keyboard macro is a string or vector containing the
events.  Don't confuse keyboard macros with Lisp macros (*note
Macros::.).

 - Function: execute-kbd-macro MACRO &optional COUNT
     This function executes MACRO as a sequence of events.  If MACRO is
     a string or vector, then the events in it are executed exactly as
     if they had been input by the user.  The sequence is *not*
     expected to be a single key sequence; normally a keyboard macro
     definition consists of several key sequences concatenated.

     If MACRO is a symbol, then its function definition is used in
     place of MACRO.  If that is another symbol, this process repeats.
     Eventually the result should be a string or vector.  If the result
     is not a symbol, string, or vector, an error is signaled.

     The argument COUNT is a repeat count; MACRO is executed that many
     times.  If COUNT is omitted or `nil', MACRO is executed once.  If
     it is 0, MACRO is executed over and over until it encounters an
     error or a failing search.

 - Variable: last-kbd-macro
     This variable is the definition of the most recently defined
     keyboard macro.  Its value is a string or vector, or `nil'.

 - Variable: executing-macro
     This variable contains the string or vector that defines the
     keyboard macro that is currently executing.  It is `nil' if no
     macro is currently executing.  A command can test this variable to
     behave differently when run from an executing macro.  Do not set
     this variable yourself.

 - Variable: defining-kbd-macro
     This variable indicates whether a keyboard macro is being defined.
     A command can test this variable to behave differently while a
     macro is being defined.  The commands `start-kbd-macro' and
     `end-kbd-macro' set this variable--do not set it yourself.


File: elisp,  Node: Keymaps,  Next: Modes,  Prev: Command Loop,  Up: Top

Keymaps
*******

   The bindings between input events and commands are recorded in data
structures called "keymaps".  Each binding in a keymap associates (or
"binds") an individual event type either with another keymap or with a
command.  When an event is bound to a keymap, that keymap is used to
look up the next input event; this continues until a command is found.
The whole process is called "key lookup".

* Menu:

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				   of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Active Keymaps::	        Each buffer has a local keymap
                                   to override the standard (global) bindings.
				   A minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.
* Menu Keymaps::		A keymap can define a menu.


File: elisp,  Node: Keymap Terminology,  Next: Format of Keymaps,  Up: Keymaps

Keymap Terminology
==================

   A "keymap" is a table mapping event types to definitions (which can
be any Lisp objects, though only certain types are meaningful for
execution by the command loop).  Given an event (or an event type) and a
keymap, Emacs can get the event's definition.  Events include ordinary
ASCII characters, function keys, and mouse actions (*note Input
Events::.).

   A sequence of input events that form a unit is called a "key
sequence", or "key" for short.  A sequence of one event is always a key
sequence, and so are some multi-event sequences.

   A keymap determines a binding or definition for any key sequence.  If
the key sequence is a single event, its binding is the definition of the
event in the keymap.  The binding of a key sequence of more than one
event is found by an iterative process: the binding of the first event
is found, and must be a keymap; then the second event's binding is found
in that keymap, and so on until all the events in the key sequence are
used up.

   If the binding of a key sequence is a keymap, we call the key
sequence a "prefix key".  Otherwise, we call it a "complete key"
(because no more events can be added to it).  If the binding is `nil',
we call the key "undefined".  Examples of prefix keys are `C-c', `C-x',
and `C-x 4'.  Examples of defined complete keys are `X', RET, and `C-x
4 C-f'.  Examples of undefined complete keys are `C-x C-g', and `C-c
3'.  *Note Prefix Keys::, for more details.

   The rule for finding the binding of a key sequence assumes that the
intermediate bindings (found for the events before the last) are all
keymaps; if this is not so, the sequence of events does not form a
unit--it is not really a key sequence.  In other words, removing one or
more events from the end of any valid key must always yield a prefix
key.  For example, `C-f C-f' is not a key; `C-f' is not a prefix key,
so a longer sequence starting with `C-f' cannot be a key.

   Note that the set of possible multi-event key sequences depends on
the bindings for prefix keys; therefore, it can be different for
different keymaps, and can change when bindings are changed.  However,
a one-event sequence is always a key sequence, because it does not
depend on any prefix keys for its well-formedness.

   At any time, several primary keymaps are "active"--that is, in use
for finding key bindings.  These are the "global map", which is shared
by all buffers; the "local keymap", which is usually associated with a
specific major mode; and zero or more "minor mode keymaps", which
belong to currently enabled minor modes.  (Not all minor modes have
keymaps.)  The local keymap bindings shadow (i.e., take precedence
over) the corresponding global bindings.  The minor mode keymaps shadow
both local and global keymaps.  *Note Active Keymaps::, for details.


File: elisp,  Node: Format of Keymaps,  Next: Creating Keymaps,  Prev: Keymap Terminology,  Up: Keymaps

Format of Keymaps
=================

   A keymap is a list whose CAR is the symbol `keymap'.  The remaining
elements of the list define the key bindings of the keymap.  Use the
function `keymapp' (see below) to test whether an object is a keymap.

   Each ordinary binding applies to events of a particular "event
type", which is always a character or a symbol.  *Note Classifying
Events::.

   An ordinary element of a keymap is a cons cell of the form `(TYPE .
BINDING)'.  This specifies one binding, for events of type TYPE.

   A cons cell whose CAR is `t' is a "default key binding"; any event
not bound by other elements of the keymap is given BINDING as its
binding.  Default bindings allow a keymap to bind all possible event
types without having to enumerate all of them.  A keymap that has a
default binding completely masks any lower-precedence keymap.

   If an element of a keymap is a vector, the vector counts as bindings
for all the ASCII characters; vector element N is the binding for the
character with code N.  This is a compact way to record lots of
bindings.  A keymap with such a vector is called a "full keymap".
Other keymaps are called "sparse keymaps".

   When a keymap contains a vector, it always defines a binding for
every ASCII character even if the vector element is `nil'.  Such a
binding of `nil' overrides any default binding in the keymap.  However,
default bindings are still meaningful for events that are not ASCII
characters.  A binding of `nil' does *not* override lower-precedence
keymaps; thus, if the local map gives a binding of `nil', Emacs uses
the binding from the global map.

   Aside from bindings, a keymap can also have a string as an element.
This is called the "overall prompt string" and makes it possible to use
the keymap as a menu.  *Note Menu Keymaps::.

   Keymaps do not directly record bindings for the meta characters,
whose codes are from 128 to 255.  Instead, meta characters are regarded
for purposes of key lookup as sequences of two characters, the first of
which is ESC (or whatever is currently the value of
`meta-prefix-char').  Thus, the key `M-a' is really represented as `ESC
a', and its global binding is found at the slot for `a' in `esc-map'
(*note Prefix Keys::.).

   Here as an example is the local keymap for Lisp mode, a sparse
keymap.  It defines bindings for DEL and TAB, plus `C-c C-l', `M-C-q',
and `M-C-x'.

     lisp-mode-map
     =>
     (keymap
      ;; TAB
      (9 . lisp-indent-line)
      ;; DEL
      (127 . backward-delete-char-untabify)
      (3 keymap
         ;; `C-c C-l'
         (12 . run-lisp))
      (27 keymap
          ;; `M-C-q', treated as `ESC C-q'
          (17 . indent-sexp)
          ;; `M-C-x', treated as `ESC C-x'
          (24 . lisp-send-defun)))

 - Function: keymapp OBJECT
     This function returns `t' if OBJECT is a keymap, `nil' otherwise.
     More precisely, this function tests for a list whose CAR is
     `keymap'.

          (keymapp '(keymap))
              => t
          (keymapp (current-global-map))
              => t


File: elisp,  Node: Creating Keymaps,  Next: Inheritance and Keymaps,  Prev: Format of Keymaps,  Up: Keymaps

Creating Keymaps
================

   Here we describe the functions for creating keymaps.

 - Function: make-keymap &optional PROMPT
     This function creates and returns a new full keymap (i.e., one
     containing a vector of length 128 for defining all the ASCII
     characters).  The new keymap initially binds all ASCII characters
     to `nil', and does not bind any other kind of event.

          (make-keymap)
              => (keymap [nil nil nil ... nil nil])

     If you specify PROMPT, that becomes the overall prompt string for
     the keymap.  The prompt string is useful for menu keymaps (*note
     Menu Keymaps::.).

 - Function: make-sparse-keymap &optional PROMPT
     This function creates and returns a new sparse keymap with no
     entries.  The new keymap does not bind any events.  The argument
     PROMPT specifies a prompt string, as in `make-keymap'.

          (make-sparse-keymap)
              => (keymap)

 - Function: copy-keymap KEYMAP
     This function returns a copy of KEYMAP.  Any keymaps that appear
     directly as bindings in KEYMAP are also copied recursively, and so
     on to any number of levels.  However, recursive copying does not
     take place when the definition of a character is a symbol whose
     function definition is a keymap; the same symbol appears in the
     new copy.

          (setq map (copy-keymap (current-local-map)))
          => (keymap
               ;; (This implements meta characters.)
               (27 keymap
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))
          
          (eq map (current-local-map))
              => nil
          (equal map (current-local-map))
              => t


File: elisp,  Node: Inheritance and Keymaps,  Next: Prefix Keys,  Prev: Creating Keymaps,  Up: Keymaps

Inheritance and Keymaps
=======================

   A keymap can inherit the bindings of another keymap.  Do do this,
make a keymap whose "tail" is another existing keymap to inherit from.
Such a keymap looks like this:

     (keymap BINDINGS... . OTHER-KEYMAP)

The effect is that this keymap inherits all the bindings of
OTHER-KEYMAP, whatever they may be at the time a key is looked up, but
can add to them or override them with BINDINGS.

   If you change the bindings in OTHER-KEYMAP using `define-key' or
other key-binding functions, these changes are visible in the
inheriting keymap unless shadowed by BINDINGS.  The converse is not
true: if you use `define-key' to change the inheriting keymap, that
affects BINDINGS, but has no effect on OTHER-KEYMAP.

   Here is an example showing how to make a keymap that inherits from
`text-mode-map':

     (setq my-mode-map (cons 'keymap text-mode-map))

