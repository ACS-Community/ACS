#! /bin/bash
#*******************************************************************************
# E.S.O. - VLT project
#
# "@(#) $Id: vltMakeIndexFilesDependencies,v 1.2 2010/07/09 15:15:24 rtobar Exp $" 
#
# who       when      what
# --------  --------  ----------------------------------------------
# gfilippi  20/11/95  created (from vltMakeLOGSFiles)
# gfilippi  08/12/95  work around to make problem in SUN (/dev/fd/3)
# rschmutz 1999-04-03 if Linux: disable bash builtin command 'echo'.

#************************************************************************
#   NAME
#   vltMakeIndexFilesDependencies - generate the ERRORS/LOGS files.
# 
#   SYNOPSIS
#
#   vltMakeIndexFilesDependencies
#
# 
#   DESCRIPTION
#   Utility used by vltMakefile to generate the ERRORS or the LOGS files.
#   The files are created by feditFormatCompile.
#
#   It is not intended to be used as a standalone command.
#
#   FILES
#
#   ENVIRONMENT
#
#   RETURN VALUES
#
#   SEE ALSO 
#   vltMakefile
#
#   BUGS    
#
#----------------------------------------------------------------------

# if Linux: disable the bash builtin command 'echo'.
if [ "`uname`" = "Linux" ]
then
    enable -n echo
elif [ "`uname`" = "$CYGWIN_VER" ]
then
    alias echo="echo -e"
fi

if [ "${1}" != "" ]
then
    echo "ERROR: vltMakeIndexFilesDependencies does not accept parameters" >&2
    exit 1
fi

echo "# Dependency file for Errors&Logs index files"
echo "# Created automatically by vltMakeIndexFilesDependencies -  `date '+%d.%m.%y %T'`"
echo "# DO NOT EDIT THIS FILE"



for type in ERRORS LOGS
do
    list=""
    if [ -d ../${type} ]
    then
        if [ "`ls ../${type}/*_${type} 2>/dev/null`" != "" ]
        then 
            # get the stem from the existing filenames:
            for file in `ls ../${type}/*_${type} 2>/dev/null`
            do
                if [ -s $file ]
                    then 
                    # The problem now is to isolate the stem name of the 
                    # source file. The trick is to drop the "_${type}" at the end.
                    # The "_" is used to separate the two parts.
                    #
                    name=`basename $file | awk -F_ '{ print $1 }' `
                    list="$list $name"
                fi
            done
            
            # output the make-rules:

            target="do_${type}:"
            
            for name in $list
            do
                 if [ ${type} = ERRORS ] ; then H_FILE="../include/${name}Errors.h"; fi
                 if [ ${type} = LOGS   ] ; then H_FILE="../include/${name}Logs.h"  ; fi

                 target="$target ../${type}/${name}${type}.IDX $H_FILE"

                 echo "\n../${type}/${name}${type}.IDX $H_FILE : ../${type}/${name}_${type}"
                 echo "	-\$(AT)echo \"== feditFormatCompile ${name}_${type}\""

                 # REMARK: 
                 # the usage of sh `which ....` is due to a problem of GNUmake (3.70)
                 # on SUN (2.3/4). May be for a bug, the $0 parameter is not cerrectly
                 # expanded to the full-filename but to "/dev/fd/3)"  
                 # In tcl script, the exec directive is used to invoke the
                 # tcl-shell and to read the script. This does not work.
                 # Using "sh" gives the right translation and the "which"
                 # finds the first executable in the path.
                 # To be tested in future versions.
                 
                 echo "	-\$(AT) sh \`which feditFormatCompile\` ${type} $name"
            done

            echo "\n$target"
        fi
    fi 

    # if either no good files or no directory have been found, create an empty target
    if [ "$list" = "" ]
    then 
        echo "\ndo_${type}:"
        echo "	-\$(AT)echo \"\""        
    fi

done

exit 0
#
# ___oOo___
