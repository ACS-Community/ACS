#! /bin/bash
. acsstartupAcsPorts
. acsstartupLogging.sh
. acsstartupConstants
. acsstartupAcsInstance
. acsstartupPids
#*******************************************************************************
# ALMA - Atacama Large Millimiter Array
# (c) Associated Universities Inc., 2002 
# (c) European Southern Observatory, 2002
# Copyright by ESO (in the framework of the ALMA collaboration)
# and Cosylab 2002, All rights reserved
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
# MA 02111-1307  USA
#
# "@(#) $Id: acsStart,v 1.31 2006/05/24 22:56:52 dfugate Exp $"
#
# who       when      what
# -------- ---------- ----------------------------------------------
# sharring 2004-06-24 redirect output to a file
# mschilli 2004-04-16 added proper command line parsing
# msekoran 2003-05-09 Created.
#

#************************************************************************
#   NAME	acsStart
#
#   SYNOPSIS    starts up all ACS services
#
#   DESCRIPTION starts up all ACS services
#
#   FILES
#
#   ENVIRONMENT
#
#   RETURN VALUES
#
#   CAUTIONS
#
#   EXAMPLES
#
#   SEE ALSO
#
#   BUGS
#
#------------------------------------------------------------------------
#
#

###If there's a corrupted $ACSDATA/tmp/ACS_INSTANCE.$ACS_INSTANCE, attempt
###to fix it
if ! checkDeadACS
then
    ACS_LOG_ERROR "Unable to continue as the ACS_INSTANCE, $ACS_INSTANCE, is currently in use!"
    exit $EC_FAILURE
fi

###
### ----------- Command Line Parsing ---------------------

#
# These will contain the parsing results (CL_XXX, CL = command line)
#
CL_BASEPORT=
CL_HELP=
CL_TIMEOUT=
CL_VERBOSE=
CL_WAITIFR=true

#
# These options can be recognized (longopts comma-separated. colon means argument is required)
#
LONGOPTS=help,baseport:,timeout:,verbose,nowaitifr
SHORTOPTS=hb:t:v

#
# Usage info. Be nice and keep this up-to-date!
#
function printUsage {
   echo "Starts an Acs instance"
   echo ""
   echo "Usage: `basename $0` [OPTIONS]  "
   echo "Options: "
   echo "   -b | -baseport INSTANCE        the acs instance (0-9) you want to use"
   echo "   -t | -timeout MULTIPLIER       the maximum timeout can be increased by specifying an integer value greater than 1"
   echo "        -nowaitifr                does not wait for the CORBA Interface Repository to load before returning"
   echo "   -v | -verbose                  print subprocess output to console (additionally to regular logfile)"
   echo "   -h | -help                     prints this help and exits"
}

#
# Run getopt (posixly_correct needed). We run twice:
# First run is simply to check the commandline for correctness
# Second run is the real deal which replaces the command line args with getopt's output
export POSIXLY_CORRECT=1

getopt -n `basename $0` -Q -u -a -l $LONGOPTS $SHORTOPTS "$@" || {
   printUsage
	exit $EC_BADARGS;
}

set -- `getopt -u -a -l $LONGOPTS $SHORTOPTS "$@"`

#
# Iterate over getopt's output and set CL_XXX variables accordingly
#
while : 
do
	case "$1" in
	--baseport)         CL_BASEPORT=$2 ; shift ;;
	-b)                 CL_BASEPORT=$2 ; shift ;;
	--timeout)          CL_TIMEOUT=$2 ; shift ;;
	-t)                 CL_TIMEOUT=$2 ; shift ;;
	--nowaitifr)        CL_WAITIFR=false ;;
	--verbose)          CL_VERBOSE=true ;;
	-v)                 CL_VERBOSE=true ;;
	--help)             CL_HELP=true ;; 
	-h)                 CL_HELP=true ;; 
	--) break ;;
	esac
	shift
done
shift

# restore 
export POSIXLY_CORRECT=
unset POSIXLY_CORRECT

if [ "$CL_HELP" ] ; then
   printUsage
   exit $EC_OK
fi


#
# (Note: Rest of command line now in $@ )
#
### ---------- End of Command Line Parsing -------------


#warn them if they're using the typical NRAO /etc/hosts file
if [ `getIP` = "127.0.0.1" ]
then
    echo "WARNING: this script has detected that your PC is incorrectly configured"
    echo "         for CORBA communications. The IP address (i.e., $HOST)"
    echo "         found is what is normally used with DHCP. In other words, forget"
    echo "         about connecting any CORBA client/servant residing on this machine" 
    echo "         to a CORBA object residing on another host. Also, do not use this"
    echo "         PC to generate TAT reference files involving Python as the reference"
    echo "         files will be different from those generated under a 'normal'"
    echo "         PC. For information on resolving this issue, please see:"
    echo "             http://almasw.hq.eso.org/almasw/bin/view/ACS/FAQGeneralDevelopmentEnvironmentBadEtcHosts"
    echo ""
    sleep 5
fi


#start the ORB services
if [ "$CL_VERBOSE" ] ; then
   export ACS_LOG_STDOUT=0
fi

### Handle TIME_OUT argument

#Makes shure there is an initial value
if [ X"$ACS_STARTUP_TIMEOUT_MULTIPLIER" = X ]
 then
   ACS_STARTUP_TIMEOUT_MULTIPLIER=5
fi

if [ "$CL_TIMEOUT" ] ; then 
   export ACS_STARTUP_TIMEOUT_MULTIPLIER=$CL_TIMEOUT
fi

#maximum timeout for anything in this script to finish executing...
MAX_TIMEOUT=$(( 36 * $ACS_STARTUP_TIMEOUT_MULTIPLIER ))

#...except acsIrFeed. This requires more time
MAX_IRFEED_TIMEOUT=$(( $MAX_TIMEOUT * 5 ))

#Check command-line args for baseport option
if [ "$CL_BASEPORT" ]
then
    export ACS_INSTANCE=$CL_BASEPORT
fi

#output from the orb services is stored here to figure out which ACS
#instance to use.

export ACSSTARTLOG=$ACS_INSTANCES_DIR/.acsStart.$$
#------------------------------------------------------
ACS_LOG_COMMAND

#start the ORB services
acsStartORBSRVC 2>&1 | tee -a $ACSSTARTLOG &
ORBSRVC_PID=$!

if ! acsutilBlock -t $MAX_TIMEOUT -f $ACSSTARTLOG -b "acsStartORBSRVC script has now completed" -c "ERROR" -p $ORBSRVC_PID
then
    ACS_LOG_ERROR "Detected the acsStartORBSRVC process has exited with an error!"
    exit $EC_FAILURE
fi
#------------------------------------------------------
#to ensure manager uses the same ACS_INSTANCE
export ACS_INSTANCE=`grep "For this ACS session, please do an" $ACSSTARTLOG | cut -d\' -f2 | cut -d= -f2`
export INSTANCE_DIR=`getInstanceDirName $ACS_INSTANCE`
#------------------------------------------------------
#start the Manager
acsStartManager 2>&1 | tee -a $ACSSTARTLOG &
MANAGER_PID=$!

if ! acsutilBlock -t $MAX_TIMEOUT -f $ACSSTARTLOG -b "Manager Application initialized" -p $MANAGER_PID
then
    ACS_LOG_ERROR "Detected the acsStartManager process has exited with an error!"
    exit $EC_FAILURE
fi
#------------------------------------------------------
#block until the interface repository has fully loaded
if [ "$CL_WAITIFR" = "true" ]
then
    export IRFEED_PIDFILE=$INSTANCE_DIR/$ACS_IRFEED_PIDFILE
    export IRFEED_PID=`cat $IRFEED_PIDFILE`

    ACS_LOG_DEBUG "Waiting for the interface repository to finish loading."
    if ! acsutilBlock -t $MAX_IRFEED_TIMEOUT -p $IRFEED_PID
    then
	ACS_LOG_ERROR "The acsstartupLoadIFR script is still loading IDLs into the interface repository after $MAX_IFREED_TIMEOUT seconds."
	ACS_LOG_INFO  "There could be something genuinely wrong here or maybe your machine is just slow."
	ACS_LOG_INFO  "Try increasing \$ACS_STARTUP_TIMEOUT_MULTIPLIER next time (was $ACS_STARTUP_TIMEOUT_MULTIPLIER)."
	kill -9 $IRFEED_PID
    else
	ACS_LOG_DEBUG "The interface repository has finished loading."
    fi
fi

rm -f $IRFEED_PIDFILE
#--------------------------------------------------------------------------------------------------------------------------

ACS_LOG_FORCED "INFO - For this ACS session, please do an 'export ACS_INSTANCE=$ACS_INSTANCE' on all terminals running ACS clients."
ACS_LOG_FORCED "INFO - ACS is up and running"
rm $ACSSTARTLOG
