#! /bin/bash
. acsstartupLogging.sh
. acsstartupConstants
. acsstartupAcsInstance
. acsstartupPids
#*************************************************************************
# ALMA - Atacama Large Millimiter Array
# (c) European Southern Observatory, 2002
# Copyright by ESO (in the framework of the ALMA collaboration),
# All rights reserved
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
# MA 02111-1307  USA
#
if [ "`uname`" = "Linux" ]; then enable -n echo; fi

ACS_LOG_COMMAND $@

###
### ----------- Command Line Parsing ---------------------

#
# These will contain the parsing results (CL_XXX, CL = command line)
#
CL_BASEPORT=
CL_HELP=

#
# These options can be recognized (longopts comma-separated. colon means argument is required)
#
LONGOPTS=help,baseport:,managerReference:,timeout:
SHORTOPTS=hb:m:t:

#
# Usage info. Be nice and keep this up-to-date!
#
function printUsage {
   echo "Stops the Acs manager; Note that acsStop is an alternative for this"
   echo ""
	echo "Usage: `basename $0` [OPTIONS]  "
	echo "Options: "
	echo "   -b | -baseport INSTANCE        the acs instance (0-9) you want to use"
        echo "   -m | -managerReference MGR     the corbaloc of your favorite manager"
	echo "   -t | -timeout MULTIPLIER       the maximum timeout can be increased by specifying an integer value greater than 1"
	echo "   -h | -help                     prints this help and exits"
}

#
# Run getopt (posixly_correct needed). We run twice:
# First run is simply to check the commandline for correctness
# Second run is the real deal which replaces the command line args with getopt's output
export POSIXLY_CORRECT=1

getopt -n `basename $0` -Q -u -a -l $LONGOPTS $SHORTOPTS "$@" || {
   printUsage
	exit $EC_BADARGS;
}

set -- `getopt -u -a -l $LONGOPTS $SHORTOPTS "$@"`

#
# Iterate over getopt's output and set CL_XXX variables accordingly
#
while : 
do
	case "$1" in
	--baseport)         CL_BASEPORT=$2 ; shift ;;
	-b)                 CL_BASEPORT=$2 ; shift ;;
	--timeout)          export ACS_STARTUP_TIMEOUT_MULTIPLIER=$2 ; shift ;;
	-t)                 export ACS_STARTUP_TIMEOUT_MULTIPLIER=$2 ; shift ;;
	--help)             CL_HELP=true ;; 
	-h)                 CL_HELP=true ;; 
	--) break ;;
	esac
	shift
done
shift

# restore 
export POSIXLY_CORRECT=
unset POSIXLY_CORRECT

if [ "$CL_HELP" ] ; then
   printUsage
   exit $EC_OK
fi


#
# (Note: Rest of command line now in $@ )
#
### ---------- End of Command Line Parsing -------------


#Check command-line args for baseport option
if [ "$CL_BASEPORT" ]
then
    export ACS_INSTANCE="$CL_BASEPORT"
fi

INSTANCE_DIR=`getInstanceDirName $ACS_INSTANCE`
MANAGER_PIDFILE=$INSTANCE_DIR/$ACS_MANAGER_PIDFILE
MANAGER_OUT=$INSTANCE_DIR/$ACS_MANAGER_OUT

if ! MANAGER_PID=`getManagerPid`
then
    exit $EC_CANNOTUSE
fi

#---------------------------------------------------------------------------------
#sanity checks
#-------------

if [ ! -d $INSTANCE_DIR ]
then
    ACS_LOG_DEBUG "acsStopManager" "The lock directory '$INSTANCE_DIR' does not exist!"

elif [ ! -e $MANAGER_PIDFILE ]
then
    ACS_LOG_DEBUG "acsStopManager" "The temporary file '$MANAGER_PIDFILE' does not exist!"

#Stop user A from interfering with user B
elif [ ! -w $INSTANCE_DIR ]
then
    ACS_LOG_ERROR "acsStopManager" "The directory '$INSTANCE_DIR' is not owned by $USER!"
    exit $EC_CANNOTUSE

elif [ ! -w $MANAGER_PIDFILE ]
then
    ACS_LOG_ERROR "acsStopManager" "The temporary file '$MANAGER_PIDFILE' is not owned by $USER!"
    exit $EC_CANNOTUSE
fi

#---------------------------------------------------------------------------------
#run the normal command to shutdown manager
#------------------------------------------
#everything checked out so manager can really be shutdown
#if this command does not finish in 15 seconds, it will be
#killed

# The code to send to shutdown methods of all containers. 
# If 0, the containers' shutdown methods are not called, and the manager simply calls disconnect()
# TODO Think about if we want containers to actually shut down, and what value to send in that case.
# See COMP-2602 for more.
export container_shutdown_code=0
acsutilBlock -t 15 -k "maciManagerShutdown $container_shutdown_code"

#---------------------------------------------------------------------------------
#assume the worst has happened...manager is hung
#-----------------------------------------------
#Makes shure there is an initial value
if [ X"$ACS_STARTUP_TIMEOUT_MULTIPLIER" = X ]
 then
   ACS_STARTUP_TIMEOUT_MULTIPLIER=5
fi

#give manager this amount of time to shutdown
MAX_TIMEOUT=$(( 6 * $ACS_STARTUP_TIMEOUT_MULTIPLIER ))

#delegate to this helper script. if jManager does not
#really go away in $MAX_TIMEOUT seconds, the helper
#script will forcefully kill it!
acsutilBlock -p $MANAGER_PID -t $MAX_TIMEOUT -k

#---------------------------------------------------------------------------------
#some final cleanup
#------------------
#remove manager's pid file
if [ -e $MANAGER_PIDFILE ]
then
    rm $MANAGER_PIDFILE 
fi

#remove manager's output file
if [ -e $MANAGER_OUT ]
then
    rm $MANAGER_OUT
fi

ACS_LOG_INFO "acsStopManager" "`basename $0`: done."
