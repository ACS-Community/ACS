#! /bin/bash
. acsstartupAcsPorts
. acsstartupLogging.sh
. acsstartupConstants
. acsstartupAcsInstance
#*******************************************************************************
# E.S.O. - VLT project
#
# "@(#) $Id: acsStopORBSRVC,v 1.30 2006/02/27 20:45:16 dfugate Exp $"
#
# who       when      what
# --------  --------  ----------------------------------------------
# mschilli 2004-04-16 added proper command line parsing
# david 2003-05-14 changed to bash for tat tests
# gchiozzi 2002-12-12 acsLogSvc was missing for SunOS
# gchiozzi 2002-11-22 Added stopping CDB
# gchiozzi 2002-09-30 Removed CDB Server. Not needed any more.
# bjeram 2002-04-10 added kill acslogsvc
# psivera  2002-03-18 ported to SUN Solaris
# gchiozzi 2001-09-19 created
#

#************************************************************************
#   NAME
# 
#   SYNOPSIS
# 
#   DESCRIPTION
#
#   FILES
#
#   ENVIRONMENT
#
#   RETURN VALUES
#
#   CAUTIONS
#
#   EXAMPLES
#
#   SEE ALSO
#
#   BUGS     
#
#------------------------------------------------------------------------
#

###
### ----------- Command Line Parsing ---------------------

#
# These will contain the parsing results (CL_XXX, CL = command line)
#
CL_BASEPORT=
CL_HELP=

#
# These options can be recognized (longopts comma-separated. colon means argument is required)
#
LONGOPTS=help,baseport:
SHORTOPTS=hb:

#
# Usage info. Be nice and keep this up-to-date!
#
function printUsage {
   echo "Stops the Orb services for Acs; note that acsStop is an alternative for this"
   echo ""
	echo "Usage: `basename $0` [OPTIONS]  "
	echo "Options: "
	echo "   -b | -baseport INSTANCE        the acs instance (0-9) you want to use"
   echo "   -h | -help                     prints this help and exits"
}

#
# Run getopt (posixly_correct needed). We run twice:
# First run is simply to check the commandline for correctness
# Second run is the real deal which replaces the command line args with getopt's output
export POSIXLY_CORRECT=1

getopt -n `basename $0` -Q -u -a -l $LONGOPTS $SHORTOPTS "$@" || {
   printUsage
	exit $EC_BADARGS;
}

set -- `getopt -u -a -l $LONGOPTS $SHORTOPTS "$@"`

#
# Iterate over getopt's output and set CL_XXX variables accordingly
#
while : 
do
	case "$1" in
	--baseport)         CL_BASEPORT=$2 ; shift ;;
	-b)                 CL_BASEPORT=$2 ; shift ;;
	--help)             CL_HELP=true ;; 
	-h)                 CL_HELP=true ;; 
	--) break ;;
	esac
	shift
done
shift

# restore 
export POSIXLY_CORRECT=
unset POSIXLY_CORRECT

if [ "$CL_HELP" ] ; then
   printUsage
   exit $EC_OK
fi

#
# (Note: Rest of command line now in $@ )
#
### ---------- End of Command Line Parsing -------------


export HOST=`getIP`


#Check command-line args for baseport option
if [ "$CL_BASEPORT" ]
then
    export ACS_INSTANCE="$CL_BASEPORT"
fi

########################################################################
#SANITY CHECKS-------------------------------------------------------

#Cannot shutdown everything if we don't know the process IDs.
if [ ! -d `getInstanceDirName $ACS_INSTANCE` ]
then
    ACS_LOG_ERROR "Unable to shutdown because the lock directory '`getInstanceDirName $ACS_INSTANCE`' does not exist!"
    ACS_LOG_ERROR "An alternative is to use the 'killACS' command which kills all ACS processes '$USER' owns"
    exit $EC_CANNOTUSE
fi

#Cannot shutdown everything if this user does not own the processes.
if [ ! -w `getInstanceDirName $ACS_INSTANCE` ]
then
    ACS_LOG_ERROR "Unable to shutdown because the lock directory '`getInstanceDirName $ACS_INSTANCE`' is not owned by '$USER'!"
    exit $EC_CANNOTUSE
fi

ACS_LOG_INFO "Stopping the ORB Services and CDB using 'ACS_INSTANCE=$ACS_INSTANCE'"

#just to be sure...
chmod -R 777 `getInstanceDirName $ACS_INSTANCE` &> /dev/null || (ACS_LOG_ERROR "Unable to change permissions on `getInstanceDirName $ACS_INSTANCE`")
#go to the directory where all process IDs are stored
cd `getInstanceDirName $ACS_INSTANCE` &> /dev/null || (ACS_LOG_ERROR "Cannot cd to `getInstanceDirName $ACS_INSTANCE`"; exit $EC_FAILURE)

########################################################################
#SHUTDOWN CDB-----------------------------------------------------------
#Since the CDB is just a Java process, it must be treated a little differently
ACS_LOG_INFO "Stopping the CDB"
ACS_CDB_PORT=`getCDBPort`
#Try the "correct" way of shutting down the CDB
cdbjDALShutdown -k corbaloc::$HOST:$ACS_CDB_PORT/CDB &> /dev/null || (ACS_LOG_ERROR "Cannot shutdown the CDB using the cdbjDALShutdown command")
#if what's above failled kill it using the PID
acsKillProc ACS_CDB_PID &> /dev/null
rm -f ACS_CDB_PID

########################################################################
#SHUTDOWN ORB SERVICES--------------------------------------------------

#kill the processes one at a time

ACS_LOG_INFO "Stopping the CORBA Naming Service"
if [ -e ACS_NAMING_SERVICE_PID ]
then
    acsKillProc ACS_NAMING_SERVICE_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the naming service")
    rm -f ACS_NAMING_SERVICE_PID
else
    ACS_LOG_ERROR "The file containing the naming service's process ID, 'ACS_NAMING_SERVICE_PID', does not exist"
fi

ACS_LOG_INFO "Stopping the CORBA Notification Service"
if [ -e ACS_NOTIFY_SERVICE_PID ]
then
    acsKillProc ACS_NOTIFY_SERVICE_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the notification service")
    rm -f ACS_NOTIFY_SERVICE_PID
else
    ACS_LOG_ERROR "The file containing the notify service's process ID, 'ACS_NOTIFY_SERVICE_PID', does not exist"
fi

ACS_LOG_INFO "Stopping the CORBA Logging Notification Service"
if [ -e ACS_LOGGING_NOTIFY_SERVICE_PID ]
then
    acsKillProc ACS_LOGGING_NOTIFY_SERVICE_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the logging notification service")
    rm -f ACS_LOGGING_NOTIFY_SERVICE_PID
else
    ACS_LOG_ERROR "The file containing the logging notify service's process ID, 'ACS_LOGGING_NOTIFY_SERVICE_PID', does not exist"
fi

ACS_LOG_INFO "Stopping the CORBA Archive Notification Service"
if [ -e ACS_ARCHIVE_NOTIFY_SERVICE_PID ]
then
    acsKillProc ACS_ARCHIVE_NOTIFY_SERVICE_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the archive notification service")
    rm -f ACS_ARCHIVE_NOTIFY_SERVICE_PID
else
    ACS_LOG_ERROR "The file containing the archive notify service's process ID, 'ACS_ARCHIVE_NOTIFY_SERVICE_PID', does not exist"
fi

ACS_LOG_INFO "Stopping the CORBA Logging Service"
if [ -e ACS_LOGGING_SERVICE_PID ]
then
    acsKillProc ACS_LOGGING_SERVICE_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the logging service")
    rm -f ACS_LOGGING_SERVICE_PID
else
    ACS_LOG_ERROR "The file containing the logging service's process ID, 'ACS_LOGGING_SERVICE_PID', does not exist"
fi

ACS_LOG_INFO "Stopping the CORBA Interface Repository"
if [ -e ACS_IR_PID ]
then
    acsKillProc ACS_IR_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the interface repository")
    rm -f ACS_IR_PID
else
    ACS_LOG_ERROR "The file containing the interface repository's process ID, 'ACS_IR_PID', does not exist"
fi

ACS_LOG_INFO "Stopping the ACS Logging Service"
if [ -e ACS_LOG_SERVICE_PID ]
then
    acsKillProc ACS_LOG_SERVICE_PID 2> /dev/null || (ACS_LOG_ERROR "Cannot kill the ACS logging service")
    rm -f ACS_LOG_SERVICE_PID
else
    ACS_LOG_ERROR "The file containing the ACS logging service's process ID, 'ACS_LOG_SERVICE_PID', does not exist"
fi

########################################################################
#FINAL CLEANUP----------------------------------------------------------
if [ -e ACS_PIDS ]
then
    file=`cat ACS_PIDS`
    
    ACS_LOG_INFO "Killing any rogue ACS processes..."
    for line in $file
    do
      acsKillProc $line &> /dev/null
    done
fi

ACS_LOG_INFO "Freeing `getInstanceDirName $ACS_INSTANCE`"
cd ..     # just jump one level up that we can delete the instance directory
rm -rf `getInstanceDirName $ACS_INSTANCE` &> /dev/null || (ACS_LOG_ERROR "Cannot remove `getInstanceDirName $ACS_INSTANCE`")


#
# ___oOo___
