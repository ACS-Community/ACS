/*
 *    ALMA - Atacama Large Millimiter Array
 *    (c) European Southern Observatory, 2002
 *    Copyright by ESO (in the framework of the ALMA collaboration),
 *    All rights reserved
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 *    MA 02111-1307  USA
 */
#ifndef _JCONTTEST_IDL_
#define _JCONTTEST_IDL_

#pragma prefix "alma"

#include <acscomponent.idl>
#include <ACSErrTypeCommon.idl>

// Module for test components. 
// These are meant more for ACS internal tests rather than for demo purposes,
// although they should be instructive at the same time.
// 
module jconttest
{
	interface ContainerServicesTester : ACS::ACSComponent
	{
		boolean testComponentName(out string compName);
		boolean testStateManager(out string currStateName);

		boolean testGetDynamicDummyComponent(out string compName); 
		
		boolean testGetDefaultIdentifierArchive(out string compName);

		boolean testGetThreadFactory(in long numThreads, in long busyLoopCount, in boolean randomize);
		
		void testGetCollocatedComponent(in string curl, in string targetCurl) raises (ACSErrTypeCommon::CouldntPerformActionEx);
		
		/**
		 * Will obtain a non-sticky reference to the given component using the ContainerServices.
		 * This method throws an exception if the reference can't be obtained, which is expected to happen if the 
		 * other component has not already been activated by some other client.
		 * If the parameter 'release' is true, then the non-sticky component will be released; that call is expected to 
		 * have no effect (aside from some log message).
		 */
		void testGetComponentNonSticky(in string curl, in boolean release) raises (ACSErrTypeCommon::CouldntPerformActionEx);

		/**
		 * Will obtain a reference to the given component (if getOwnRef is true) and then try to forcefully release that component.
		 * The calling client is exepcted to already hold a reference to that component, as otherwise the 
		 * component unloading would be trivial instead of forceful.
		 */
		void testForceReleaseComponent(in string curl, in boolean getOwnRef) raises (ACSErrTypeCommon::CouldntPerformActionEx);		
	};
	
	
	interface DummyComponent : ACS::ACSComponent
	{
		void dummyComponentsCanDoCloseToNothing();
		void callThatTakesSomeTime(in long timeInMillisec);
	};
	
};

#endif 
