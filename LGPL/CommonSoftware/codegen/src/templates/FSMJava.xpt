«REM»
	ALMA - Atacama Large Millimiter Array
	(c) European Southern Observatory, 2002
	Copyright by ESO (in the framework of the ALMA collaboration),
	All rights reserved
	
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.
	
	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.
	 
	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston,
	MA 02111-1307  USA
«ENDREM» 

«IMPORT uml»
«EXTENSION templates::util»


«REM»	Expansions for the StateMachine.
		For StateMachine in a UML Model, it expands:
			- ActionInterface: An interface which has all the actions definitions
			- SuperContextClass: The outermost context. It handles most of the StateMachine functions.
			- AbstractStateClass: For each Composite State, an abstract class is created which specifies common functions for inner states.
			- MiddleStateClass: For each State in the middle of the hierarchy (is not a leaf state), the State class is generated.
			- StateClass: For each State that is a leaf (is not composite), the State class is generated.
		
		@author Arturo Hoffstadt Urrutia <ahoffsta@inf.utfsm.cl>
		
		TODO: Separate templates for different classes into different files
		TODO: The error state is handled in a different way. It is identified by the name. Should use Stereotypes.
		TODO: The final state is handled in a different way, It is identified by the name. Should use UML to detect final states.
		TODO: Introduce global variables for:
				- Package for generated classes.
«ENDREM»
«DEFINE Root FOR StateMachine»
	«EXPAND ActionInterface»
	«EXPAND SuperContextClass»
	«EXPAND AbstractStateClass»
	«EXPAND MiddleStateClass FOREACH allOwnedElements().typeSelect(State).select(e|e.isComposite())»
	«EXPAND StateClass FOREACH allOwnedElements().typeSelect(State).select(e| !(e.isComposite()) && (e.name != "Unavailable") )»	
«ENDDEFINE»



«REM»	Expansions for the ActionInterface. Every Action available for the StateMachine is putted in this interface.
«ENDREM»
«DEFINE ActionInterface FOR StateMachine»
  «FILE "alma/ACS/MasterComponentImpl/statemachine/" + this.name + "Actions.java"»
    package alma.ACS.MasterComponentImpl.statemachine;
    
    import alma.acs.genfw.runtime.sm.AcsStateActionException;

    public interface «this.name»Actions {
      «FOREACH listActions().sortBy(e|e.name) AS act»
        void «act.name»() throws AcsStateActionException;
      «ENDFOREACH»
    }
  «ENDFILE»
«ENDDEFINE»



«REM»	First context class. This "SuperContext" class has the current state, and the action delegation.
«ENDREM»
«DEFINE SuperContextClass FOR StateMachine»
  		«FILE "alma/ACS/MasterComponentImpl/statemachine/" + this.name + "Context.java"»
package alma.ACS.MasterComponentImpl.statemachine;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import alma.ACSErrTypeCommon.wrappers.AcsJIllegalStateEventEx;
import alma.acs.genfw.runtime.sm.AcsState;
import alma.acs.genfw.runtime.sm.AcsStateActionException;
import alma.acs.genfw.runtime.sm.AcsStateChangeListener;
import alma.acs.logging.AcsLogger;

/**
 * The super context class for the «name» state machine.
 */
public class «name»Context 
{	    
	private «name»StateAbstract m_currentState;
	private «name»Actions m_actionDelegate;
	
	private List<AcsStateChangeListener> m_stateChangeListeners;	
	private AcsState[] m_oldHierarchy;	
	private final AcsLogger m_logger;
	
	/**
	 * Executor for do/ actions in activity states.
	 * This executor only has one worker thread and therefore synchronizes
	 * concurrent requests.
	 * @TODO: Discuss if and how we want to escape from a hanging action method. 
	 *        Both timeout and asynchronous actions pose ugly implementation issues for the subsystem MCs.
	 */
	private final ThreadPoolExecutor sharedActivityExecutor;	
	private boolean m_verbose = false;
      
	// state objects
    	«FOREACH listStates() AS st-»
	public «st.name»State m_state«st.name»;
    	«ENDFOREACH»
    
    public «this.name»Context(«this.name»Actions actions, AcsLogger logger, ThreadFactory threadFactory) {
    	m_stateChangeListeners = new ArrayList<AcsStateChangeListener>();
		m_logger = logger;
		// This choice of parameters is copied from the implementation of 
		// Executors.newSingleThreadExecutor which unfortunately hides 
		// in its returned type some methods we need.
		sharedActivityExecutor = new ThreadPoolExecutor(1, 1,
			0L, TimeUnit.MILLISECONDS,
			new LinkedBlockingQueue<Runnable>(),
			threadFactory);
		m_actionDelegate = actions;
    	«FOREACH listStates() AS st-»
		m_state«st.name» = new «st.name»State(«st.getHierarcharchyString()»);
		«ENDFOREACH-»
		
		// initial state
		m_state«getInitialState().name».activate("<init>");
		m_oldHierarchy = getCurrentTopLevelState().getStateHierarchy();
	}
	
	/**
	 * Registers an object that will be notified about any state change in this state machine.
	 * @param listener
	 */
	public synchronized void addAcsStateChangeListener(AcsStateChangeListener listener) {
		m_stateChangeListeners.add(listener);
	}
	
	public void setState(«this.name»StateAbstract newState, String eventName) {
		«this.name»StateAbstract oldState = m_currentState;
		if (oldState != newState) {
			logTransition(m_currentState, newState, eventName);
			m_currentState = newState;
			m_currentState.entry();
		}
		AcsState[] currentHierarchy = getCurrentTopLevelState().getStateHierarchy();
		// check if there was a state change down the nesting hierarchy		
		if (!Arrays.equals(currentHierarchy, m_oldHierarchy)) {
			// if so, notify listeners
			for (Iterator<AcsStateChangeListener> iter = m_stateChangeListeners.iterator(); iter.hasNext();) {
				AcsStateChangeListener listener = iter.next();
				listener.stateChangedNotify(m_oldHierarchy, currentHierarchy);
			}
			m_oldHierarchy = currentHierarchy;
		}
	}
	
	public synchronized AlmaSubsystemStateAbstract getCurrentTopLevelState()
	{
		return m_currentState;
	}
	
	//======================================================================
	// delegates incoming events to current state class
	//======================================================================
		«FOREACH getUniqueSignalsNames() AS sg-»
	public void «sg»() throws AcsJIllegalStateEventEx {
		m_currentState.«sg»();
	}
    	«ENDFOREACH-»
    
	//======================================================================
	// delegates actions to user-provided action handler
	// Note that actions of activity states are run in separate threads 
	//======================================================================
	«FOREACH listActions() AS act»
	public void «act.name»() throws AcsStateActionException {
		try {
			m_actionDelegate.«act.name»();
		}
		catch (AcsStateActionException ex) {
			throw ex;
		}
		catch (Throwable thr) {
			throw new AcsStateActionException(thr);
		}
	}
    «ENDFOREACH»
    
    //======================================================================
	// util methods
	//======================================================================

	public void illegalEvent(String stateName, String eventName) throws AcsJIllegalStateEventEx
	{
		String msg = "illegal event '" + eventName + "' in state '" + stateName + "'.";
		if (m_verbose) {
			m_logger.warning(msg);
		}
//		for (Iterator iter = m_stateChangeListeners.iterator(); iter.hasNext();) {
//			AcsStateChangeListener listener = (AcsStateChangeListener) iter.next();
//			listener.illegalEventNotify(stateName, eventName);			
//		}
		AcsJIllegalStateEventEx ex = new AcsJIllegalStateEventEx();
		ex.setEvent(eventName);
		ex.setState(stateName);
		throw ex;
	}
	
	public void logTransition(AcsState sourceState, AcsState targetState, String eventName) {
		if (m_verbose && sourceState != null) {  // sourceState is null at initial state setting
			String msg = "event '" + eventName + "' causes transition from '" + 
			sourceState.stateName() + "' to '" + targetState.stateName() + "'.";
			m_logger.info(msg);
		}
	}

	public ThreadPoolExecutor getSharedActivityExecutor() {
		return sharedActivityExecutor;
	}

	/**
	 * Final clean-up, must be called before unloading this class.
	 * Afterwards it may be in an undefined state.
	 */
	public void cleanUp() {
		// wake up and terminate the activity worker thread.
		sharedActivityExecutor.shutdownNow();
	}
}
	«ENDFILE»
«ENDDEFINE»


«DEFINE AbstractStateClass FOR uml::StateMachine»
	«FILE "alma/ACS/MasterComponentImpl/statemachine/" + name + "StateAbstract.java"-»
package alma.ACS.MasterComponentImpl.statemachine;
    
import alma.ACSErrTypeCommon.wrappers.AcsJIllegalStateEventEx;
import alma.acs.genfw.runtime.sm.AcsState;
    
/**
  * Abstract state class. Concrete subclass receives delegation calls from the
  * SM's super context class.
  */
public abstract class «name»StateAbstract implements AcsState
{
	protected «name»Context m_superContext;
    
	public «name»StateAbstract(«name»Context superContext) {
		m_superContext = superContext;
	}
	
	public abstract AcsState[] getStateHierarchy();
	public abstract String stateName();
      
	// all events that the master component can handle
	// make all events illegal here, and let subclasses allow certain events 
		«FOREACH getUniqueSignalsNames().sortBy(e|e) AS sg»
	public void «sg»() throws AcsJIllegalStateEventEx {
		m_superContext.illegalEvent(stateName(), "«sg»");
	}
    	«ENDFOREACH-»

	// entry, exit, events
	public abstract void entry();
	public void exit() {}
}
	«ENDFILE»
«ENDDEFINE»


«DEFINE MiddleStateClass FOR State»
	«FILE "alma/ACS/MasterComponentImpl/statemachine/" + name + "State.java"-»
package alma.ACS.MasterComponentImpl.statemachine;
    
import alma.ACSErrTypeCommon.wrappers.AcsJIllegalStateEventEx;
import alma.acs.genfw.runtime.sm.AcsState;
		«IF !isComposite()-»
import alma.acs.logging.AcsLogger;
		«ENDIF-»
    
public class «name»State
    	«IF isTopState()-»
	extends «containingStateMachine().name»StateAbstract
    	«ELSE-»
	extends «getContextName()»SubStateAbstract
    	«ENDIF-» 
{
	public «name»SubStateAbstract m_subState;
	«IF !isTopState() && isComposite()-»
	public boolean newEntryToThis = false;
	«ENDIF-»
      
    	«EXPAND StateConstructor-»

	/**
	 * @see alma.acs.genfw.runtime.sm.AcsState#stateName()
	 */      
	public String stateName() {
		return "«name.toUpperCase()»";
	}

	/**
	 * @see alma.acs.genfw.runtime.sm.AcsState#getStateHierarchy()
	 */
	public «IF isTopState()-»synchronized«ENDIF-» AcsState[] getStateHierarchy() 
	{
		AcsState[] substates = m_subState.getStateHierarchy();
		AcsState[] hierarchy = new AcsState[substates.length + 1];
		hierarchy[0] = this;
		System.arraycopy(substates, 0, hierarchy, 1, substates.length);
		return hierarchy;
	}
      
	public void setSubstate(«name»SubStateAbstract newSubState, String eventName) {
		«name»SubStateAbstract oldSubState = m_subState;
		if (oldSubState != newSubState) {
			m_superContext.logTransition(oldSubState, newSubState, eventName);
			m_subState = newSubState;
		}
		
		// always propagate state change upwards. «IF !isTopState()» May result in a call to entry() if the previous state was not a substate of this state.«ENDIF»
		«IF isTopState()-»
		m_superContext.setState(this, eventName);
		«ELSE-»
		m_context.setSubstate(this, eventName);
		«ENDIF-» 
		
		«IF isTopState()-»
		// from UML spec (1.5):
		// If the transition goes to a substate of the composite state, then that
		// substate becomes active and its entry code is executed after the execution of the
		// entry code of the composite state. This rule applies recursively if the transition
		// terminates on a transitively nested substate.
		«ENDIF-»
		if («IF !isTopState()»newEntryToThis || «ENDIF»oldSubState != newSubState) {
			m_subState.entry();
		}
		«IF !isTopState()-»
		newEntryToThis = false;
		«ENDIF-»
	}
	
	public void entry() 
	{ 
		«IF !isTopState()-»
		newEntryToThis = true;
		«ELSE-»
		// todo: generate entry action if required
		«ENDIF-»		
	}

  	
    	«FOREACH allOwnedElements().typeSelect(Transition) AS sg»
    		«IF sg.hasTrigger()-»
	public void «getSignalName( sg )»()  throws AcsJIllegalStateEventEx {
		m_subState.«getSignalName( sg )»();
	}
			«ENDIF-»
    	«ENDFOREACH-»
    	
    	«IF isTopState()-»
    		«FOREACH getOthersSignalsNames() AS sg»
	public void «sg»() {
		m_subState.«sg»();		
	}
    		«ENDFOREACH-»
    	«ENDIF-»

}
	«ENDFILE»
  
	«FILE "alma/ACS/MasterComponentImpl/statemachine/" + name + "SubStateAbstract.java"-»
package alma.ACS.MasterComponentImpl.statemachine;

import alma.acs.genfw.runtime.sm.AcsState;
import alma.ACSErrTypeCommon.wrappers.AcsJIllegalStateEventEx;
«IF !isTopState()-»
import alma.acs.logging.AcsLogger;
«ENDIF-»
    
/**
  * Abstract class for substates of composite state '«name»'.
  */
public abstract class «name»SubStateAbstract implements AcsState
{
	public «containingStateMachine().name»Context m_superContext;
	«IF !isTopState()-»
	protected final AcsLogger logger;	
	protected «name»State m_«name.toLowerCase()»Context;
	«ENDIF-»
	
	«IF isTopState()-»
	// the nested state AvailableState serves as both state class and context class for its substates
    protected AvailableState m_context;
    «ENDIF-»
    
    «IF isTopState()-»
    public «name»SubStateAbstract(«containingStateMachine().name»Context superContext, «name»State context ) {
        m_superContext = superContext;
        m_context = context;
    }
    «ELSE-»
	public «name»SubStateAbstract(«containingStateMachine().name»Context superContext, «name»State «name.toLowerCase()»Context, AcsLogger logger ) {
		this.logger = logger;
        m_superContext = superContext;
        m_«name.toLowerCase()»Context = «name.toLowerCase()»Context;
	}
	«ENDIF-»      
	public abstract AcsState[] getStateHierarchy();
	public abstract String stateName();
	
	public abstract void entry();
    
    // events to be dealt with by subclasses
    
    	«FOREACH allOwnedElements().typeSelect(Transition) AS sg-»
    		«IF sg.hasTrigger()-»
	public void «getSignalName( sg )»()  throws AcsJIllegalStateEventEx {
		m_superContext.illegalEvent(stateName(), "«getSignalName(sg)»");
	}
			«ENDIF-»
    	«ENDFOREACH-»

	// events handled by this base class 
	«IF !(!isTopState() && isComposite)-»
    	«FOREACH getOthersSignalsNames() AS sg-»
	public void «sg»() {
			«IF sg == "error"-»
		m_context.setSubstate(m_superContext.m_stateError, "error");
			«ELSE-»
		m_superContext.m_state«containingStateMachine().allOwnedElements().typeSelect(Transition).selectFirst(e|hasTrigger(e) && getSignalName(e) == sg ).target.name».activate("«sg»");
			«ENDIF-»
	}
    	«ENDFOREACH-»
    «ENDIF»
}
	«ENDFILE»
«ENDDEFINE»

«DEFINE StateConstructor FOR State»
    «IF isTopState()-»
	public «name»State(«containingStateMachine().name»Context superContext) {
		super(superContext);
    «ELSE-»
    	«IF isComposite()-»
	public «name»State(«containingStateMachine().name»Context superContext, «parentState().name»State context ) {
		super(superContext, context );
		«ELSE-»
			«IF parentState().isTopState()-»
	public «name»State(«containingStateMachine().name»Context superContext, «parentState().name»State context ) {
		super(superContext, context );
			«ELSE-»
	public «name»State(«containingStateMachine().name»Context superContext, «parentState().name»State context, AcsLogger logger) {
		super(superContext, context, logger );
			«ENDIF-»
		«ENDIF-»
    «ENDIF-»
	}
«ENDDEFINE»


«DEFINE StateClass FOR uml::State»
	«FILE "alma/ACS/MasterComponentImpl/statemachine/" + name + "State.java"-»
package alma.ACS.MasterComponentImpl.statemachine;
    
import alma.acs.genfw.runtime.sm.AcsSimpleState;
import alma.acs.genfw.runtime.sm.AcsState;
		«IF !parentState().isTopState()»
import alma.acs.logging.AcsLogger;
		«ENDIF»
		«IF doActivity != null-»
import alma.acs.genfw.runtime.sm.AcsDoActivity;
import alma.acs.genfw.runtime.sm.AcsStateActionException;
		«ENDIF-»
    
public class «name»State extends «parentState().name»SubStateAbstract implements AcsSimpleState
{
		«IF doActivity != null-»
	private AcsDoActivity m_doActivity;
		«ENDIF-»

		«EXPAND StateConstructor-»
    
	public String stateName() 
	{
		return "«name.toUpperCase()»";
	}

	/**
	 * @see alma.acs.genfw.runtime.sm.AcsState#getStateHierarchy()
	 */
	public AcsState[] getStateHierarchy() 
	{
		return new AcsState[] {this};
	}

	public void activate(String eventName) 
	{
		synchronized (m_superContext) {
		«IF parentState().isTopState()-»
		m_context.setSubstate(this, eventName);
		«ELSE-»
		m_«parentState().name.toLowerCase()»Context.setSubstate(this, eventName);
		«ENDIF-»
		}
	}
	
    public void entry() 
    {
		«IF doActivity != null-»
      // perform do/ action asynchronously
      if (m_doActivity == null) {
        // todo : get error state from a new stereotype (instead of name "Error")
        m_doActivity = new AcsDoActivity("«name»", m_superContext.m_state«outgoing.get(0).target.name», m_superContext.m_stateError, logger, m_superContext.getSharedActivityExecutor() ) {
          public void runActions() throws AcsStateActionException 
          {
			«EXPAND ActionMethodCall FOR doActivity-»
          }
        };
      }
      m_doActivity.execute();
		«ENDIF-»
	}

	public void exit()
	{
		«IF doActivity != null-»
      m_doActivity.terminateActions();
		«ENDIF-»
	}
    
	// events handled by this state:
		«IF parentState().isTopState()»
			«EXPAND ConcreteEventMethod2 FOREACH outgoing»
		«ELSE»
			«EXPAND ConcreteEventMethod FOREACH outgoing»
		«ENDIF»
		
    
}    
	«ENDFILE»
«ENDDEFINE»

«DEFINE ActionMethodCall FOR Behavior»
		m_superContext.«name»();
«ENDDEFINE»

«DEFINE ConcreteEventMethod FOR Transition»
	«IF !trigger.isEmpty-»
	public void «getSignalName(this)»() {    
		«IF effect != null-»
			«EXPAND ActionMethodCall FOR effect-»
		«ENDIF-»
		m_superContext.m_state«target.name».activate("«getSignalName(this)»");
	}
	«ENDIF-»
«ENDDEFINE»

«DEFINE ConcreteEventMethod2 FOR Transition»
	«IF !trigger.isEmpty-»
	public void «getSignalName(this)»() {    
		«IF effect != null-»
			«EXPAND ActionMethodCall FOR effect-»
		«ENDIF-»
		m_context.setSubstate(m_superContext.m_state«target.name», "«getSignalName(this)»");
	}
	«ENDIF-»
«ENDDEFINE»