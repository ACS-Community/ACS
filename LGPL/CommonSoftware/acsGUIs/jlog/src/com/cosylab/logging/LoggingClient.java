/*
 *    ALMA - Atacama Large Millimiter Array
 *    (c) European Southern Observatory, 2002
 *    Copyright by ESO (in the framework of the ALMA collaboration)
 *    and Cosylab 2002, All rights reserved
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 *    MA 02111-1307  USA
 */
package com.cosylab.logging;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.WindowEvent;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JViewport;
import javax.swing.ToolTipManager;
import javax.swing.event.MenuEvent;

import alma.acs.logging.archive.ArchiveConnectionManager;
import alma.acs.logging.archive.QueryDlg;
import alma.acs.logging.dialogs.main.LogEntryTable;
import alma.acs.logging.dialogs.main.LogFrame;
import alma.acs.logging.dialogs.main.LogMenuBar;
import alma.acs.logging.dialogs.main.LogToolBar;
import alma.acs.logging.preferences.UserPreferences;

import com.cosylab.gui.components.r2.SmartTextArea;
import com.cosylab.logging.client.DetailedLogTable;
import com.cosylab.logging.engine.ACS.ACSRemoteErrorListener;
import com.cosylab.logging.engine.ACS.ACSRemoteLogListener;
import com.cosylab.logging.engine.ACS.ACSLogConnectionListener;
import com.cosylab.logging.engine.ACS.LCEngine;
import com.cosylab.logging.engine.log.ILogEntry;
import com.cosylab.logging.search.SearchDialog;
import com.cosylab.logging.settings.ErrorLogDialog;
import com.cosylab.logging.settings.ExpertPrefsDlg;
import com.cosylab.logging.stats.StatsDlg;

/**
 * Defines a JRootPane Application LoggingClient for displaying event logs 
 * received through the CORBA protocol for the purpose of monitoring and 
 * reviewing of the logs. It contains of a JScrollPane scrollLogTable for the 
 * logs and a LogEntryTable logEntryTable for displaying the status 
 * as well as a JPanel ivjJFrameContentPane. Multiple listeners handle 
 * user's input. 
 * Based on the current code and our understanding of it one could describe
 * the information flow as follows. User's input triggers events which are 
 * caught by the listeners attached to each one of the available GUI object
 * representations defined in the LoggingClient class. 
 * Independent of that there are messages available at the logging system 
 * generated by the other services running in the framework. These messages are
 * parsed by the ACSStructuredPushConsumer class using the SAX parser and are
 * then passed on using the LogTableDataModel's appendLog method for outputing
 * the logs to the log table. 
 * In particular, we are interested in the saving and loading of files to be 
 * implemented by the LoggingClient. While saveFile and loadFromFile are defined 
 * in LogTabledataModel, the LogImportTask file makes use of the 
 * the LogTabledataModel's appendLog method as well. The use of the DocumentBuilderFactory 
 * in the LogImportTask defines a way for transforming a DOM tree into XML. 
 * 
 * An important issue is the format of the Log Entry Message produced by the Logging 
 * Service. Certain characters ('<', '>', '&', ''', '"') need to be escaped 
 * because they delineate markup data from character data and cause the following exception 
 * in ACSLogParserDOM class: 
 * org.xml.sax.SAXParseException: The content beginning with '<'
 * is not legal markup. 
 * One solution is replacing the character with the appropriate html substitute &lt;.
 * Another solution is keeping it in a CDATA section: <[!CDATA[the log entry message]]>.
 * 
 * The panel can be instantiated:
 *  - by LogFrame 
 *  - as an EXEC plugin
 */
public class LoggingClient extends JRootPane implements ACSRemoteLogListener, ACSLogConnectionListener, ACSRemoteErrorListener
{
	
	private ArchiveConnectionManager archive;
	
	// Create an instance of the preferences with default values
	private UserPreferences userPreferences = new UserPreferences();

	private JLabel ivjFilterStatus = null; // Not filtered

	private JPanel ivjJPanel1 = null;
	private JPanel ivjJPanel2 = null;
	private JPanel detailedInfoPanel = null;
	
	// The table showing the whole content of a log (in the detailed
	// panel at the right side of the main window)
	private DetailedLogTable detailedLogTable = new DetailedLogTable();
	
	// The panel with the suspend btn, the filter string...
	// It is immediately under the table of logs
	private JPanel filterStatusPnl = null;

	private JScrollPane statusAreaPanel = null; // The bottom scrolling panel with the status messages
	private JScrollPane detailedInfoScrollPane = null;

	private JSplitPane ivjJSplitPane1 = null;
	private JSplitPane ivjJSplitPane2 = null;

	private JScrollPane scrollLogTable = null;
	private LogEntryTable logEntryTable = null;

	private SmartTextArea ivjStatusArea = null;

	private JPanel ivjJFrameContentPane = null;
    
	private ErrorLogDialog errorDialog = new ErrorLogDialog(null,"jlog: Error log", false);
    
    // The progress bar for long time operations
    private JProgressBar progressBar = new JProgressBar(JProgressBar.HORIZONTAL);
    
    /**
     * The search dialog 
     * The object is built the first time the user requests a search
     */
    private SearchDialog searchDialog;

	private EventHandler eventHandler = new EventHandler();

	private boolean ivjConnPtoLCMod = false;

	private LCEngine engine = null;
	private LogTableDataModel tableModel = null;
	
	/**
	 * The icons to show the status of the connection
	 * 
	 */
	private final int CONNECTED_ICON =  0;
	private final int CONNECTING_ICON = 1;
	private final int DISCONNECTED_ICON=2;
	private final int SUSPENDED_ICON = 3;
	private final int DELAY_ICON = 4;
	private ImageIcon[] connectionStatusIcons; 
	// The label where icon is shown
	private JLabel connectionStatusLbl;
	
	// The label where the icon representing the status of the connection 
	// with the DB is shown
	private JLabel connectionDBLbl;
	
    // The toolbar
    private LogToolBar toolBar = new LogToolBar();
    
    // The menu bar
    private LogMenuBar menuBar = new LogMenuBar();
    
    // The frame containing this logging client
    // It is not null only if the application is executed in stand alone mode
    private LogFrame logFrame=null;
	
	class EventHandler
		implements
			java.awt.event.ActionListener,
			java.beans.PropertyChangeListener,
			javax.swing.event.MenuListener
	{
		public void actionPerformed(java.awt.event.ActionEvent e)
		{
			if (e.getSource() == menuBar.getConnectMenuItem()) {
				connect(menuBar.getConnectMenuItem().getText().compareTo("Connect")==0);
            } else if (e.getSource() == menuBar.getLoadMenuItem()) {
				getLCModel1().loadFromFile(null);
            } else if (e.getSource() == menuBar.getLoadURLMenuItem()) {
            	getLCModel1().loadFromURL();
            } else if (e.getSource() == menuBar.getSaveFileMenuItem()) {
            	getLCModel1().saveFile();
            } else if (e.getSource() == menuBar.getLoadDBMenuItem()) {
            	if (archive.getDBStatus()==ArchiveConnectionManager.DATABASE_OK) {
            		QueryDlg dlg = new QueryDlg(archive,LoggingClient.this,LoggingClient.this,LoggingClient.this);
            		dlg.setVisible(true);
            	}
            } else if (e.getSource() == menuBar.getClearLogsMenuItem() || e.getSource()==toolBar.getClearLogsBtn()) {
				getLCModel1().clearAll();
            } else if (e.getSource() == menuBar.getExitMenuItem()) {
            	if (logFrame!=null) {
        			// The application is executed in stand-alone mode
        			// Signal the main window to close
        			WindowEvent wEvt = new WindowEvent(logFrame,WindowEvent.WINDOW_CLOSING);
        			logFrame.dispatchEvent(wEvt);
        		} else {
        			close(false);
        		}
            }else if (e.getSource() == menuBar.getFieldsMenuItem()) {
				connFields(e);
            } else if (e.getSource() == menuBar.getFiltersMenuItem() || e.getSource()==toolBar.getFiltersBtn()) {
				showFiltersPanel(e);
            } else if (e.getSource()==toolBar.getPauseBtn()) {
				// Swap set the pause mode in the toolbar
				toolBar.clickPauseBtn();
				// Pause/unpause the engine
				engine.setPaused(toolBar.isPaused());
			} else if (e.getSource()==toolBar.getLogLevelCB()) {
				getLCModel1().setLogLevel(toolBar.getLogLevelCB().getSelectedIndex());
            } else if (e.getSource()==toolBar.getSearchBtn() ||
                    e.getSource()==menuBar.getSearchMenuItem()) {
                if (searchDialog==null) {
                    searchDialog = new SearchDialog(LoggingClient.this);
                }
                searchDialog.setVisible(true);
            } else if (e.getSource()==menuBar.getSearchNextMenuItem()) {
                // The searchDialog is always not null otherwise the
                // menu item is disabled but... repetita juvant ;-)
                if (searchDialog!=null) {
                    searchDialog.search();
                } else {
                    menuBar.getSearchNextMenuItem().setEnabled(false);
                }
            } else if (e.getSource()==menuBar.getViewToolbarMenuItem()) {
                // Hide/Show the toolbar
                toolBar.setVisible(menuBar.getViewToolbarMenuItem().getState());
            } else if (e.getSource()==menuBar.getStatisticsMenuItem()) {
            	// Show the statistics dialog
            	StatsDlg statsDlg = new StatsDlg(LoggingClient.this); 
            } else if (e.getSource()==menuBar.getViewErrorLogMenuItem()) { 
            		errorDialog.setVisible(true);
            } else if (e.getSource()==menuBar.getViewStatusAreaMenuItem()) {
            	getStatusAreaPanel().setVisible(menuBar.getViewStatusAreaMenuItem().getState());
            	if (menuBar.getViewStatusAreaMenuItem().getState()) {
            		getJSplitPane1().setDividerLocation(getHeight() - 150);
            	} else {
            		getJSplitPane1().setDividerLocation(getHeight());
            	}
            } else if (e.getSource()==menuBar.getViewDetailedInfoMenuItem()) {
            	getDeatailedInfoPanel().setVisible(menuBar.getViewDetailedInfoMenuItem().getState());
            	if (menuBar.getViewDetailedInfoMenuItem().getState()) {
            		int w = getLogTable().getWidth();
            		getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w/3);
            	} else {
            		getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
            	}
            } else if (e.getSource()==menuBar.getAutoReconnectMenuItem()) {
            	if (LoggingClient.this.engine!=null) {
            		LoggingClient.this.engine.enableAutoReconnection(menuBar.getAutoReconnectMenuItem().getState());
            	}
            } else if (e.getSource()==menuBar.getShortDateViewMenuItem()) {
            	logEntryTable.setShortDateFormat(menuBar.getShortDateViewMenuItem().getState());
            } else if (e.getSource()==toolBar.getPauseBtn()) {
            	toolBar.clickPauseBtn();
            } else if (e.getSource()==menuBar.getSuspendMenuItem()) {
            	getEngine().setSupended(menuBar.getSuspendMenuItem().isSelected());
            } else if (e.getSource()==menuBar.getPrefsMenuItem()) {
            	ExpertPrefsDlg dlg = new ExpertPrefsDlg(userPreferences.getMaxNumOfLogs(),userPreferences.getMinuteTimeFrame());
            	if (dlg.okPressed()) {
            		userPreferences.setMaxLogs(dlg.getMaxNumOfLogs());
            		userPreferences.setTimeFrame(dlg.getTimeFrame());
            		getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
            		getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
            	}
            } else {
            	System.err.println("Unrecognized ActionEvent "+e);
            }
		};

		public void propertyChange(java.beans.PropertyChangeEvent evt)
		{

			if (evt.getSource() == LoggingClient.this.getLogEntryTable() 
					&& (evt.getPropertyName().equals("filterString"))) {
				connFilter(evt);
			} else if (evt.getSource() == LoggingClient.this.getLogEntryTable() 
					&& (evt.getPropertyName().equals("extraInfo"))) {
				showDetailedLogInfo();
			} else if (evt.getSource() == LoggingClient.this.getLogEntryTable() 
					&& (evt.getPropertyName().equals("LCModel"))) {
				connLCMod();
			}
				
		}
		
		public void menuCanceled(MenuEvent menuE) {}
		public void menuDeselected(MenuEvent menuE) {}
		
		public void menuSelected(MenuEvent menuE) {
			// Some menus are disabled when loading/saving
			boolean enableMenu = !getLCModel1().IOInProgress();
			menuBar.getClearLogsMenuItem().setEnabled(enableMenu);
			if (getEngine().isConnected()) {
				menuBar.getConnectMenuItem().setText("Disconnect");
			} else {
				menuBar.getConnectMenuItem().setText("Connect");
			}
			menuBar.getConnectMenuItem().setEnabled(enableMenu);
			menuBar.getLoadMenuItem().setEnabled(enableMenu);
			menuBar.getLoadURLMenuItem().setEnabled(enableMenu);
			menuBar.getSaveFileMenuItem().setEnabled(enableMenu);
			
			// Ensure the status of the item shown in the main panel
			// is consistent with the menu item in View
			menuBar.getViewStatusAreaMenuItem().setSelected(getStatusAreaPanel().isVisible());
			menuBar.getViewDetailedInfoMenuItem().setSelected(getDeatailedInfoPanel().isVisible());
			menuBar.getViewToolbarMenuItem().setSelected(toolBar.isVisible());
			
			// Enable diasble the menu to load from the DB
			// if the DB is not available
			menuBar.getLoadDBMenuItem().setEnabled(archive.getDBStatus()==ArchiveConnectionManager.DATABASE_OK);
		}
		
		
	}
	
	
	
	/**
	 * Build the object in online/offline mode 
	 * 
	 * @param initialConnectionStatus If true jlog connects to the ACS logging system
	 */
	public LoggingClient()
	{
		super();
		initialize();
	}
	
	public LoggingClient(LogFrame frame)
	{
		super();
		logFrame=frame;
		initialize();
	}
	
	
	
	/**
	 * Method used by the plugin interface in EXEC:
	 * it connects the application to the NC
	 * @see alma.exec.extension.subsystemplugin.SubsystemPlugin
	 * 
	 * @throws Exception
	 */
	public void start() throws Exception {
			connect();
	}
	
	/**
	 * Method used by the plugin interface in EXEC.
	 * Stop the application disconnecting from the NC
	 * @see alma.exec.extension.subsystemplugin.SubsystemPlugin
	 * 
	 * @throws Exception
	 */
	public void stop() throws Exception {
		close(false);
	}
	
	/**
	 * Method used by the plugin interface in EXEC.
	 * Pause the application (scroll lock enabled)
	 * @see alma.exec.extension.subsystemplugin.IPauseResume
	 * 
	 * @throws Exception
	 */
	public void pause() throws Exception {
		toolBar.pause();
		engine.setPaused(true);
	}
	
	/**
	 * Method used by the plugin interface in EXEC.
	 * Unpause the application (scroll lock disabled)
	 * @see alma.exec.extension.subsystemplugin.IPauseResume
	 * 
	 * @throws Exception
	 */
	public void resume() throws Exception {
		toolBar.unpause();
		engine.setPaused(false);
	}
	
	
	/**
	 * Connect or disconnect the engine to the NC
	 * 
	 * @param connect If true the engine is connected
	 *                otherwise it is disconnected
	 */
	public void connect(boolean connectEngine) {
		if (connectEngine) {
			// Check and eventually un-suspend the engine
			menuBar.getSuspendMenuItem().setSelected(false);
			getEngine().setSupended(menuBar.getSuspendMenuItem().isSelected());
			// Connect the the channel
			connect();
		} else {
			menuBar.getAutoReconnectMenuItem().setState(false);
			LoggingClient.this.engine.enableAutoReconnection(false);
			disconnect();
		}
	}

    /**
	 * Connects to the remote system
	 * as soon as the item "New" is clicked.
	 */
	public void connect()
	{
		try
		{
			getEngine().connect("ACS");
		}
		catch (java.lang.Throwable ivjExc)
		{
			handleException(ivjExc);
		}
	}
	
	private void disconnect() {
		getEngine().disconnect();
	}

    /**
	 * Triggers the Field Choser's dialog visual appearance 
	 * as soon as the item "Fields" is clicked.
	 * @param arg1 java.awt.event.ActionEvent
	 */

	private void connFields(java.awt.event.ActionEvent arg1)
	{
		try
		{

			getLogEntryTable().showFieldChooser();

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}
	
	/**
	 Triggers the Filters dialog visual appearance 
	 * as soon as the item "Filters" is clicked.
	 * @param arg1 java.awt.event.ActionEvent
	 */
	private void showFiltersPanel(java.awt.event.ActionEvent arg1)
	{
		try
		{
			enableFiltersWidgets(false);
			getLogEntryTable().showFilterChooser(true);
		}
		catch (java.lang.Throwable ivjExc)
		{
			handleException(ivjExc);
			enableFiltersWidgets(true);
		}
	}

	/**
	 * Returns the JFrameContentPane property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getJFrameContentPane()
	{
		if (ivjJFrameContentPane == null)
		{
			try
			{
				ivjJFrameContentPane = new javax.swing.JPanel();
				ivjJFrameContentPane.setName("JFrameContentPane");
				ivjJFrameContentPane.setLayout(new java.awt.BorderLayout());
				ivjJFrameContentPane.add(getJSplitPane1(), "Center");
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return ivjJFrameContentPane;
	}

	/**
	 * CustomColumnListener implements componentResized() of a ComponentListener. 
	 * It has been added to JScrollPane scrollLogTable to increase the width of 
	 * the Log Message column as soon as the space is available.
	 */
	private class CustomColumnListener implements ComponentListener
	{
		public void componentShown(ComponentEvent evt)
		{
		}

		public void componentHidden(ComponentEvent evt)
		{
		}

		public void componentMoved(ComponentEvent evt)
		{
		}

		// This method is called after the component's size changes
		public void componentResized(ComponentEvent evt)
		{
			// gets the component JTable LogEntryTable that has been changed
			Component c = (Component) evt.getSource();

			// gets the width of JTable LogEntryTable
			// in case a vertical ScrollBar appears the width remains the same
			int tableWidthTobe = c.getSize().width;

			// sets a preferred size to JScrollPane
			getLogEntryTable().setPreferredScrollableViewportSize(new Dimension(tableWidthTobe, c.getSize().height));

			// gets the number of columns in JTable LogEntryTable
			int numCols = getLogEntryTable().getColumnModel().getColumnCount();

			// computes the width of the table taking into consideration all visible columns
			int columnWidth = getLogEntryTable().getColumnWidth(numCols);

			// adds width to the Log Message column
			getLogEntryTable().setAdditionalWidth(numCols, tableWidthTobe - columnWidth);
		}
	}

	/**
	 * Returns the LogTable property value.
	 * @return javax.swing.JScrollPane
	 */

	public javax.swing.JScrollPane getLogTable()
	{
		if (scrollLogTable == null)
		{
			try
			{
				scrollLogTable = new javax.swing.JScrollPane();
				scrollLogTable.setName("LogTable");
				scrollLogTable.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
				scrollLogTable.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
				scrollLogTable.setBackground(new java.awt.Color(204, 204, 204));
				scrollLogTable.setFont(new java.awt.Font("Arial", 1, 12));
				scrollLogTable.setMinimumSize(new java.awt.Dimension(100, 50));
				scrollLogTable.addComponentListener(new CustomColumnListener());
				scrollLogTable.setColumnHeaderView(getLogEntryTable().getTableHeader());
				scrollLogTable.setViewportView(getLogEntryTable());
				scrollLogTable.getViewport().setScrollMode(JViewport.BLIT_SCROLL_MODE);
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return scrollLogTable;
	}

	
	
	/**
	 * Returns the ScrollPaneTable property value.
	 * @return com.cosylab.logging.client.LogEntryTable
	 */

	public LogEntryTable getLogEntryTable()
	{
		if (logEntryTable == null)
		{
			try
			{
				logEntryTable = new LogEntryTable(this,menuBar.getShortDateViewMenuItem().isSelected());
				logEntryTable.setName("ScrollPaneTable");
				logEntryTable.setBounds(0, 0, 200, 200);
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return logEntryTable;
	}

	/**
	 * Called whenever the part throws an exception.
	 * @param exception java.lang.Throwable
	 */
	private void handleException(java.lang.Throwable exception)
	{

		/* Uncomment the following lines to print uncaught exceptions to stdout */
		System.out.println("--------- UNCAUGHT EXCEPTION ---------");
		exception.printStackTrace(System.err);
		JOptionPane.showMessageDialog(null,exception.getMessage(),"Uncaught exception",JOptionPane.ERROR_MESSAGE);
	}
	/**
	 * Initializes connections and adds listeners to all the menus and menu items.
	 * @exception java.lang.Exception The exception description.
	 */
	private void initConnections() throws java.lang.Exception
	{
		menuBar.setEventHandler(eventHandler, eventHandler);
		toolBar.setEventHandler(eventHandler);
		getLogEntryTable().addPropertyChangeListener(eventHandler); // ScrollPaneTable		

		connLCMod();
	}

	/**
	 * Initializes the object.
	 */
	private void initialize()
	{
		try
		{
			setName("LoggingClientPanel");
			
			// Set the tooltip manager
			ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
			toolTipManager.setDismissDelay(60000);
			
			Dimension d = new Dimension(750, 550);
			setPreferredSize(d);
			
			getContentPane().setLayout(new BorderLayout());
			setJMenuBar(menuBar);
            
            //  Add the GUI in the center position
			getContentPane().add(getJFrameContentPane(),BorderLayout.CENTER);
            
            // Add the tool bar
			getContentPane().add(toolBar,BorderLayout.NORTH);
            
    		initConnections();
    		validate();
            
			getLCModel1().setLogLevel(toolBar.DEFAULT_LOGLEVEL.ordinal());
			
			getLCModel1().setTimeFrame(userPreferences.getMillisecondsTimeFrame());
			getLCModel1().setMaxLog(userPreferences.getMaxNumOfLogs());
			
			archive = new ArchiveConnectionManager(this);
		}
		catch (java.lang.Throwable ivjExc)
		{
			handleException(ivjExc);
		}

		// java 1.2.2. bugfix
		getJSplitPane2().setDividerLocation(getJSplitPane2().getLastDividerLocation());
		getJSplitPane1().setDividerLocation(350); //getHeight() - 150);
		// user code end

	}

	/**
	 * The method is executed when the filter property ("filterString") changes.
	 * 
	 * This property has to be changed in the LogEntryTable but the listener is 
	 * in LoggingClient to update the GUI .
	 * 
	 * @param arg1 java.beans.PropertyChangeEvent
	 */

	private void connFilter(java.beans.PropertyChangeEvent arg1)
	{
		try
		{
			getFilterStatus().setText(String.valueOf(getLogEntryTable().getFilterString()));

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}

	/**
	 * Show a detailed view of the selected log in the right panel
	 */
	public void showDetailedLogInfo()
	{
		try {
			LogEntryTable jt = getLogEntryTable();
			int selectedRow = jt.getSelectedRow();
			// Check whether a row has been selected
			// no row selected
			if (selectedRow == -1) {
				detailedLogTable.setupContent(null);
			} else {
				// a row is selected
				ILogEntry log = jt.getLCModel().getVisibleLogEntry(selectedRow);
				detailedLogTable.setupContent(log);
			}
		} catch (java.lang.Throwable ivjExc) {
			handleException(ivjExc);
		}
	}
	
	/**
	 * Set the content of the detailed info table from the given log
	 * 
	 * @param log The log entry which fields have to be shown in the table
	 *            It can be null
	 * @return The component that displays the datas
	 */
	public void setLogDetailContent(ILogEntry log)
	{
		// Try to build a DetailedLogTable
		detailedLogTable.setupContent(log);
	}

	/**
	 * Disconnects the LCEngine.
	 * @param arg1 java.awt.event.WindowEvent
	 */

	public void connLCEngDisconnect(WindowEvent arg1)
	{
		try
		{

			getEngine().disconnect();

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}

	/**
	 * Sets the LCModel.
	 */

	private void connLCMod()
	{
		/* Set the target from the source */
		try
		{
			if (ivjConnPtoLCMod == false)
			{

				ivjConnPtoLCMod = true;
				setLCModel1(getLogEntryTable().getLCModel());

				ivjConnPtoLCMod = false;
			}
		}
		catch (java.lang.Throwable ivjExc)
		{
			ivjConnPtoLCMod = false;

			handleException(ivjExc);
		}
	}
	
	/**
	 * Returns the FilterStatus property value.
	 * @return javax.swing.JLabel
	 */
	/* WARNING: THIS METHOD WILL BE REGENERATED. */
	private javax.swing.JLabel getFilterStatus()
	{
		if (ivjFilterStatus == null)
		{
			try
			{
				ivjFilterStatus = new javax.swing.JLabel();
				ivjFilterStatus.setName("FilterStatus");
				ivjFilterStatus.setText("Not filtered");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjFilterStatus;
	}
	/**
	 * Returns the groupMenu1 property value.
	 * @return javax.swing.JMenu
	 */

	/**
	 * Returns the JPanel1 property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getJPanel1()
	{
		if (ivjJPanel1 == null)
		{
			try
			{
				ivjJPanel1 = new javax.swing.JPanel();
				ivjJPanel1.setName("JPanel1");
				ivjJPanel1.setLayout(new java.awt.GridBagLayout());

				java.awt.GridBagConstraints constraintsLogTable = new java.awt.GridBagConstraints();
				constraintsLogTable.gridx = 0;
				constraintsLogTable.gridy = 0;
				constraintsLogTable.fill = java.awt.GridBagConstraints.BOTH;
				constraintsLogTable.weightx = 1.0;
				constraintsLogTable.weighty = 1.0;
				ivjJPanel1.add(getLogTable(), constraintsLogTable);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJPanel1;
	}

	/**
	 * Returns the JPanel2 property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getJPanel2()
	{
		if (ivjJPanel2 == null)
		{
			try
			{
				ivjJPanel2 = new javax.swing.JPanel();
				ivjJPanel2.setName("JPanel2");
				ivjJPanel2.setLayout(new java.awt.BorderLayout());
				ivjJPanel2.add(getFilterStatusPnl(), "South");
				ivjJPanel2.add(getJSplitPane2(), "Center");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJPanel2;
	}
	/**
	 * Returns the JPanel3 property value.
	 * @return javax.swing.JPanel
	 */
	private JPanel getDeatailedInfoPanel()
	{
		if (detailedInfoPanel == null)
		{
			try
			{
				BorderLayout layout = new BorderLayout();
				layout.setVgap(10);
				detailedInfoPanel = new JPanel(layout);
				detailedInfoPanel.setName("detailedInfoPanel");
				JLabel lbl =new JLabel("Detailed info");
				detailedInfoPanel.add(lbl,BorderLayout.NORTH);
				detailedInfoPanel.add(getLogDetailScrollPane(), BorderLayout.CENTER);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return detailedInfoPanel;
	}
	/**
	 * Returns the JPanel4 property value.
	 * @return javax.swing.JPanel
	 */
	private JPanel getFilterStatusPnl()
	{
		if (filterStatusPnl == null)
		{
			try
			{
				// Load the icons for the status of the connection
				connectionStatusIcons = new ImageIcon[5];
				connectionStatusIcons[CONNECTED_ICON]=new ImageIcon(this.getClass().getResource("/console-connected.png"));
				connectionStatusIcons[CONNECTING_ICON]=new ImageIcon(this.getClass().getResource("/console-connecting.png"));
				connectionStatusIcons[DISCONNECTED_ICON]=new ImageIcon(this.getClass().getResource("/console-disconnected.png"));
				connectionStatusIcons[SUSPENDED_ICON]=new ImageIcon(this.getClass().getResource("/console-suspended.png"));
				connectionStatusIcons[DELAY_ICON]=new ImageIcon(this.getClass().getResource("/console-delay.png"));
				connectionStatusLbl = new JLabel(connectionStatusIcons[CONNECTING_ICON]);
				
				// Create a label to show the status of the connection with the DB
				connectionDBLbl = new JLabel();
				
				filterStatusPnl = new javax.swing.JPanel();
				filterStatusPnl.setName("JPanel4");
				filterStatusPnl.setLayout(new java.awt.GridBagLayout());
				
				GridBagConstraints constraintsFilterStatus = new GridBagConstraints();
				constraintsFilterStatus.gridx = 0;
				constraintsFilterStatus.gridy = 0;
				constraintsFilterStatus.fill = GridBagConstraints.BOTH;
				constraintsFilterStatus.anchor = GridBagConstraints.WEST;
				constraintsFilterStatus.weightx = 1.0;
				constraintsFilterStatus.insets = new Insets(1, 2, 1, 1);
				filterStatusPnl.add(getFilterStatus(), constraintsFilterStatus);

				GridBagConstraints constraintsProgressBar = new GridBagConstraints();
		        constraintsProgressBar.gridx=1;
		        constraintsProgressBar.gridy=0;
		        constraintsProgressBar.insets = new Insets(1,1,1,1);
		        progressBar.setVisible(false);
		        filterStatusPnl.add(progressBar,constraintsProgressBar);
				
		        GridBagConstraints constraintsConnectionDBStatus = new GridBagConstraints();
				constraintsConnectionDBStatus.gridx = 2;
				constraintsConnectionDBStatus.gridy = 0;
				constraintsConnectionDBStatus.insets = new Insets(1, 2, 1, 2);
				filterStatusPnl.add(connectionDBLbl,constraintsConnectionDBStatus);
		        
				GridBagConstraints constraintsConnectionStatus = new GridBagConstraints();
				constraintsConnectionStatus.gridx = 3;
				constraintsConnectionStatus.gridy = 0;
				constraintsConnectionStatus.insets = new Insets(1, 2, 1, 2);
				filterStatusPnl.add(connectionStatusLbl,constraintsConnectionStatus);
			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return filterStatusPnl;
	}

	/**
	 * Returns the JScrollPane1 property value.
	 * @return javax.swing.JScrollPane
	 */
	private javax.swing.JScrollPane getStatusAreaPanel()
	{
		if (statusAreaPanel == null)
		{
			try
			{
				statusAreaPanel = new javax.swing.JScrollPane();
				statusAreaPanel.setName("JScrollPane1");
				statusAreaPanel.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
				statusAreaPanel.setPreferredSize(new java.awt.Dimension(50, 50));
				statusAreaPanel.setMinimumSize(new java.awt.Dimension(50, 50));
				statusAreaPanel.setViewportView(getStatusArea());
				statusAreaPanel.setVisible(false);
			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return statusAreaPanel;
	}
	
	
	/**
	 * Returns the scroll pane with the details of the logs
	 * 
	 * @return JScrollPane
	 */
	public JScrollPane getLogDetailScrollPane()
	{
		if (detailedInfoScrollPane == null)
		{
			try
			{
				detailedInfoScrollPane = new JScrollPane(detailedLogTable);
				detailedInfoScrollPane.setName("detailedInfoScrollPane");
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return detailedInfoScrollPane;
	}
	/**
	 * Returns the JSplitPane1 property value.
	 * @return javax.swing.JSplitPane
	 */
	private javax.swing.JSplitPane getJSplitPane1()
	{
		if (ivjJSplitPane1 == null)
		{
			try
			{
				ivjJSplitPane1 = new javax.swing.JSplitPane(javax.swing.JSplitPane.VERTICAL_SPLIT);
				ivjJSplitPane1.setName("JSplitPane1");
				ivjJSplitPane1.setLastDividerLocation(350);
				ivjJSplitPane1.setDividerLocation(350);
				ivjJSplitPane1.add(getStatusAreaPanel(), "bottom");
				ivjJSplitPane1.add(getJPanel2(), "top");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJSplitPane1;
	}
	/**
	 * Returns the JSplitPane2 property value.
	 * @return javax.swing.JSplitPane
	 */

	private javax.swing.JSplitPane getJSplitPane2()
	{
		if (ivjJSplitPane2 == null)
		{
			try
			{
				ivjJSplitPane2 = new javax.swing.JSplitPane(javax.swing.JSplitPane.HORIZONTAL_SPLIT);
				ivjJSplitPane2.setName("JSplitPane2");
				ivjJSplitPane2.setLastDividerLocation(570);
				ivjJSplitPane2.setAlignmentX(java.awt.Component.LEFT_ALIGNMENT);
				ivjJSplitPane2.setContinuousLayout(true);
				//ivjJSplitPane2.setDividerLocation(501);
				ivjJSplitPane2.add(getJPanel1(), "left");
				ivjJSplitPane2.add(getDeatailedInfoPanel(), "right");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJSplitPane2;
	}
	
	/**
	 * Returns the LCEngine property value.
	 * @return com.cosylab.logging.LCEngine
	 */
	public LCEngine getEngine()
	{
		if (engine == null)
		{
			try
			{
				engine = new LCEngine();
				engine.addLogConnectionListener(this);
				engine.addLogListener(this);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return engine;
	}
	
	/**
	 * Returns the LCModel1 property value.
	 * @return com.cosylab.logging.LogTableDataModel
	 */
	public LogTableDataModel getLCModel1()
	{

		return tableModel;
	}

	/**
	 * Returns the StatusArea property value.
	 * @return com.cosylab.gui.components.SmartTextArea
	 */
	private SmartTextArea getStatusArea()
	{
		if (ivjStatusArea == null)
		{
			try
			{
				ivjStatusArea = new SmartTextArea();
				ivjStatusArea.setName("StatusArea");
				ivjStatusArea.setLocation(0, 0);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjStatusArea;
	}
	/**
	 * Sets the height and width generated by user's actions.
	 */
	public void loggingClient_ComponentResized(java.awt.event.ComponentEvent e)
	{
		if (e.getComponent() == this)
		{
			int w = getLogTable().getWidth();
			int h = getLogTable().getHeight();
			System.out.println(w + ", " + h);
			System.out.println(getJSplitPane2().getWidth());
			System.out.println(getJSplitPane1().getHeight());

			getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w);
			getJSplitPane1().setDividerLocation(getJSplitPane1().getHeight() - h);
		}
	}

	/**
	 * Sets the LCModel1 to a new value.
	 * @param newValue com.cosylab.logging.LogTableDataModel
	 */
	private void setLCModel1(LogTableDataModel newValue)
	{
		if (tableModel != newValue)
		{
			try
			{
				tableModel = newValue;

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		};

	}
	
	
	
	
    /**
     * Enable or disable the Search next menu item
     * (tipically this action is preformed by the SearchDialog when a valid search
     * is performed)
     * 
     * @param enable true enable the searchNextMenuItem
     */
    public void enableSearchNext(boolean enable) {
        menuBar.getSearchNextMenuItem().setEnabled(enable);
    }
    
    /**
     * Show the progres bar as determinate with the given min and max
     * 
     * @param textThe text to show in the toolbar
     *            If it is null or empty then no text will be displayed
     * @param min The starting position
     * @param max The final position
     */
    public void animateProgressBar(String text, int min, int max) {
    	if (progressBar.isVisible()) {
    		throw new IllegalStateException("Exception trying to set the Progress Bar");
    	}
    	if (min>=max) {
    		throw new IllegalArgumentException("Invalid range: ["+min+","+max+"]");
    	}
    	Cursor hourglassCursor = new Cursor(Cursor.WAIT_CURSOR);
    	setCursor(hourglassCursor);
    	if (text!=null && text.length()>0) {
    			progressBar.setString(text);
    			progressBar.setStringPainted(true);
    			progressBar.setToolTipText(text);
    	} else {
    		progressBar.setStringPainted(false);
    		progressBar.setToolTipText("Wait please");
    	}
    	progressBar.setMinimum(min);
    	progressBar.setMaximum(max);
    	progressBar.setIndeterminate(false);
    	progressBar.setVisible(true);
    }
    
    /**
     * Move the progressbar when in determinate mode
     * @param newPos
     */
    public void moveProgressBar(int newPos) {
    	progressBar.setValue(newPos);
    }
    
    /**
     * Show the progress bar as indeterminate
     * 
     *@param text The text to show in the toolbar
     *            If it is null or empty then no text will be displayed
     */
    public void animateProgressBar(String text) {
    	if (progressBar.isVisible()) {
    		throw new IllegalStateException("Exception trying to set the Progress Bar");
    	}
    	Cursor hourglassCursor = new Cursor(Cursor.WAIT_CURSOR);
    	setCursor(hourglassCursor);
    	if (text!=null && text.length()>0) {
    			progressBar.setString(text);
    			progressBar.setStringPainted(true);
    			progressBar.setToolTipText(text);
    	} else {
    		progressBar.setStringPainted(false);
    		progressBar.setToolTipText("Wait please");
    	}
    	progressBar.setIndeterminate(true);
    	progressBar.setVisible(true);
    }
    
    /**
     * Hide the progress bar (i.e. a long operation
     * has terminated)
     */
    public void freezeProgressBar() {
    	progressBar.setIndeterminate(false);
    	progressBar.setMinimum(0);
    	progressBar.setMaximum(100);
    	progressBar.setValue(0);
    	progressBar.setStringPainted(false);
    	progressBar.setToolTipText(null);
    	progressBar.setVisible(false);
    	Cursor normalCursor = new Cursor(Cursor.DEFAULT_CURSOR);
    	setCursor(normalCursor);
    }
    
    /**
     * @return true if the application is connected to the notification channel
     *
     */
    public boolean isConnected() {
    	return getEngine().isConnected();
    }
    
    /**
     * 
     * @return The discard log level
     * @see LoggingClient.discardLevelCB
     */
    public int getDiscardLevel() {
    	return toolBar.getDiscardLevelCB().getSelectedIndex();
    }
    
    /**
     * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
     */
    public void logEntryReceived(ILogEntry logEntry) {
    	if (logEntry.getType().ordinal()>=toolBar.getDiscardLevelCB().getSelectedIndex()) {
			getLogEntryTable().getLCModel().appendLog(logEntry);
		} 
    }
    
    /**
     * 
     * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
     */
    public void reportStatus(String status) {
    	StringBuilder str = new StringBuilder("Error parsing the following log: \n");
		str.append(status);
		str. append("\n The log has been lost.\n");
    	getStatusArea().append(str.toString());
    }
    
   /**
    * Notify that the connection with ACS NC has been established
    * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnEstablished() {
		//setTitle("LoggingClient");
		connectionStatusLbl.setIcon(connectionStatusIcons[CONNECTED_ICON]);
		connectionStatusLbl.setToolTipText("Connected");
	}
	
	/**
     * 
     * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
     */
	public void acsLogConnDisconnected() {
		//setTitle("LoggingClient - Offline");
		connectionStatusLbl.setIcon(connectionStatusIcons[DISCONNECTED_ICON]);
		connectionStatusLbl.setToolTipText("Disconnected");
	}
	
	/**
	 * Notify that the connection with ACS NC has been lost
	 *@see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnLost() {
		JOptionPane.showMessageDialog(null,"Connection lost!","LoggingClient error",JOptionPane.ERROR_MESSAGE);
		connectionStatusLbl.setIcon(connectionStatusIcons[DISCONNECTED_ICON]);
		connectionStatusLbl.setToolTipText("Disconnected");
	}
	
	/**
	 * Notify that an attempt to connect to ACS NC is in progress
	 * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnConnecting() {
		//setTitle("LoggingClient - Connecting");
		connectionStatusLbl.setIcon(connectionStatusIcons[CONNECTING_ICON]);
		connectionStatusLbl.setToolTipText("Connecting");
	}
	
	/**
	 * Notify that the service is supended 
	 * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnSuspended() {
		//setTitle("LoggingClient - Suspended");
		connectionStatusLbl.setIcon(connectionStatusIcons[SUSPENDED_ICON]);
		connectionStatusLbl.setToolTipText("Suspended");
	}
	
	/**
	 * Notify that for some internal reason the service is not able
	 * to follow the flow of the incoming logs
	 * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogsDelay() {
		connectionStatusLbl.setIcon(connectionStatusIcons[DELAY_ICON]);
		connectionStatusLbl.setToolTipText("Delay");
	}
	
	/**
	 * Enable/Disbale all the control in tha GUI than can cause
	 * the invalidation of the logs
	 * 
	 * @param enabled If true the controls are enabled
	 */
	public void setEnabledGUIControls(boolean enabled) {
		toolBar.setEnabledGUIControls(enabled);
		menuBar.setEnabledGUIControls(enabled);
	}
	
	/**
	 * Update the GUI with the status of the DB connection
	 * 
	 * @param icon The icon 
	 * @param msg A message to show as tooltip
	 */
	public void showDBStatus(ImageIcon icon,String msg) {
		connectionDBLbl.setIcon(icon);
		connectionDBLbl.setToolTipText(msg);
	}
	
	/**
	 * @return A reference to the preferences 
	 */
	public UserPreferences getPrefs() {
		return userPreferences;
	}
	
	/**
	 * Return true if the application is paused
	 * 
	 * @return
	 */
	public boolean isPaused() {
		return toolBar.isPaused();
	}
	
	/**
	 * Hide the Exit menu item
	 * 
	 * @param hide If true the menu is set to invisible
	 */
	public void hideExitMenu(boolean hide) {
		menuBar.hideExitMenu(hide);
	}
	
	/**
	 * Close all the threads and release all the resources
	 * @param sync If it is true wait the termination of the threads before returning
	 */
	public void close(boolean sync) {
		disconnect();
		if (tableModel!=null) {
			tableModel.close(sync);
		}
		if (logEntryTable!=null) {
			logEntryTable.close();
		}
		if (engine!=null) {
			engine.disconnect();
		}
	}
	
	/**
	 * Enable/disable the filter menu item and the filter button
	 * in the tool bar
	 * 
	 * @param enable true enables the widgets
	 */
	public void enableFiltersWidgets(boolean enable) {
		toolBar.getFiltersBtn().setEnabled(enable);
		menuBar.getFiltersMenuItem().setEnabled(enable);
	}
	
	/**
	 * @see ACSRemoteErrorListener
	 */
	public void errorReceived(String xml) {
		StringBuilder str = new StringBuilder("Error parsing the following log: \n");
		str.append(xml);
		str. append("\n The log has been lost.");
		errorDialog.appendText(str.toString());
	}
}

