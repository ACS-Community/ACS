/******************************************************************************** $Id: testComponent.idl,v 1.4 2008/03/26 09:54:54 acaproni Exp $
* DO NOT EDIT
* Automatically generated from ../idl/testComponent.midl
* on Wed Mar 26 10:53:22 2008
*******************************************************************************/
#ifndef _testComponent_midl_
#define _testComponent_midl_
#ifndef _ACS_PREPROCESSED_
#define _ACS_PREPROCESSED_
#endif
#include <baci.idl>
#include <enumpropMACRO.idl>

#pragma prefix "alma"

module alarmsystemPropTest
{

 enum AlarmEnum { Ok, Not, Initing, Busy };

 typedef sequence<AlarmEnum> AlarmEnumSeq; interface CBAlarmEnum : ACS::Callback { oneway void working(in AlarmEnum value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in AlarmEnum value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBAlarmEnum AlarmEnumCB; interface AlarmAlarmEnum : ACS::Callback { oneway void alarm_raised(in AlarmEnum value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in AlarmEnum value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmAlarmEnum AlarmEnumAlarm; interface PAlarmEnum: ACS::TypelessProperty { AlarmEnum get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out AlarmEnumSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute AlarmEnum default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute AlarmEnumSeq allStates; };
 interface ROAlarmEnum: PAlarmEnum{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute AlarmEnumSeq alarm_on; readonly attribute AlarmEnumSeq alarm_off; };
 interface RWAlarmEnum: PAlarmEnum { ACSErr::Completion set_sync(in AlarmEnum value); void set_async(in AlarmEnum value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in AlarmEnum value);};


interface BaciPropTest : ACS::CharacteristicComponent
 {

  void setDoubleVar(in float val);


  void setPatternVar(in short bit, in boolean set);


  void setEnumVar(in AlarmEnum val);





  readonly attribute ACS::ROdouble testDoubleVar;


  readonly attribute ACS::ROpattern testPatternVar;


  readonly attribute ROAlarmEnum testEnumVar;
        };

};

#endif
