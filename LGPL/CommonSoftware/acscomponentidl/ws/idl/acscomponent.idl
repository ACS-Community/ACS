#ifndef _ACSCOMPONENT_IDL_
#define _ACSCOMPONENT_IDL_

/*******************************************************************************
*    ALMA - Atacama Large Millimiter Array
*
*    (c) European Southern Observatory, 2002
*    Copyright by ESO (in the framework of the ALMA collaboration)
*    and Cosylab 2002, All rights reserved
*
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    Lesser General Public License for more details.
*
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*
*
* "@(#) $Id: acscomponent.idl,v 1.6 2011/03/15 18:04:35 hsommer Exp $"
*
* who       when      what
* --------  --------  ----------------------------------------------
* oat       28/08/03  created
*/


#pragma prefix "alma"


module ACS {
  
  
  /**
   * Component state enumeration.
   * Component starts it's lifecycle in state <code>NEW</code>.
   * During objects life it cycles though following states in prescribed order,
   * possibly skipping the nasty ones:
   * <ul>
   * <li><code>COMPSTATE_NEW</code></li>
   * <li><code>COMPSTATE_INITIALIZING</code></li>
   * <li><code>COMPSTATE_INITIALIZED</code></li>
   * <li><code>COMPSTATE_OPERATIONAL</code></li>
   * <li><code>COMPSTATE_ERROR</code></li>
   * <li><code>COMPSTATE_DESTROYING</code></li>
   * <li><code>COMPSTATE_ABORTING</code></li>
   * <li><code>COMPSTATE_DEFUNCT</code></li>
   * </ul>
   *
   * Object lifecycle can be aborted anytime, abort sequence prescribes next order. 
   * <ul>
   * <li><code>COMPSTATE_ABORTING</code></li>
   * <li><code>COMPSTATE_DEFUNCT</code></li>
   * </ul>
   *
   * The COMPSTATE_UNKNOWN signals an abnormal situation, or a situation
   * where it is not possible to read/retrieve the state
   *
   * There also exists an error state:
   * <ul>
   * <li><code>COMPSTATE_ERROR</code></li>
   * </ul>
   *
   * Note: recycable objects are allowed to be initialized again after
   * <code>COMPSTATE_DESTROYING</code> or <code>COMPSTATE_ERROR</code> states.
   */
  enum ComponentStates {
    COMPSTATE_NEW,
    COMPSTATE_INITIALIZING,
    COMPSTATE_INITIALIZED,
    COMPSTATE_OPERATIONAL,
    COMPSTATE_ERROR,
    COMPSTATE_DESTROYING,
    COMPSTATE_ABORTING,
    COMPSTATE_DEFUNCT,
    COMPSTATE_UNKNOWN
  };
  
  
  /** ACSComponent is the base interface which every ACS component derives from.
   *  It defines components without characteristic access in the CDB (dynamic
   *  components.  
   */
  interface ACSComponent {
    
    /** Component name */
    readonly attribute string name;
    
    /** Component status */
    readonly attribute ComponentStates componentState;

  };

  /**
   * This interface may be implemented by any remote object (component, offshoot, other resources...)
   * that you want to monitor in the master component.
   * Note that resource monitoring framework in module 'mastercomp' supports monitoring of ACSComponents
   * for which it checks the 'componentState' attribute.
   * However, this componentState only tells us something about the Alma component itself, but not about
   * any resources it controls or uses.
   * While resource monitoring via 'componentState' does not require specific changes in the component,
   * the check call cannot be intercepted by the component, which means that the value of the returned
   * information is limited.
   * On the other hand, this 'PingableResource' interface shows up in the component definition,
   * but allows for "deeper" outreach of the status check.
   * Of course your components and resources can use any other method to get their status checked
   * by your master component, but in that case you must implement a custom "ResourceChecker" class;
   * with "PingableResource" you can use the convenience methods provided by ACS.
   *
   */
  interface PingableResource
  {
    /**
     * @param fast  If true, skip performing fancier checks, so that the returned result only tells us whether the resources can communicate,
     *              but not if they are otherwise healthy. This could be used for performance measurements.
     * @param recursive  If true, the call should recursively ping other PingableResources managed by this PingableResource.
     * @param id  The caller may pass a random number that can be used by the resources to identify this call
     *            and avoid endless recursion if "recursive" is true and it is not clear whether the resource topology is free of cycles.
     * @return true means the resource is OK
     */
    boolean ping(in boolean fast, in boolean recursive, in long id);
  };


};

#endif /* _ACSCOMPONENT_IDL_ */
