/*
 *    ALMA - Atacama Large Millimiter Array
 *    (c) European Southern Observatory, 2002
 *    Copyright by ESO (in the framework of the ALMA collaboration)
 *    and Cosylab 2002, All rights reserved
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 *    MA 02111-1307  USA
 */
package com.cosylab.logging;

import java.awt.Component;
import java.awt.Dimension;
import javax.swing.event.MenuEvent;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.Toolkit;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Cursor;

import java.io.File;
import java.io.IOException;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import javax.swing.JSplitPane;
import javax.swing.JOptionPane;
import javax.swing.JToggleButton;
import javax.swing.JFileChooser;
import javax.swing.UIManager;
import javax.swing.filechooser.FileFilter;
import javax.swing.JToolBar;
import javax.swing.JComboBox;
import javax.swing.JButton;
import javax.swing.JProgressBar;
import javax.swing.KeyStroke;

import com.cosylab.gui.components.r2.SmartTextArea;

import com.cosylab.logging.client.DetailedLogTable;
import com.cosylab.logging.engine.Filter;
import com.cosylab.logging.engine.FiltersVector;
import com.cosylab.logging.engine.log.ILogEntry;
import com.cosylab.logging.engine.log.LogTypeHelper;
import com.cosylab.logging.settings.LogTypeRenderer;

import com.cosylab.logging.engine.ACS.ACSRemoteLogListener;
import com.cosylab.logging.engine.ACS.LCEngine;

import com.cosylab.logging.stats.StatsDlg;

import com.cosylab.logging.search.SearchDialog;

/**
 * This type was generated by a SmartGuide.
 * 
 * Defines a JFrame Application LoggingClient for displaying event logs 
 * received through the CORBA protocol for the purpose of monitoring and 
 * reviewing of the logs. It contains of a JScrollPane scrollLogTable for the 
 * logs and a LogEntryTable logEntryTable for displaying the status 
 * as well as a JPanel ivjJFrameContentPane. Multiple listeners handle 
 * user's input. 
 * Based on the current code and our understanding of it one could describe
 * the information flow as follows. User's input triggers events which are 
 * caught by the listeners attached to each one of the available GUI object
 * representations defined in the LoggingClient class. 
 * Independent of that there are messages available at the logging system 
 * generated by the other services running in the framework. These messages are
 * parsed by the ACSStructuredPushConsumer class using the SAX parser and are
 * then passed on using the LogTableDataModel's appendLog method for outputing
 * the logs to the log table. 
 * In particular, we are interested in the saving and loading of files to be 
 * implemented by the LoggingClient. While saveFile and loadFromFile are defined 
 * in LogTabledataModel, the LogImportTask file makes use of the 
 * the LogTabledataModel's appendLog method as well. The use of the DocumentBuilderFactory 
 * in the LogImportTask defines a way for transforming a DOM tree into XML. 
 * 
 * An important issue is the format of the Log Entry Message produced by the Logging 
 * Service. Certain characters ('<', '>', '&', ''', '"') need to be escaped 
 * because they delineate markup data from character data and cause the following exception 
 * in ACSLogParser class: 
 * org.xml.sax.SAXParseException: The content beginning with '<'
 * is not legal markup. 
 * One solution is replacing the character with the appropriate html substitute &lt;.
 * Another solution is keeping it in a CDATA section: <[!CDATA[the log entry message]]>.
 */
public class LoggingClient extends JFrame implements ACSRemoteLogListener
{
	// The loggingClient is a singleton
	private static LoggingClient singleton=null;
	
	// Connect or disconnect text depending on the status of the connection
	// The text is changed by checking the connection before displaying the menu
	private JMenuItem connectMenuItem = null; 
	
	private JMenuItem loadMenuItem = null; // Load File
	private JMenuItem loadURLMenuItem = null; // Load from URL
	private JMenuItem saveFileMenuItem = null; // Save File As
	private JMenuItem clearAllMenuItem = null; // Clear All
	private JMenuItem exitMenuItem = null; // Exit
	
	/**
	 * The menu item to load filters
	 */
	private JMenuItem loadFiltersMenuItem = null;
	
	/**
	 * The menu item to save the filters
	 */
	private JMenuItem saveFiltersMenuItem = null;
	
	/**
	 * The menu item to show the statistics dialog
	 */
	private JMenuItem statisticsMenuItem = null;
	
	/**
	 * The menu item to save the filters with a new name
	 */
	private JMenuItem saveAsFiltersMenuItem = null;
	
	/**
	 * The menu item to edit the filters
	 */
	private JMenuItem editFiltersMenuItem = null;
	
	/**
	 * The name of the last save/load filter file
	 * (to implement the save as option)
	 */
	private String filterFileName = null;
	
	private JMenuItem fieldsMenuItem = null; // Fields...

	private JMenuItem searchMenuItem; // Search...
    private JMenuItem searchNextMenuItem; // Search Next

	private JMenu fileMenu; // File
	private JMenu viewMenu; // View
    private JMenu searchMenu; // Search

	private JLabel ivjFilterStatus = null; // Not filtered
	private JLabel ivjInfoStatus = null; // Additional info

	private JToggleButton suspendToggleButton = null; // Suspend

	private JMenuBar loggingClientJMenuBar = null;

	private JPanel ivjJPanel1 = null;
	private JPanel ivjJPanel2 = null;
	private JPanel detailedInfoPanel = null;
	
	// The panel with the suspend btn, the filter string...
	// It is immediately under the table of logs
	private JPanel filterStatusPnl = null;

	private JScrollPane statusAreaPanel = null; // The bottom scrolling panel with the status messages
	private JScrollPane ivjJScrollPane2 = null;

	private JSplitPane ivjJSplitPane1 = null;
	private JSplitPane ivjJSplitPane2 = null;

	private JScrollPane scrollLogTable = null;
	private LogEntryTable logEntryTable = null;

	private SmartTextArea ivjStatusArea = null;

	private JPanel ivjJFrameContentPane = null;
    
    /**
     * The toolbar
     */
    private JToolBar toolBar;
    
    /**
     * The menu item to show/hide the toolbar
     */
    private JCheckBoxMenuItem viewToolbarMI;
    
    /**
     * The menu item to show/hide the toolbar
     */
    private JCheckBoxMenuItem autoReconnectMI;
    
    /**
     * The menu item to show/hide the Detailed log info panel
     */
    private JCheckBoxMenuItem viewDetailedInfoMI;
    
    /**
     * The menu item to show/hide the Detailed log info panel
     */
    private JCheckBoxMenuItem viewStatusAreaMI;
    
    /**
     * The menu item to select the format of the date column in the table of logs
     * If it is true, the date appear as hh:mm:ss otherwise it's shown with a complet
     * longest format
     * shortDateViewMI defaults to true
     */
    private JCheckBoxMenuItem shortDateViewMI;
    
    // The ComboBox in the toolbar and its default value (i.e. the log level
    // at startup
    private JComboBox logLevelCB;
    private final int DEFAULT_LOGLEVEL = LogTypeHelper.ENTRYTYPE_INFO;
    
    // The ComboBox with the discard level in the toolbar
    // (the logs with a level lower then what is shown in this ComboBox
    // are discarded when read from the NC)
    private JComboBox discardLevelCB;
    private final int DEFAULT_DISCARDLEVEL = LogTypeHelper.ENTRYTYPE_DEBUG;
    
    // The radio button to enable/disable the scroll lock
    private JToggleButton scrollLockTB;
    
    // The search button in the toolbar
    private JButton searchBtn;
    
    // The progress bar for long time operations
    private JProgressBar progressBar = new JProgressBar(JProgressBar.HORIZONTAL);
    
    /**
     * The search dialog 
     * The object is built the first time the user requests a search
     */
    private SearchDialog searchDialog;

	private EventHandler eventHandler = new EventHandler();

	private boolean ivjConnPtoLCMod = false;

	private com.cosylab.logging.client.DomTree ivjDomTree = null;

	private LCEngine engine = null;
	private LogTableDataModel tableModel = null;
	
	/**
	 * The icons to show the status of the connection
	 * 
	 */
	private final int CONNECTED_ICON =  0;
	private final int CONNECTING_ICON = 1;
	private final int DISCONNECTED_ICON=2;
	private ImageIcon[] connectionStatusIcons; 
	// The label where icon is shown
	private JLabel connectionStatusLbl;

	class EventHandler
		implements
			java.awt.event.ActionListener,
			java.awt.event.WindowListener,
			java.beans.PropertyChangeListener,
			javax.swing.event.MenuListener
	{
		public void actionPerformed(java.awt.event.ActionEvent e)
		{
			if (e.getSource() == LoggingClient.this.getConnectMenuItem()) {
				if (connectMenuItem.getText().compareTo("Connect")==0) {
					connect();
				} else {
					LoggingClient.this.autoReconnectMI.setState(false);
					LoggingClient.this.engine.enableAutoReconnection(false);
					disconnect();
				}
            } else if (e.getSource() == LoggingClient.this.getLoadMenuItem()) {
				getLCModel1().loadFromFile(null);
            } else if (e.getSource() == LoggingClient.this.getLoadURLMenuItem()) {
            	getLCModel1().loadFromURL();
            } else if (e.getSource() == LoggingClient.this.getSaveFileMenuItem()) {
                getLCModel1().saveFile();
            } else if (e.getSource() == LoggingClient.this.getClearAllMenuItem()) {
				getLCModel1().clearAll();
            } else if (e.getSource() == LoggingClient.this.getExitMenuItem()) {
				connExit(e);
            }else if (e.getSource() == LoggingClient.this.getFieldsMenuItem()) {
				connFields(e);
            } else if (e.getSource() == LoggingClient.this.editFiltersMenuItem) {
				editFilters(e);
            } else if (e.getSource() == LoggingClient.this.loadFiltersMenuItem) {
				loadFilters();
            } else if (e.getSource() == LoggingClient.this.saveFiltersMenuItem) {
				if (filterFileName!=null)
					if (filterFileName.length()>0) 
						saveFilters(filterFileName);
			} else if (e.getSource() == LoggingClient.this.saveAsFiltersMenuItem) {
				saveAsFilters();
			} else if (e.getSource()==LoggingClient.this.logLevelCB) {
                setLogLevel(logLevelCB.getSelectedIndex());
            } else if (e.getSource()==LoggingClient.this.searchBtn ||
                    e.getSource()==searchMenuItem) {
                if (searchDialog==null) {
                    searchDialog = new SearchDialog(LoggingClient.this);
                }
                searchDialog.setVisible(true);
            } else if (e.getSource()==LoggingClient.this.searchNextMenuItem) {
                // The searchDialog is always not null otherwise the
                // menu item is disabled but... repetita juvant ;-)
                if (searchDialog!=null) {
                    searchDialog.search();
                } else {
                    searchNextMenuItem.setEnabled(false);
                }
            } else if (e.getSource()==LoggingClient.this.viewToolbarMI) {
                // Hide/Show the toolbar
                toolBar.setVisible(viewToolbarMI.getState());
            } else if (e.getSource()==LoggingClient.this.statisticsMenuItem) {
            	// Show the statistics dialog
            	StatsDlg statsDlg = new StatsDlg(LoggingClient.this); 
            } else if (e.getSource()==LoggingClient.this.viewStatusAreaMI) {
            	getStatusAreaPanel().setVisible(viewStatusAreaMI.getState());
            	if (viewStatusAreaMI.getState()) {
            		getJSplitPane1().setDividerLocation(getHeight() - 150);
            	} else {
            		getJSplitPane1().setDividerLocation(getHeight());
            	}
            } else if (e.getSource()==LoggingClient.this.viewDetailedInfoMI) {
            	getDeatailedInfoPanel().setVisible(viewDetailedInfoMI.getState());
            	if (viewDetailedInfoMI.getState()) {
            		int w = getLogTable().getWidth();
            		getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w/3);
            	} else {
            		getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth());
            	}
            } else if (e.getSource()==LoggingClient.this.autoReconnectMI) {
            	if (LoggingClient.this.engine!=null) {
            		LoggingClient.this.engine.enableAutoReconnection(LoggingClient.this.autoReconnectMI.getState());
            	}
            } else if (e.getSource()==LoggingClient.this.shortDateViewMI) {
            	logEntryTable.setShortDateFormat(LoggingClient.this.shortDateViewMI.getState());
            }
		};

		public void propertyChange(java.beans.PropertyChangeEvent evt)
		{

			if (evt.getSource() == LoggingClient.this.getLogEntryTable() 
					&& (evt.getPropertyName().equals("filterString"))) {
				connFilter(evt);
			} else if (evt.getSource() == LoggingClient.this.getLogEntryTable() 
					&& (evt.getPropertyName().equals("extraInfo"))) {
				showDetailedLogInfo();
			} else if (evt.getSource() == LoggingClient.this.getLogEntryTable() 
					&& (evt.getPropertyName().equals("LCModel"))) {
				connLCMod();
			}
				
		};
		
		public void windowActivated(java.awt.event.WindowEvent e)
		{
		};

		public void windowClosed(java.awt.event.WindowEvent e)
		{
		};

		public void windowClosing(java.awt.event.WindowEvent e)
		{

			if (e.getSource() == LoggingClient.this)
				connLCEngDisconnect(e);
		};

		public void windowDeactivated(java.awt.event.WindowEvent e)
		{
		};

		public void windowDeiconified(java.awt.event.WindowEvent e)
		{
		};

		public void windowIconified(java.awt.event.WindowEvent e)
		{
		};

		public void windowOpened(java.awt.event.WindowEvent e)
		{
		};
		
		
		public void menuCanceled(MenuEvent menuE) {
		};
		
		public void menuSelected(MenuEvent menuE) {
			// Some menus are disabled when loading/saving
			boolean enableMenu = !getLCModel1().IOInProgress();
			clearAllMenuItem.setEnabled(enableMenu);
			if (getEngine().isConnected()) {
				connectMenuItem.setText("Disconnect");
			} else {
				connectMenuItem.setText("Connect");
			}
			connectMenuItem.setEnabled(enableMenu);
			loadMenuItem.setEnabled(enableMenu);
			loadURLMenuItem.setEnabled(enableMenu);
			saveFileMenuItem.setEnabled(enableMenu);
			
			// Check if Save and Save As menu items are selectable
			saveAsFiltersMenuItem.setEnabled(true);
			if (tableModel.getFilters().size()==0) {
				saveFiltersMenuItem.setEnabled(false);
				saveAsFiltersMenuItem.setEnabled(false);
			} else if(filterFileName==null) {
					saveFiltersMenuItem.setEnabled(false);
			} else if (filterFileName.length()==0) {
				saveFiltersMenuItem.setEnabled(false);
			} else {
				saveFiltersMenuItem.setEnabled(true);
			}
			
			// Ensure the status of the item shown in the main panel
			// is consistent with the menuite in View
			viewStatusAreaMI.setSelected(getStatusAreaPanel().isVisible());
			viewDetailedInfoMI.setSelected(getDeatailedInfoPanel().isVisible());
			viewToolbarMI.setSelected(toolBar.isVisible());
		}
		
		public void menuDeselected(MenuEvent menuE) {
		}
	};
	
	/**
	 * The filter to load save filters as xml files
	 * The filter checks for the extension .xml in the name
	 * 
	 * @author acaproni
	 */
	private class xmlFileFilter extends FileFilter {
		public boolean accept(File f) {
			// Check if the name has the extension .xml at the end and is readable
			boolean pass = f.isFile() && f.getName().toUpperCase().endsWith(".XML") && f.canRead();
			// Check if the file is a directory
			pass = pass || f.isDirectory();
			// Check if f is a hidden file
			pass = pass && !f.isHidden();
			return pass; 
		}
		
		public String getDescription() {
			return "xml file";
		}
	}
	
	/**
	 * Build the object in online/offline mode 
	 * 
	 * @param initialConnectionStatus If true jlog connects to the ACS logging system
	 */
	private LoggingClient()
	{
		super();
		initialize();
	}

    /**
	 * Connects to the remote system
	 * as soon as the item "New" is clicked.
	 */
	private void connect()
	{
		try
		{
			getEngine().connect("ACS");
		}
		catch (java.lang.Throwable ivjExc)
		{
			handleException(ivjExc);
		}
	}
	
	private void disconnect() {
		getEngine().disconnect();
	}

    /**
	 * Triggers the Field Choser's dialog visual appearance 
	 * as soon as the item "Fields" is clicked.
	 * @param arg1 java.awt.event.ActionEvent
	 */

	private void connFields(java.awt.event.ActionEvent arg1)
	{
		try
		{

			getLogEntryTable().showFieldChooser();

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}
	
	/**
	 Triggers the Filters dialog visual appearance 
	 * as soon as the item "Filters" is clicked.
	 * @param arg1 java.awt.event.ActionEvent
	 */
	private void editFilters(java.awt.event.ActionEvent arg1)
	{
		try
		{
			getLogEntryTable().showFilterChooser();
		}
		catch (java.lang.Throwable ivjExc)
		{
			handleException(ivjExc);
		}
	}

	/**
	 * Returns the ExitMenuItem property value.
	 * @return javax.swing.JMenuItem
	 */
	private javax.swing.JMenuItem getExitMenuItem()
	{
		if (exitMenuItem == null)
		{
			try
			{
				exitMenuItem = new javax.swing.JMenuItem();
				exitMenuItem.setName("ExitMenuItem");
				exitMenuItem.setText("Exit");

			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return exitMenuItem;
	}
	/**
	 * Returns the SaveFileMenuItem property value.
	 * @return javax.swing.JMenuItem
	 */

	private javax.swing.JMenuItem getSaveFileMenuItem()
	{
		if (saveFileMenuItem == null)
		{
			try
			{
				saveFileMenuItem = new javax.swing.JMenuItem();
				saveFileMenuItem.setName("SaveFileMenuItem");
				saveFileMenuItem.setText("Save File As");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return saveFileMenuItem;
	}

    /**
	 * Returns the ClearAllMenuItem property value.
	 * @return javax.swing.JMenuItem
	 */
	private javax.swing.JMenuItem getClearAllMenuItem()
	{
		if (clearAllMenuItem == null)
		{
			try
			{
				clearAllMenuItem = new javax.swing.JMenuItem();
				clearAllMenuItem.setName("ClearAllMenuItem");
				clearAllMenuItem.setText("Clear All");
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return clearAllMenuItem;
	}

	/**
	 * Returns the JFrameContentPane property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getJFrameContentPane()
	{
		if (ivjJFrameContentPane == null)
		{
			try
			{
				ivjJFrameContentPane = new javax.swing.JPanel();
				ivjJFrameContentPane.setName("JFrameContentPane");
				ivjJFrameContentPane.setLayout(new java.awt.BorderLayout());
				ivjJFrameContentPane.add(getJSplitPane1(), "Center");
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return ivjJFrameContentPane;
	}

	/**
	 * Returns the FiltersMenuItem property value.
	 * @return javax.swing.JMenuItem
	 */
	private javax.swing.JMenu setFiltersMenuItem()
	{
		JMenu filtersMenu = new JMenu("Filters");
		filtersMenu.addMenuListener(eventHandler);
		loadFiltersMenuItem = new JMenuItem("Load");
		filtersMenu.add(loadFiltersMenuItem);
		saveFiltersMenuItem = new JMenuItem("Save");
		filtersMenu.add(saveFiltersMenuItem);
		saveAsFiltersMenuItem = new JMenuItem("Save As...");
		filtersMenu.add(saveAsFiltersMenuItem);
		editFiltersMenuItem = new JMenuItem("Edit...");
		filtersMenu.add(editFiltersMenuItem);
		return filtersMenu; 
	}

	/**
	 * Returns the LoadMenuItem property value.
	 * @return javax.swing.JMenuItem
	 */
	private javax.swing.JMenuItem getLoadMenuItem()
	{
		if (loadMenuItem == null)
		{
			try
			{
				loadMenuItem = new javax.swing.JMenuItem();
				loadMenuItem.setName("ivjLoadMenuItem");
				loadMenuItem.setText("Load from File");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return loadMenuItem;
	}

	private javax.swing.JMenuItem getLoadURLMenuItem()
	{
		if (loadURLMenuItem == null)
		{
			try
			{
				loadURLMenuItem = new javax.swing.JMenuItem();
				loadURLMenuItem.setName("ivjLoadURLMenuItem");
				loadURLMenuItem.setText("Load from URL");

			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return loadURLMenuItem;
	}

	/**
	 * CustomColumnListener implements componentResized() of a ComponentListener. 
	 * It has been added to JScrollPane scrollLogTable to increase the width of 
	 * the Log Message column as soon as the space is available.
	 */
	private class CustomColumnListener implements ComponentListener
	{
		public void componentShown(ComponentEvent evt)
		{
		}

		public void componentHidden(ComponentEvent evt)
		{
		}

		public void componentMoved(ComponentEvent evt)
		{
		}

		// This method is called after the component's size changes
		public void componentResized(ComponentEvent evt)
		{
			// gets the component JTable LogEntryTable that has been changed
			Component c = (Component) evt.getSource();

			// gets the width of JTable LogEntryTable
			// in case a vertical ScrollBar appears the width remains the same
			int tableWidthTobe = c.getSize().width;

			// sets a preferred size to JScrollPane
			getLogEntryTable().setPreferredScrollableViewportSize(new Dimension(tableWidthTobe, c.getSize().height));

			// gets the number of columns in JTable LogEntryTable
			int numCols = getLogEntryTable().getColumnModel().getColumnCount();

			// computes the width of the table taking into consideration all visible columns
			int columnWidth = getLogEntryTable().getColumnWidth(numCols);

			// adds width to the Log Message column
			getLogEntryTable().setAdditionalWidth(numCols, tableWidthTobe - columnWidth);
		}
	}

	/**
	 * Returns the LogTable property value.
	 * @return javax.swing.JScrollPane
	 */

	public javax.swing.JScrollPane getLogTable()
	{
		if (scrollLogTable == null)
		{
			try
			{
				scrollLogTable = new javax.swing.JScrollPane();
				scrollLogTable.setName("LogTable");
				scrollLogTable.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
				scrollLogTable.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
				scrollLogTable.setBackground(new java.awt.Color(204, 204, 204));
				scrollLogTable.setFont(new java.awt.Font("Arial", 1, 12));
				scrollLogTable.setMinimumSize(new java.awt.Dimension(100, 50));
				scrollLogTable.addComponentListener(new CustomColumnListener());
				scrollLogTable.setColumnHeaderView(getLogEntryTable().getTableHeader());
				scrollLogTable.setViewportView(getLogEntryTable());
				scrollLogTable.getViewport().setScrollMode(JViewport.BLIT_SCROLL_MODE);
			}
			catch (java.lang.Throwable ivjExc)
			{
				handleException(ivjExc);
			}
		}
		return scrollLogTable;
	}

	/**
	 * Returns the NewMenuItem property value.
	 * @return javax.swing.JMenuItem
	 */
	private javax.swing.JMenuItem getConnectMenuItem()
	{
		if (connectMenuItem == null)
		{
			try
			{
				connectMenuItem = new javax.swing.JMenuItem();
				connectMenuItem.setName("connectMenuItem");
				connectMenuItem.setText("Connect");
				connectMenuItem.setActionCommand("Connect");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return connectMenuItem;
	}
	
	/**
	 * Returns the ScrollPaneTable property value.
	 * @return com.cosylab.logging.client.LogEntryTable
	 */

	public LogEntryTable getLogEntryTable()
	{
		if (logEntryTable == null)
		{
			try
			{
				logEntryTable = new com.cosylab.logging.LogEntryTable(this,shortDateViewMI.isSelected());
				logEntryTable.setName("ScrollPaneTable");
				logEntryTable.setBounds(0, 0, 200, 200);
			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return logEntryTable;
	}

	/**
	 * Called whenever the part throws an exception.
	 * @param exception java.lang.Throwable
	 */
	private void handleException(java.lang.Throwable exception)
	{

		/* Uncomment the following lines to print uncaught exceptions to stdout */
		System.out.println("--------- UNCAUGHT EXCEPTION ---------");
		exception.printStackTrace(System.out);
	}
	/**
	 * Initializes connections and adds listeners to all the menus and menu items.
	 * @exception java.lang.Exception The exception description.
	 */
	private void initConnections() throws java.lang.Exception
	{
		getConnectMenuItem().addActionListener(eventHandler); // Connect/Disconnect
		getLoadMenuItem().addActionListener(eventHandler); // Load File
		getLoadURLMenuItem().addActionListener(eventHandler); // Load URL
		getSaveFileMenuItem().addActionListener(eventHandler); // Save File As
		getClearAllMenuItem().addActionListener(eventHandler); // ClearAll
		getExitMenuItem().addActionListener(eventHandler); // Exit

		getFieldsMenuItem().addActionListener(eventHandler); // Fields
		editFiltersMenuItem.addActionListener(eventHandler); // Edit Filters
		loadFiltersMenuItem.addActionListener(eventHandler); // Load Filters
		saveFiltersMenuItem.addActionListener(eventHandler); // Save Filters
		saveAsFiltersMenuItem.addActionListener(eventHandler); // Save Filters
		getLogEntryTable().addPropertyChangeListener(eventHandler); // ScrollPaneTable		
		this.addWindowListener(eventHandler); // Logging Client

		connLCMod();
	}
    
    /**
     * Builds the menu bar
     */
    private void setupMenuBar() {
        // Build the menu barr
        loggingClientJMenuBar = new javax.swing.JMenuBar();
        loggingClientJMenuBar.setName("LoggingClientJMenuBar");
        
        // Add the File menu
        fileMenu = new javax.swing.JMenu();
        fileMenu.setName("FileMenu");
        fileMenu.setText("File");
        fileMenu.addMenuListener(eventHandler);
        fileMenu.add(getConnectMenuItem());
        autoReconnectMI = new JCheckBoxMenuItem("Auto reconnect",false);
        autoReconnectMI.addActionListener(eventHandler);
        fileMenu.add(autoReconnectMI);
        fileMenu.addSeparator();
        fileMenu.add(getLoadMenuItem());
        fileMenu.add(getLoadURLMenuItem());
        fileMenu.add(getSaveFileMenuItem());
        fileMenu.add(getClearAllMenuItem());
        fileMenu.addSeparator();
        fileMenu.add(getExitMenuItem());
        loggingClientJMenuBar.add(fileMenu);
        
        // Add the View Menu
        viewMenu = new javax.swing.JMenu();
        viewMenu.setName("ViewMenu");
        viewMenu.setText("View");
        viewMenu.addMenuListener(eventHandler);
        viewToolbarMI = new JCheckBoxMenuItem("Toolbar",true);
        viewToolbarMI.addActionListener(eventHandler);
        viewMenu.add(viewToolbarMI);
        viewDetailedInfoMI = new JCheckBoxMenuItem("Detailed log info",true);
        viewDetailedInfoMI.addActionListener(eventHandler);
        viewMenu.add(viewDetailedInfoMI);
        viewStatusAreaMI = new JCheckBoxMenuItem("Status area",true);
        viewStatusAreaMI.addActionListener(eventHandler);
        viewMenu.add(viewStatusAreaMI);
        viewMenu.addSeparator();
        viewMenu.add(getFieldsMenuItem());
        shortDateViewMI = new JCheckBoxMenuItem("Short date format",true);
        shortDateViewMI.addActionListener(eventHandler);
        viewMenu.add(shortDateViewMI);
        viewMenu.addSeparator();
        viewMenu.add(setFiltersMenuItem());
        viewMenu.addSeparator();
        statisticsMenuItem = new JMenuItem("Statistics");
        statisticsMenuItem.addActionListener(eventHandler);
        viewMenu.add(statisticsMenuItem);
        loggingClientJMenuBar.add(viewMenu);
        
        // Add the Search Menu
        searchMenu = new javax.swing.JMenu();
        searchMenu.setName("SearchMenu");
        searchMenu.setText("Search");
        searchMenu.addMenuListener(eventHandler);
        searchMenuItem = new JMenuItem("Search...");
        searchMenuItem.addActionListener(eventHandler);
        searchMenuItem.setAccelerator(KeyStroke.getKeyStroke('S',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
        searchMenu.add(searchMenuItem);
        searchNextMenuItem = new JMenuItem("Search Next");
        searchNextMenuItem.setAccelerator(KeyStroke.getKeyStroke('N',Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
        searchNextMenuItem.addActionListener(eventHandler);
        searchNextMenuItem.setEnabled(false);
        searchMenu.add(searchNextMenuItem);
        loggingClientJMenuBar.add(searchMenu);
    }
    
    /** 
     * Builds the toolbar
     */
    private void setupToolBar() {
        toolBar=new JToolBar();
        toolBar.setFloatable(false);
        
        // The panel for the toolbar
        JPanel toolBarPanel = new JPanel();
        toolBarPanel.setLayout(new BorderLayout());
        
        // userPanel conatins the Panel with buttons, combo boxes and so on
        JPanel userPanel = new JPanel();
        FlowLayout tbFlowL = new FlowLayout(FlowLayout.LEFT);
        tbFlowL.setHgap(10);
        userPanel.setLayout(tbFlowL);
        
        // Add the label for the log level
        FlowLayout lyLevel = new FlowLayout();
        lyLevel.setHgap(2);
        JPanel tbLevelPanel = new JPanel(lyLevel);
        JLabel logLevelLbl = new JLabel("<HTML><FONT size=-2>Log level: </FONT></HTML>");
        tbLevelPanel.add(logLevelLbl);
        
        // Add the ComboBox for the log level
        logLevelCB = new JComboBox(LogTypeHelper.getAllTypesDescriptions());
        
        // Build the renderer for the combo boxex
        LogTypeRenderer rendererCB = new LogTypeRenderer();
        
        logLevelCB.setSelectedIndex(DEFAULT_LOGLEVEL);
        setLogLevel(DEFAULT_LOGLEVEL);
        logLevelCB.setEditable(false);
        logLevelCB.setMaximumRowCount(LogTypeHelper.getNumberOfTypes());
        logLevelCB.setRenderer(rendererCB);
        logLevelCB.addActionListener(eventHandler);
        tbLevelPanel.add(logLevelCB);
        
        JLabel discardLevelLbl = new JLabel("<HTML><FONT size=-2>Discard level: </FONT></HTML>");
        tbLevelPanel.add(discardLevelLbl);
        // Add the ComboBox for the log level
        LogTypeRenderer discardRendererCB = new LogTypeRenderer();
        String[] discardLevelStr = new String[LogTypeHelper.getAllTypesDescriptions().length+1];
        discardLevelStr[0] = "None";
        for (int t=0; t<LogTypeHelper.getAllTypesDescriptions().length; t++) {
        	discardLevelStr[t+1]=LogTypeHelper.getAllTypesDescriptions()[t];
        }
        discardLevelCB = new JComboBox(discardLevelStr);
        discardLevelCB.setMaximumRowCount(discardLevelStr.length);
        discardLevelCB.setSelectedIndex(DEFAULT_DISCARDLEVEL+1);
        discardLevelCB.setEditable(false);
        discardLevelCB.setRenderer(discardRendererCB);
        discardLevelCB.addActionListener(eventHandler);
        tbLevelPanel.add(discardLevelCB);
        
        scrollLockTB = new JToggleButton("Scroll lock");
        scrollLockTB.setSelected(false);
        //tbLevelPanel.add(scrollLockTB);
        
        
        userPanel.add(tbLevelPanel);
        
        // Add the  search button
        ImageIcon searchIcon=new ImageIcon(LogTypeHelper.class.getResource("/search.gif"));
        searchBtn = new JButton("<HTML><FONT size=-2>Search...</FONT></HTML>",searchIcon);
        userPanel.add(searchBtn);
        searchBtn.addActionListener(eventHandler);
        
    
        
        toolBarPanel.add(userPanel,BorderLayout.WEST);
        
        
        toolBar.add(toolBarPanel);
    }

	/**
	 * Initializes the object.
	 */
	private void initialize()
	{
		try
		{
			setName("LoggingClient");
			setTitle("LoggingClient");
			setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
            setupMenuBar();
			setJMenuBar(loggingClientJMenuBar);
            
            setSize(750, 550);
            // Move the window to the center of the screen 
            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
            Dimension windowSize = getSize();
            setLocation(Math.max(0,(screenSize.width -windowSize.width)/2), 
            Math.max(0,(screenSize.height-windowSize.height)/2));
            
            // Create a panel for the toolbar (NORTH position)
            // and the other stuffs like the table (CENTER position)
            JPanel toolBarPanel = new JPanel();
            toolBarPanel.setLayout(new BorderLayout());
            
            // Add the GUI in the center position
            toolBarPanel.add(getJFrameContentPane(),BorderLayout.CENTER);
            
            // Set the content pane
			setContentPane(toolBarPanel);
            
			initConnections();
			validate();
            
			// Create and setup the toolbar
            setupToolBar();
            
            // Add the tool bar
            toolBarPanel.add(toolBar,BorderLayout.NORTH);
		}
		catch (java.lang.Throwable ivjExc)
		{
			handleException(ivjExc);
		}

		// java 1.2.2. bugfix
		getJSplitPane2().setDividerLocation(getJSplitPane2().getLastDividerLocation());
		getJSplitPane1().setDividerLocation(getHeight() - 150);
		// user code end

	}
	
	/**
	 * Return the LoggingClient: it is a singleton
	 * This method creates the object that is not connected to
	 * the CORBA notification channel (connect must be called)
	 * 
	 * @return The LoggingClient
	 */
	public static LoggingClient getInstance() {
		if (singleton == null) {
			singleton = new LoggingClient();
		}
		return singleton;
	}
	
	/**
	 * Print the standard usage message if the parameters in the command
	 * line are wrong.
	 *
	 * @param errorMsg An optional error message to print
	 */
	private static void printUsage(String errorMsg) {
		if (errorMsg!=null) {
			System.out.println("Wrong parameters: "+errorMsg);
		}
		System.out.println("USAGE:");
		System.out.println("jlog [logFileName] [(-f|--filter) filterFileName]\n");
	}

	/**
	 * Starts the application.
	 * @param args an array of command-line arguments
	 */
	public static void main(java.lang.String[] args)
	{
		// First check if there are parameter in the command line
		
		// If it is null then the user specified a file name in the
		// command line
		String initLogFileName = null;
		// If it is null then the user specified a filter file name in the
		// command line
		String initFilterFileName = null;
		
		if (args.length>3) {
			// Wrong number of params
			printUsage("cmd line too long");
			System.exit(-1);
		} else if (args.length>0) {
			// Retrieve the params
			for (int t=0; t<args.length; t++) {
				if (args[t].compareTo("-f")==0 || args[t].compareTo("--filter")==0) {
					t++;
					if (t<args.length) {
						initFilterFileName=args[t];
					} else if (initFilterFileName!=null) {
						// A filter file was already defined
						printUsage("Two filter file names in cmd line");
						System.exit(-1);
					} else {
						// -f was the last param in the cmd
						printUsage("No filter file name after "+args[t-1]);
						System.exit(-1);
					}
				} else {
					if (initLogFileName==null) {
						initLogFileName=args[t];
					} else {
						// A log file was already found!
						printUsage("Two log file names in cmd line");
						System.exit(-1);
					}
				}
			}
		}
		
		File logFile = null;
		if (initLogFileName!=null) {
			// Check if the file in the cmd line is readable
			logFile = new File(initLogFileName);
			if (!logFile.canRead()) {
				System.err.println(initLogFileName+" is unreadable!");
				System.exit(-1);
			}
		}
		
		File filterFile = null;
		if (initFilterFileName!=null) {
			filterFile = new File(initFilterFileName);
			if (!filterFile.canRead()) {
				System.err.println(initFilterFileName+" is unreadable!");
				System.exit(-1);
			}
		}
		
		try
		{
			/* Set native look and feel */
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
			/* Create the frame */
			LoggingClient aLoggingClient;
			aLoggingClient = getInstance(); // build the singleton
			aLoggingClient.setVisible(true);
			
			// Load the filters (if any)
			if (filterFile!=null) {
				aLoggingClient.getLCModel1().getFilters().loadFilters(filterFile,true,null);
			}
			// If there is no file name in the command line then connect
			// the client to the CORBA notification channel
			if (logFile==null) {
				aLoggingClient.connect();
			} else {
				aLoggingClient.getLCModel1().loadFromFile(initLogFileName);
			}
		}
		catch (Throwable exception)
		{
			System.err.println("Exception occurred in main() of LoggingClient");
			exception.printStackTrace(System.out);
		}
	}

	/**
	 * Exits by calling the LCEngine.
	 * @param arg1 java.awt.event.ActionEvent
	 */

	private void connExit(java.awt.event.ActionEvent arg1)
	{
		try
		{

			getEngine().exit();

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}
	
	/**
	 * Adds filtering.
	 * @param arg1 java.beans.PropertyChangeEvent
	 */

	private void connFilter(java.beans.PropertyChangeEvent arg1)
	{
		try
		{

			getFilterStatus().setText(String.valueOf(getLogEntryTable().getFilterString()));

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}

	/**
	 * Show a detailed view of the selected log in the right panel
	 */
	public void showDetailedLogInfo()
	{
		try {
			LogEntryTable jt = getLogEntryTable();
			//getDomTree().setRootNode(jt.getExtraInfo());
			int selectedRow = jt.getSelectedRow();
			// Check whether a row has been selected
			// no row selected
			if (selectedRow == -1) {
				getJScrollPane2().setViewportView(getDomTree());
			} else {
				// a row is selected
				ILogEntry log = jt.getLCModel().getVisibleLogEntry(selectedRow);
				getJScrollPane2().setViewportView(getDataTable(log));
			}
		} catch (java.lang.Throwable ivjExc) {
			handleException(ivjExc);
		}
	}
	
	/**
	 * Returns a table that displays all the data elements for a selected table row.
	 * @param log The log entry which datas are to be shown
	 * @return The component that displays the datas
	 */
	public Component getDataTable(ILogEntry log)
	{
		DetailedLogTable table = null;
		// Try to build a DetailedLogTable
		try {
			table = new DetailedLogTable(log);
		} catch (Exception e) {
			e.printStackTrace();
			// DetailedLogTable returns an error if there are no datas in the log entry
			// In this case we return a DomTree
			return getDomTree();
		}
		return (Component)table;
	}

	/**
	 * Disconnects the LCEngine.
	 * @param arg1 java.awt.event.WindowEvent
	 */

	private void connLCEngDisconnect(java.awt.event.WindowEvent arg1)
	{
		try
		{

			getEngine().disconnect();

		}
		catch (java.lang.Throwable ivjExc)
		{

			handleException(ivjExc);
		}
	}

	/**
	 * Sets the LCModel.
	 */

	private void connLCMod()
	{
		/* Set the target from the source */
		try
		{
			if (ivjConnPtoLCMod == false)
			{

				ivjConnPtoLCMod = true;
				setLCModel1(getLogEntryTable().getLCModel());

				ivjConnPtoLCMod = false;
			}
		}
		catch (java.lang.Throwable ivjExc)
		{
			ivjConnPtoLCMod = false;

			handleException(ivjExc);
		}
	}
	/**
	 * Returns the DomTree property value.
	 * @return com.cosylab.logging.client.DomTree
	 */

	public com.cosylab.logging.client.DomTree getDomTree()
	{
		if (ivjDomTree == null)
		{
			try
			{
				ivjDomTree = new com.cosylab.logging.client.DomTree();
				ivjDomTree.setName("DomTree");
				ivjDomTree.setBounds(0, 0, 107, 310);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjDomTree;
	}
	/**
	 * Returns the FilterStatus property value.
	 * @return javax.swing.JLabel
	 */
	/* WARNING: THIS METHOD WILL BE REGENERATED. */
	private javax.swing.JLabel getFilterStatus()
	{
		if (ivjFilterStatus == null)
		{
			try
			{
				ivjFilterStatus = new javax.swing.JLabel();
				ivjFilterStatus.setName("FilterStatus");
				ivjFilterStatus.setText("Not filtered");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjFilterStatus;
	}
	/**
	 * Returns the groupMenu1 property value.
	 * @return javax.swing.JMenu
	 */

	/**
	 * Returns the JLabel1 property value.
	 * @return javax.swing.JLabel
	 */

	private javax.swing.JLabel getInfoStatus()
	{
		if (ivjInfoStatus == null)
		{
			try
			{
				ivjInfoStatus = new javax.swing.JLabel();
				ivjInfoStatus.setName("InfoStatus");
				ivjInfoStatus.setText("Detailed info");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjInfoStatus;
	}
	/**
	 * Returns the JMenuItem6 property value.
	 * @return javax.swing.JMenuItem
	 */

	private javax.swing.JMenuItem getFieldsMenuItem()
	{
		if (fieldsMenuItem == null)
		{
			try
			{
				fieldsMenuItem = new javax.swing.JMenuItem();
				fieldsMenuItem.setName("FieldsMenuItem");
				fieldsMenuItem.setText("Fields...");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return fieldsMenuItem;
	}

	/**
	 * Returns the JPanel1 property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getJPanel1()
	{
		if (ivjJPanel1 == null)
		{
			try
			{
				ivjJPanel1 = new javax.swing.JPanel();
				ivjJPanel1.setName("JPanel1");
				ivjJPanel1.setLayout(new java.awt.GridBagLayout());

				java.awt.GridBagConstraints constraintsLogTable = new java.awt.GridBagConstraints();
				constraintsLogTable.gridx = 0;
				constraintsLogTable.gridy = 0;
				constraintsLogTable.fill = java.awt.GridBagConstraints.BOTH;
				constraintsLogTable.weightx = 1.0;
				constraintsLogTable.weighty = 1.0;
				ivjJPanel1.add(getLogTable(), constraintsLogTable);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJPanel1;
	}

	/**
	 * Returns the JPanel2 property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getJPanel2()
	{
		if (ivjJPanel2 == null)
		{
			try
			{
				ivjJPanel2 = new javax.swing.JPanel();
				ivjJPanel2.setName("JPanel2");
				ivjJPanel2.setLayout(new java.awt.BorderLayout());
				ivjJPanel2.add(getFilterStatusPnl(), "South");
				ivjJPanel2.add(getJSplitPane2(), "Center");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJPanel2;
	}
	/**
	 * Returns the JPanel3 property value.
	 * @return javax.swing.JPanel
	 */
	private javax.swing.JPanel getDeatailedInfoPanel()
	{
		if (detailedInfoPanel == null)
		{
			try
			{
				detailedInfoPanel = new javax.swing.JPanel();
				detailedInfoPanel.setName("JPanel3");
				detailedInfoPanel.setLayout(new java.awt.GridBagLayout());

				java.awt.GridBagConstraints constraintsJLabel1 = new java.awt.GridBagConstraints();
				constraintsJLabel1.gridx = 0;
				constraintsJLabel1.gridy = 0;
				constraintsJLabel1.anchor = java.awt.GridBagConstraints.WEST;
				constraintsJLabel1.insets = new java.awt.Insets(4, 4, 4, 4);
				detailedInfoPanel.add(getInfoStatus(), constraintsJLabel1);

				java.awt.GridBagConstraints constraintsJScrollPane2 = new java.awt.GridBagConstraints();
				constraintsJScrollPane2.gridx = 0;
				constraintsJScrollPane2.gridy = 1;
				constraintsJScrollPane2.fill = java.awt.GridBagConstraints.BOTH;
				constraintsJScrollPane2.weightx = 1.0;
				constraintsJScrollPane2.weighty = 1.0;
				detailedInfoPanel.add(getJScrollPane2(), constraintsJScrollPane2);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return detailedInfoPanel;
	}
	/**
	 * Returns the JPanel4 property value.
	 * @return javax.swing.JPanel
	 */
	private JPanel getFilterStatusPnl()
	{
		if (filterStatusPnl == null)
		{
			try
			{
				// Lad the icons for the status of the connection
				connectionStatusIcons = new ImageIcon[3];
				connectionStatusIcons[CONNECTED_ICON]=new ImageIcon(this.getClass().getResource("/console-connected.png"));
				connectionStatusIcons[CONNECTING_ICON]=new ImageIcon(this.getClass().getResource("/console-connecting.png"));
				connectionStatusIcons[DISCONNECTED_ICON]=new ImageIcon(this.getClass().getResource("/console-disconnected.png"));
				System.out.println("Image info "+connectionStatusIcons[CONNECTED_ICON].getIconHeight()+","+connectionStatusIcons[CONNECTED_ICON].getIconWidth());
				connectionStatusLbl = new JLabel(connectionStatusIcons[CONNECTING_ICON]);
				
				filterStatusPnl = new javax.swing.JPanel();
				filterStatusPnl.setName("JPanel4");
				filterStatusPnl.setLayout(new java.awt.GridBagLayout());
				
				GridBagConstraints constraintsFilterStatus = new GridBagConstraints();
				constraintsFilterStatus.gridx = 0;
				constraintsFilterStatus.gridy = 0;
				constraintsFilterStatus.fill = GridBagConstraints.BOTH;
				constraintsFilterStatus.anchor = GridBagConstraints.WEST;
				constraintsFilterStatus.weightx = 1.0;
				constraintsFilterStatus.insets = new Insets(1, 2, 1, 1);
				filterStatusPnl.add(getFilterStatus(), constraintsFilterStatus);

				GridBagConstraints constraintsProgressBar = new GridBagConstraints();
		        constraintsProgressBar.gridx=1;
		        constraintsProgressBar.gridy=0;
		        constraintsProgressBar.insets = new Insets(1,1,1,1);
		        progressBar.setVisible(false);
		        filterStatusPnl.add(progressBar,constraintsProgressBar);
				
				GridBagConstraints constraintsJToggleButton = new GridBagConstraints();
				constraintsJToggleButton.gridx = 2;
				constraintsJToggleButton.gridy = 0;
				constraintsJToggleButton.insets = new Insets(4, 4, 4, 4);
				filterStatusPnl.add(getSuspendToggleBtn(), constraintsJToggleButton);
				
				GridBagConstraints constraintsConnectionStatus = new GridBagConstraints();
				constraintsConnectionStatus.gridx = 3;
				constraintsConnectionStatus.gridy = 0;
				constraintsConnectionStatus.insets = new Insets(1, 2, 1, 2);
				filterStatusPnl.add(connectionStatusLbl,constraintsConnectionStatus);
			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return filterStatusPnl;
	}

	/**
	 * Returns the JScrollPane1 property value.
	 * @return javax.swing.JScrollPane
	 */
	private javax.swing.JScrollPane getStatusAreaPanel()
	{
		if (statusAreaPanel == null)
		{
			try
			{
				statusAreaPanel = new javax.swing.JScrollPane();
				statusAreaPanel.setName("JScrollPane1");
				statusAreaPanel.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
				statusAreaPanel.setPreferredSize(new java.awt.Dimension(50, 50));
				statusAreaPanel.setMinimumSize(new java.awt.Dimension(50, 50));
				statusAreaPanel.setViewportView(getStatusArea());

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return statusAreaPanel;
	}
	/**
	 * Returns the JScrollPane2 property value.
	 * @return javax.swing.JScrollPane
	 */
	public javax.swing.JScrollPane getJScrollPane2()
	{
		if (ivjJScrollPane2 == null)
		{
			try
			{
				ivjJScrollPane2 = new javax.swing.JScrollPane();
				ivjJScrollPane2.setName("JScrollPane2");
				ivjJScrollPane2.setViewportView(getDomTree());

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJScrollPane2;
	}
	/**
	 * Returns the JSplitPane1 property value.
	 * @return javax.swing.JSplitPane
	 */
	private javax.swing.JSplitPane getJSplitPane1()
	{
		if (ivjJSplitPane1 == null)
		{
			try
			{
				ivjJSplitPane1 = new javax.swing.JSplitPane(javax.swing.JSplitPane.VERTICAL_SPLIT);
				ivjJSplitPane1.setName("JSplitPane1");
				ivjJSplitPane1.setLastDividerLocation(350);
				ivjJSplitPane1.setDividerLocation(350);
				ivjJSplitPane1.add(getStatusAreaPanel(), "bottom");
				ivjJSplitPane1.add(getJPanel2(), "top");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJSplitPane1;
	}
	/**
	 * Returns the JSplitPane2 property value.
	 * @return javax.swing.JSplitPane
	 */

	private javax.swing.JSplitPane getJSplitPane2()
	{
		if (ivjJSplitPane2 == null)
		{
			try
			{
				ivjJSplitPane2 = new javax.swing.JSplitPane(javax.swing.JSplitPane.HORIZONTAL_SPLIT);
				ivjJSplitPane2.setName("JSplitPane2");
				ivjJSplitPane2.setLastDividerLocation(570);
				ivjJSplitPane2.setAlignmentX(java.awt.Component.LEFT_ALIGNMENT);
				ivjJSplitPane2.setContinuousLayout(true);
				//ivjJSplitPane2.setDividerLocation(501);
				ivjJSplitPane2.add(getJPanel1(), "left");
				ivjJSplitPane2.add(getDeatailedInfoPanel(), "right");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjJSplitPane2;
	}
	/**
	 * Returns the JToggleButton1 property value.
	 * @return javax.swing.JToggleButton
	 */

	private JToggleButton getSuspendToggleBtn()
	{
		if (suspendToggleButton == null)
		{
			try
			{
				suspendToggleButton = new javax.swing.JToggleButton();
				suspendToggleButton.setName("JToggleButton1");
				suspendToggleButton.setText("Suspend");

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return suspendToggleButton;
	}
	
	/**
	 * Returns the LCEngine property value.
	 * @return com.cosylab.logging.LCEngine
	 */
	public LCEngine getEngine()
	{
		if (engine == null)
		{
			try
			{
				engine = new LCEngine(this);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return engine;
	}
	
	/**
	 * Returns the LCModel1 property value.
	 * @return com.cosylab.logging.LogTableDataModel
	 */
	public LogTableDataModel getLCModel1()
	{

		return tableModel;
	}

	/**
	 * Returns the StatusArea property value.
	 * @return com.cosylab.gui.components.SmartTextArea
	 */
	private SmartTextArea getStatusArea()
	{
		if (ivjStatusArea == null)
		{
			try
			{
				ivjStatusArea = new SmartTextArea();
				ivjStatusArea.setName("StatusArea");
				ivjStatusArea.setLocation(0, 0);

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		}
		return ivjStatusArea;
	}
	/**
	 * Sets the height and width generated by user's actions.
	 */
	public void loggingClient_ComponentResized(java.awt.event.ComponentEvent e)
	{
		if (e.getComponent() == this)
		{
			int w = getLogTable().getWidth();
			int h = getLogTable().getHeight();
			System.out.println(w + ", " + h);
			System.out.println(getJSplitPane2().getWidth());
			System.out.println(getJSplitPane1().getHeight());

			getJSplitPane2().setDividerLocation(getJSplitPane2().getWidth() - w);
			getJSplitPane1().setDividerLocation(getJSplitPane1().getHeight() - h);
		}
	}

	/**
	 * Sets the LCModel1 to a new value.
	 * @param newValue com.cosylab.logging.LogTableDataModel
	 */
	private void setLCModel1(LogTableDataModel newValue)
	{
		if (tableModel != newValue)
		{
			try
			{
				tableModel = newValue;

			}
			catch (java.lang.Throwable ivjExc)
			{

				handleException(ivjExc);
			}
		};

	}
	
	/**
	 * Save the filters in a new XML file
	 *
	 */
	private void saveAsFilters() {
		// Check if there are filters in use
		if (tableModel.getFilters().size()==0) {
			JOptionPane.showMessageDialog(this,"No filters to save","Warning",JOptionPane.INFORMATION_MESSAGE);
			return;
		}
		// Show the dialog to choose the file to save
		JFileChooser fileChooserDlg = new JFileChooser();
		fileChooserDlg.setMultiSelectionEnabled(false);
		fileChooserDlg.setDialogTitle("Save filters");
		xmlFileFilter fileFilter= new xmlFileFilter();
		fileChooserDlg.setFileFilter(fileFilter);
		if (fileChooserDlg.showSaveDialog(this)==JFileChooser.APPROVE_OPTION) {
			// Get the selected file
			File fileToSave = fileChooserDlg.getSelectedFile();
			if (!fileToSave.getAbsolutePath().toUpperCase().endsWith(".XML")) {
				fileToSave = new File(fileToSave.getAbsolutePath()+".xml");
			}
			if (fileToSave!=null) {
				try {
					tableModel.getFilters().saveFilters(fileToSave);
					filterFileName=fileToSave.getAbsolutePath();
					System.out.println("Saved "+filterFileName);
				} catch (IOException e) {
					System.err.println("Exception: "+e.toString());
				}
			}
		}
	}

	/**
	 * Save the filters to a XML files with a given name
	 * It create the File object then call overloaded method
	 * 
	 *@param fileName The name of the xml file
	 */
	private void saveFilters(String fileName) {
		// Check if the name terminate with xml
		if (!fileName.toUpperCase().endsWith(".XML")) {
			fileName=fileName+".xml";
		}
		File f = new File(fileName);
		try {
			tableModel.getFilters().saveFilters(f);
			filterFileName=f.getAbsolutePath();
			System.out.println("Saved "+filterFileName);
		} catch (IOException e) {
			System.err.println("Error opening "+fileName);
		}
	}
	
	/**
	 * Load filters from a XML file
	 * The user choose if the loaded filters substitutes the existing ones
	 * or merges with them
	 */
	private void loadFilters() {
		boolean eraseOldFilters;
		// Check if already exists filters
		if (tableModel.getFilters().size()>0) {
			int ret=JOptionPane.showConfirmDialog(
					(Component)this,
					"Do you want do discard existing filters?",
					"Merge filters?",
					JOptionPane.YES_NO_CANCEL_OPTION);
			if (ret==JOptionPane.CANCEL_OPTION) {
				return;
			} else {
				eraseOldFilters=(ret==JOptionPane.YES_OPTION);
			}
		} else {
			eraseOldFilters = false; // We have no filters so.. nothing to delete ;-) 
		}
		
		// Show the dialog to choose the file to load
		JFileChooser fileChooserDlg = new JFileChooser();
		fileChooserDlg.setMultiSelectionEnabled(false);
		fileChooserDlg.setDialogTitle("Load filters");
		xmlFileFilter fileFilter= new xmlFileFilter();
		fileChooserDlg.setFileFilter(fileFilter);
		if (fileChooserDlg.showOpenDialog(this)==JFileChooser.APPROVE_OPTION) {
			// Load filters from file
			File fileToLoad=fileChooserDlg.getSelectedFile();
			if (fileToLoad!=null) {
				tableModel.getFilters().loadFilters(fileToLoad,eraseOldFilters,null);
				//tableModel.setMaxHistory(history);
				tableModel.invalidateVisibleLogs();
				filterFileName=fileToLoad.getAbsolutePath();
			}
		}
	}

    /** Change the system filter to set the log level to the value the
     * user selected in the Combobox 
     * 
     * @param level The level requested
     */
    private void setLogLevel(int level) {
        // Get the system filters
        FiltersVector filters = getLCModel1().getSystemFilters();
        for (int t=0; t<filters.size(); t++) {
            Filter f = filters.get(t);
            if (f.getField()==ILogEntry.FIELD_ENTRYTYPE) {
                // We have found the LogLevel filter: we remove it in order to
                // replace with the new filter
                filters.remove(t);
            } 
        }
        // Build the new filter
        try {
            Filter levelFilter =
                new Filter(
                		ILogEntry.FIELD_ENTRYTYPE,
                		false,
                		new Integer(level),
                		new Integer(LogTypeHelper.ENTRYTYPE_EMERGENCY),
                		false);
            filters.addFilter(levelFilter,true);
        } catch (Exception e) {
            System.err.println("Error creating the log level filter:"+e.getMessage());
            e.printStackTrace();
            JOptionPane.showMessageDialog(null,"Error creating the log level filter!","LoggingClient error",JOptionPane.ERROR_MESSAGE);
            // We have no log level so we set the combo box
            // to trace
            logLevelCB.setSelectedIndex(0);
        }
        // Invalidate the logs (the changes will appear in the GUI)
        tableModel.invalidateVisibleLogs();
    }
    
	
    /**
     * Enable or disable the Search next menu item
     * (tipically this action is preformed by the SearchDialog when a valid search
     * is performed)
     * 
     * @param enable true enable the searchNextMenuItem
     */
    public void enableSearchNext(boolean enable) {
        this.searchNextMenuItem.setEnabled(enable);
    }
    
    /**
     * Show the progres bar as determinate with the given min and max
     * 
     * @param textThe text to show in the toolbar
     *            If it is null or empty then no text will be displayed
     * @param min The starting position
     * @param max The final position
     */
    public void animateProgressBar(String text, int min, int max) {
    	if (progressBar.isVisible()) {
    		throw new IllegalStateException("Exception trying to set the Progress Bar");
    	}
    	if (min>=max) {
    		throw new IllegalArgumentException("Invalid range: ["+min+","+max+"]");
    	}
    	Cursor hourglassCursor = new Cursor(Cursor.WAIT_CURSOR);
    	setCursor(hourglassCursor);
    	if (text!=null && text.length()>0) {
    			progressBar.setString(text);
    			progressBar.setStringPainted(true);
    			progressBar.setToolTipText(text);
    	} else {
    		progressBar.setStringPainted(false);
    		progressBar.setToolTipText("Wait please");
    	}
    	progressBar.setMinimum(min);
    	progressBar.setMaximum(max);
    	progressBar.setIndeterminate(false);
    	progressBar.setVisible(true);
    }
    
    /**
     * Move the progressbar when in determinate mode
     * @param newPos
     */
    public void moveProgressBar(int newPos) {
    	progressBar.setValue(newPos);
    }
    
    /**
     * Show the progress bar as indeterminate
     * 
     *@param text The text to show in the toolbar
     *            If it is null or empty then no text will be displayed
     */
    public void animateProgressBar(String text) {
    	if (progressBar.isVisible()) {
    		throw new IllegalStateException("Exception trying to set the Progress Bar");
    	}
    	Cursor hourglassCursor = new Cursor(Cursor.WAIT_CURSOR);
    	setCursor(hourglassCursor);
    	if (text!=null && text.length()>0) {
    			progressBar.setString(text);
    			progressBar.setStringPainted(true);
    			progressBar.setToolTipText(text);
    	} else {
    		progressBar.setStringPainted(false);
    		progressBar.setToolTipText("Wait please");
    	}
    	progressBar.setIndeterminate(true);
    	progressBar.setVisible(true);
    }
    
    /**
     * Hide the progress bar (i.e. a long operation
     * has terminated)
     */
    public void freezeProgressBar() {
    	progressBar.setIndeterminate(false);
    	progressBar.setMinimum(0);
    	progressBar.setMaximum(100);
    	progressBar.setValue(0);
    	progressBar.setStringPainted(false);
    	progressBar.setToolTipText(null);
    	progressBar.setVisible(false);
    	Cursor normalCursor = new Cursor(Cursor.DEFAULT_CURSOR);
    	setCursor(normalCursor);
    }
    
    /**
     * @return true if the application is connected to the notification channel
     *
     */
    public boolean isConnected() {
    	return getEngine().isConnected();
    }
    
    /**
     * 
     * @return true if the scrool lock is enabled
     */
    public boolean scrollLock() {
    	return scrollLockTB.isSelected();
    }
    
    /**
     * 
     * @return The discard log level
     * @see LoggingClient.discardLevelCB
     */
    public int getDiscardLevel() {
    	return discardLevelCB.getSelectedIndex();
    }
    
    /**
     * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
     */
    public void logEntryReceived(ILogEntry logEntry) {
    	int logLevel = ((Integer)logEntry.getField(ILogEntry.FIELD_ENTRYTYPE)).intValue();
    	if (!suspendToggleButton.isSelected() && logLevel>=discardLevelCB.getSelectedIndex()) {
			getLogEntryTable().getLCModel().appendLog(logEntry);
		} 
    	
    }
    
    /**
     * 
     * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
     */
    public void reportStatus(String status) {
    	getStatusArea().append(status+"\n");
    }
    
   /**
    * Notify that the connection with ACS NC has been established
    * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnEstablished() {
		setTitle("LoggingClient");
		connectionStatusLbl.setIcon(connectionStatusIcons[CONNECTED_ICON]);
		connectionStatusLbl.setToolTipText("Connected");
	}
	
	/**
     * 
     * @see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
     */
	public void acsLogConnDisconnected() {
		setTitle("LoggingClient - Offline");
		connectionStatusLbl.setIcon(connectionStatusIcons[DISCONNECTED_ICON]);
		connectionStatusLbl.setToolTipText("Disconnected");
	}
	
	/**
	 * Notify that the connection with ACS NC has been lost
	 *@see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnLost() {
		JOptionPane.showMessageDialog(null,"Connection lost!","LoggingClient error",JOptionPane.ERROR_MESSAGE);
		connectionStatusLbl.setIcon(connectionStatusIcons[DISCONNECTED_ICON]);
		connectionStatusLbl.setToolTipText("Disconnected");
	}
	
	/**
	 * Notify that an attempt to connect to ACS NC is in progress
	 *@see com.cosylab.logging.engine.ACS.ACSRemoteLogListener
	 */
	public void acsLogConnConnecting() {
		setTitle("LoggingClient - Connecting");
		connectionStatusLbl.setIcon(connectionStatusIcons[CONNECTING_ICON]);
		connectionStatusLbl.setToolTipText("Connecting");
	}
}

