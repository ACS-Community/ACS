diff -Naur DDS.old//dds/DCPS/DataSampleHeader.cpp DDS/dds/DCPS/DataSampleHeader.cpp
--- DDS.old//dds/DCPS/DataSampleHeader.cpp	2012-01-09 10:55:43.321250000 -0300
+++ DDS/dds/DCPS/DataSampleHeader.cpp	2012-01-09 10:58:18.961875000 -0300
@@ -39,7 +39,7 @@
 
     if (!mb.cont()) return true;
 
-    memcpy(buffer, mb.cont()->rd_ptr(), 2);
+    ACE_OS::memcpy(buffer, mb.cont()->rd_ptr(), 2);
     break;
   case 1:
 
@@ -49,7 +49,7 @@
     buffer[1] = *mb.cont()->rd_ptr();
     break;
   default:
-    memcpy(buffer, mb.rd_ptr(), 2);
+    ACE_OS::memcpy(buffer, mb.rd_ptr(), 2);
   }
 
   if (buffer[1] & LIFESPAN_MASK) return len < full_header;
diff -Naur DDS.old//dds/idl/be_global.cpp DDS/dds/idl/be_global.cpp
--- DDS.old//dds/idl/be_global.cpp	2012-01-09 10:55:46.274375000 -0300
+++ DDS/dds/idl/be_global.cpp	2012-01-09 10:58:16.258750000 -0300
@@ -117,7 +117,7 @@
 BE_GlobalData::open_streams(const char* filename)
 {
   this->filename(filename);
-  size_t len = strlen(filename);
+  size_t len = ACE_OS::strlen(filename);
 
   if ((len < 5 || 0 != ACE_OS::strcasecmp(filename + len - 4, ".idl"))
       && (len < 6 || 0 != ACE_OS::strcasecmp(filename + len - 5, ".pidl"))) {
diff -Naur DDS.old//dds/idl/be_produce.cpp DDS/dds/idl/be_produce.cpp
--- DDS.old//dds/idl/be_produce.cpp	2012-01-09 10:55:46.290000000 -0300
+++ DDS/dds/idl/be_produce.cpp	2012-01-09 10:58:16.149375000 -0300
@@ -106,7 +106,7 @@
 {
   string ret = "OPENDDS_IDL_GENERATED_";
 
-  for (size_t i = 0; i < strlen(fn); ++i) {
+  for (size_t i = 0; i < ACE_OS::strlen(fn); ++i) {
     ret += isalnum(fn[i]) ? static_cast<char>(toupper(fn[i])) : '_';
   }
 
@@ -116,7 +116,7 @@
 /// change *.cpp to *.h
 string to_header(const char* cpp_name)
 {
-  size_t len = strlen(cpp_name);
+  size_t len = ACE_OS::strlen(cpp_name);
   assert(len >= 5 && 0 == ACE_OS::strcasecmp(cpp_name + len - 4, ".cpp"));
   string base_name(cpp_name, len - 4);
   return base_name + ".h";
@@ -184,7 +184,7 @@
   while (idl) {
     idl.getline(buffer, buffer_sz);
 
-    if (0 == strncmp("#include", buffer, 8)) { //FUTURE: account for comments?
+    if (0 == ACE_OS::strncmp("#include", buffer, 8)) { //FUTURE: account for comments?
       string inc(buffer + 8);
       size_t delim1 = inc.find_first_of("<\"");
       size_t delim2 = inc.find_first_of(">\"", delim1 + 1);
diff -Naur DDS.old//performance-tests/DCPS/SimpleLatency/raw_tcp/publisher/TcpPublisher.cpp DDS/performance-tests/DCPS/SimpleLatency/raw_tcp/publisher/TcpPublisher.cpp
--- DDS.old//performance-tests/DCPS/SimpleLatency/raw_tcp/publisher/TcpPublisher.cpp	2012-01-09 10:56:13.040000000 -0300
+++ DDS/performance-tests/DCPS/SimpleLatency/raw_tcp/publisher/TcpPublisher.cpp	2012-01-09 10:58:15.743125000 -0300
@@ -47,7 +47,7 @@
     stats_type& stats,
     const char *name)
 {
-    strncpy ((char *)stats.name, name, 19);
+    ACE_OS::strncpy ((char *)stats.name, name, 19);
     stats.name[19] = '\0';
     stats.count    = 0;
     stats.average  = ACE_hrtime_t(0.0);
diff -Naur DDS.old//tests/DCPS/Compiler/idl_test1_main/main.cpp DDS/tests/DCPS/Compiler/idl_test1_main/main.cpp
--- DDS.old//tests/DCPS/Compiler/idl_test1_main/main.cpp	2012-01-09 10:56:18.665000000 -0300
+++ DDS/tests/DCPS/Compiler/idl_test1_main/main.cpp	2012-01-09 10:58:15.883750000 -0300
@@ -393,7 +393,7 @@
       ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize octer\n")));
       failed = true;
     }
-  else if (0 != strcmp(ss_foo.theString.in (), my_foo.theString.in ()))
+  else if (0 != ACE_OS::strcmp(ss_foo.theString.in (), my_foo.theString.in ()))
     {
       ACE_ERROR((LM_ERROR,
         ACE_TEXT("Failed to serialize theString \"%C\" => \"%C\"\n"),
diff -Naur DDS.old//tests/DCPS/Compiler/idl_test1_main/main.cpp.orig DDS/tests/DCPS/Compiler/idl_test1_main/main.cpp.orig
--- DDS.old//tests/DCPS/Compiler/idl_test1_main/main.cpp.orig	1969-12-31 20:00:00.000000000 -0400
+++ DDS/tests/DCPS/Compiler/idl_test1_main/main.cpp.orig	2010-08-17 14:49:01.000000000 -0400
@@ -0,0 +1,419 @@
+#include "../idl_test1_lib/FooDefTypeSupportImpl.h"
+#include "ace/ACE.h"
+#include "ace/Log_Msg.h"
+#include <map>
+#include "tao/CDR.h"
+
+// this test tests the -Gdcps generated code for type XyZ::Foo from idl_test1_lib.
+int ACE_TMAIN (int argc, ACE_TCHAR *argv[])
+{
+  int failed = false;
+  bool dump_buffer = false;
+
+  if (argc > 1) dump_buffer = true;
+
+  {
+  Xyz::StructAUnion sau;
+  sau.sau_f1._d(Xyz::redx);
+  sau.sau_f1.rsv((const char*) "joe");
+  // size = union descr/4 + string length/4 + string contents/3
+  if (OpenDDS::DCPS::gen_find_size(sau) != 4+4+3)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("StructAUnion find_size failed with = %d\n"),
+        OpenDDS::DCPS::gen_find_size(sau)));
+      failed = true;
+    }
+  }
+  {
+  Xyz::AStringSeq ass;
+  ass.length(2); //4 for seq length
+  ass[0] = CORBA::string_dup ("four"); //4+4 strlen & string
+  ass[1] = CORBA::string_dup ("five5"); //4+5 strlen + string
+  size_t size_ass = OpenDDS::DCPS::gen_find_size(ass);
+  if (size_ass != 21)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("AStringSeq find_size failed with = %d ; expecting 21\n"),
+        size_ass));
+    }
+  }
+  {
+  Xyz::ArrayOfShortsSeq ash;
+  ash.length(2); //4 for seq length + 5*2 for arry *2 length
+  size_t size_ash = OpenDDS::DCPS::gen_find_size(ash);
+  if (size_ash != 24)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("ArrayOfShortsSeq find_size failed with = %d ; expecting 24\n"),
+        size_ash));
+    }
+  }
+
+  {
+  Xyz::StructContainingArrayOfAStruct aas;
+  aas.f1[0].v2s.length(2); //4 for v1 + 4 for length seq + 2*2
+  aas.f1[1].v2s.length(1); //4 for v1 + 4 for length seq + 2
+  aas.f1[2].v2s.length(0); //4 for v1 + 4 for length seq + 0
+  size_t size_aas = OpenDDS::DCPS::gen_find_size(aas);
+  if (size_aas != 30)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("StructContainingArrayOfAStruct find_size failed with = %d ; expecting 30\n"),
+        size_aas));
+    }
+  }
+
+  {
+  Xyz::StructContainingArrayOfAStructSeq aas;
+  aas.f1[0].length(1); //4 for length
+  aas.f1[0][0].v2s.length(2); //4 for v1 + 4 for length seq + 2*2
+  aas.f1[1].length(1);//4 for length
+  aas.f1[1][0].v2s.length(1); //4 for v1 + 4 for length seq + 2
+  aas.f1[2].length(1);//4 for length
+  aas.f1[2][0].v2s.length(0); //4 for v1 + 4 for length seq + 0
+  size_t size_aas = OpenDDS::DCPS::gen_find_size(aas);
+  if (size_aas != 42)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("StructContainingArrayOfAStructSeq find_size failed ")
+        ACE_TEXT("with = %d ; expecting 42\n"),
+        size_aas));
+    }
+  }
+
+  {
+  Xyz::StructOfArrayOfArrayOfShorts2 aas;
+  size_t size_aas = OpenDDS::DCPS::gen_find_size(aas);
+  if (size_aas != 18)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("StructContainingArrayOfAStructSeq find_size failed ")
+        ACE_TEXT("with = %d ; expecting 18\n"),
+        size_aas));
+    }
+
+  CORBA::Short count = 0;
+  for (int i = 0; i < 3 ; i++) {
+    for (int j = 0; j < 2 ; j++) {
+      aas.f1[i][j] = count++;
+    }
+  }
+
+  ACE_Message_Block *mb = new ACE_Message_Block(size_aas);
+  OpenDDS::DCPS::Serializer ss(mb);
+
+  if (false == ss << aas)
+    {
+      ACE_ERROR((LM_ERROR, "Serializing StructOfArrayOfArrayOfShorts2 failed\n"));
+      failed = true;
+    }
+
+  // Reset the chain back to the beginning.
+  // This is needed when the buffer size = find_size(my_foo) because
+  // the the serialize method set current_ the next block in the chain
+  // which is nil; so deserializing will fail.
+  ss.add_chain(mb) ;
+
+  Xyz::StructOfArrayOfArrayOfShorts2 aas2;
+  if (false == ss >> aas2)
+    {
+      ACE_ERROR((LM_ERROR, "Deserializing StructOfArrayOfArrayOfShorts2 failed\n"));
+      failed = true;
+    }
+  else
+    {
+      count = 0;
+      for (int i = 0; i < 3 ; i++) {
+        for (int j = 0; j < 2 ; j++) {
+          if (aas.f1[i][j] != count++)
+            {
+              ACE_ERROR((LM_ERROR,
+                ACE_TEXT("arrayOfArray[%d][%d] failed serailization\n"),
+                  i,j));
+              failed = true;
+            }
+        }
+      }
+    }
+
+    mb->release (); // don't leak memrory
+  }
+
+  Xyz::AStruct a_struct;
+  if (!OpenDDS::DCPS::gen_has_key(a_struct))
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("_dcps_has_key(Xyz::AStruct) returned false when expecting true.\n")
+        ));
+    }
+
+  Xyz::StructContainingArrayOfAStructSeq ascaoass;
+  if (OpenDDS::DCPS::gen_has_key(ascaoass))
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("_dcps_has_key(Xyz::StructContainingArrayOfAStructSeq) returned true when expecting false.\n")
+        ));
+    }
+
+  Xyz::Foo my_foo;
+
+  // greenx < redx < bluex
+  const Xyz::ColorX orig_color = Xyz::greenx;
+
+  // -- //+# is keeping track of the find_size
+  my_foo.key = 99; //4
+  my_foo.x = 0.99f; //+4 > 8
+  my_foo.y = 0.11f; //+4 > 12
+  my_foo.octer = 0x13; //+1 > 13
+  my_foo.xcolor = orig_color; //+4 > 17
+  // syntax error my_foo.ooo = {0xff, 0x80, 0x3d};
+  my_foo.ooo[0] = 0xff; //+3 > 20
+  my_foo.ooo[1] = 0x80;
+  my_foo.ooo[2] = 0x3d;
+  my_foo.ushrtseq.length(2); //+4+2*2 >> 28
+  my_foo.ushrtseq[0] = 7;
+  my_foo.ushrtseq[1] = 11;
+  my_foo.theString = CORBA::string_dup ("four");
+
+  // seq lenghts theStruct +4+4 theStructSeq +4 theString +4 + structArray3*8 = 40
+  // theUnion defaults to short so +4+2 = 6
+
+  const size_t expected_max_marshaled_size = 135;
+  const size_t expected_find_size = 28+40+6 + 4 /*string assigned */;
+  const CORBA::Boolean expected_bounded = false;
+
+  Xyz::Foo foo2;
+  foo2.key = 99;
+  foo2.x = 0.99f;
+  foo2.y = 0.11f;
+  foo2.octer = 0x13;
+  foo2.xcolor = orig_color;
+  // syntax error foo2.ooo = {0xff, 0x80, 0x3d};
+  foo2.ooo[0] = 0xff;
+  foo2.ooo[1] = 0x80;
+  foo2.ooo[2] = 0x3d;
+  foo2.ushrtseq.length(2);
+  foo2.ushrtseq[0] = 7;
+  foo2.ushrtseq[1] = 11;
+  foo2.theString = CORBA::string_dup ("four");
+
+  std::map<Xyz::Foo, Xyz::Foo*, Xyz::OpenDDSGenerated::Foo_KeyLessThan> foomap;
+
+  if (OpenDDS::DCPS::gen_has_key(my_foo))
+    {
+      foomap[my_foo] = &my_foo;
+      foomap[foo2] = &foo2;
+      // foo2 and my_foo should have mapped to the same place
+      if (foomap[my_foo] != &foo2)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map\n"));
+          failed = true;
+        }
+
+      my_foo.key = 77;
+      my_foo.xcolor = Xyz::redx;
+      foomap[my_foo] = &my_foo;
+      if (foomap[foo2] != &foo2)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 2\n"));
+          failed = true;
+        }
+
+      if (foomap[my_foo]->key != 77)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 3a\n"));
+          failed = true;
+        }
+      if (foomap[my_foo]->xcolor != Xyz::redx)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 3b\n"));
+          failed = true;
+        }
+      if (foomap[foo2]->xcolor != orig_color)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 4\n"));
+          failed = true;
+        }
+    }
+  else
+    ACE_DEBUG((LM_DEBUG, "NOTE: _dcps_has_key(foo) returned false\n"));
+
+  size_t ms = OpenDDS::DCPS::gen_max_marshaled_size(my_foo);
+  CORBA::Boolean bounded = OpenDDS::DCPS::gen_is_bounded_size(my_foo);
+  size_t cs = OpenDDS::DCPS::gen_find_size(my_foo);
+
+  ACE_DEBUG((LM_DEBUG,"OpenDDS::DCPS::gen_max_marshaled_size(my_foo) => %d\n", ms));
+  ACE_DEBUG((LM_DEBUG,"OpenDDS::DCPS::gen_is_bounded_size(my_foo) => %d\n", bounded));
+  ACE_DEBUG((LM_DEBUG,"OpenDDS::DCPS::gen_find_size(my_foo) => %d\n", cs));
+
+  if (bounded != expected_bounded)
+    {
+      ACE_ERROR((LM_ERROR, "OpenDDS::DCPS::gen_is_bounded_size(Foo) failed - expected %d got %d\n",
+        expected_bounded, bounded));
+      failed = true;
+    }
+  if (bounded && ms != expected_max_marshaled_size)
+    {
+      ACE_ERROR((LM_ERROR,
+        "_tao_max_marshaled_size(Foo) returned %d when was expecting %d\n",
+        ms, expected_max_marshaled_size));
+      failed = true;
+    }
+  if (!bounded && cs != expected_find_size)
+    {
+      ACE_ERROR((LM_ERROR,
+        "OpenDDS::DCPS::gen_find_size(Foo) returned %d when was expecting %d\n",
+        cs, expected_find_size));
+      failed = true;
+    }
+
+  TAO_OutputCDR cdr;
+  if (false == (cdr << my_foo))
+    {
+      ACE_ERROR((LM_ERROR, "TAO_OutputCDR << failed\n"));
+      failed = true;
+    }
+
+
+  ACE_TCHAR ebuffer[512] ; ebuffer[0] = ACE_TEXT('\0') ;
+  ACE_TCHAR obuffer[512] ; obuffer[0] = ACE_TEXT('\0') ;
+
+  // test serializing
+
+  const size_t buff_size = bounded ? ms : cs;
+  ACE_Message_Block *mb = new ACE_Message_Block(buff_size);
+  OpenDDS::DCPS::Serializer ss(mb);
+
+  if (dump_buffer)
+    {
+      ACE::format_hexdump( mb->rd_ptr(), mb->length(), ebuffer,
+        sizeof(ebuffer)) ;
+      ACE_DEBUG((LM_DEBUG,
+        ACE_TEXT("BEFORE WRITING, LENGTH: %d, BUFFER:\n%s\n"),
+        mb->length(), ebuffer));
+    }
+
+  if (false == ss << my_foo)
+    {
+      ACE_ERROR((LM_ERROR, "Serializing failed\n"));
+      failed = true;
+    }
+
+  if (dump_buffer)
+    {
+      ACE::format_hexdump( mb->rd_ptr(), mb->length(), ebuffer,
+        sizeof(ebuffer)) ;
+      ACE_DEBUG((LM_DEBUG,
+        ACE_TEXT("AFTER WRITING, LENGTH: %d, BUFFER:\n%s\n"),
+        mb->length(), ebuffer));
+    }
+
+  // Reset the chain back to the beginning.
+  // This is needed when the buffer size = find_size(my_foo) because
+  // the the serialize method set current_ the next block in the chain
+  // which is nil; so deserializing will fail.
+  ss.add_chain(mb) ;
+
+  Xyz::Foo ss_foo;
+  if (false == ss >> ss_foo)
+    {
+      ACE_ERROR((LM_ERROR, "Deserializing failed\n"));
+      failed = true;
+    }
+
+  if (dump_buffer)
+    {
+      ACE::format_hexdump( mb->rd_ptr(), mb->length(),
+        ebuffer, sizeof(ebuffer)) ;
+      ACE_DEBUG((LM_DEBUG,
+        ACE_TEXT("AFTER READING, LENGTH: %d, BUFFER:\n%s\n"),
+        mb->length(), ebuffer));
+
+      ACE::format_hexdump( (char*)&(my_foo.key), sizeof(ACE_CDR::ULong),
+        ebuffer, sizeof(ebuffer)) ;
+      ACE::format_hexdump( (char*)&(ss_foo.key), sizeof(ACE_CDR::ULong),
+        obuffer, sizeof(obuffer)) ;
+      ACE_ERROR((LM_ERROR,
+                ACE_TEXT("key (expected:\n%s, observed:\n%s)\n"),
+                ebuffer, obuffer
+              ));
+      ACE::format_hexdump( (char*)&(my_foo.x), sizeof(ACE_CDR::Float),
+        ebuffer, sizeof(ebuffer)) ;
+      ACE::format_hexdump( (char*)&(ss_foo.x), sizeof(ACE_CDR::Float),
+        obuffer, sizeof(obuffer)) ;
+      ACE_ERROR((LM_ERROR,
+                ACE_TEXT("x (expected:\n%s, observed:\n%s)\n"),
+                ebuffer, obuffer
+              ));
+      ACE::format_hexdump( (char*)&(my_foo.y), sizeof(ACE_CDR::Float),
+        ebuffer, sizeof(ebuffer)) ;
+      ACE::format_hexdump( (char*)&(ss_foo.y), sizeof(ACE_CDR::Float),
+        obuffer, sizeof(obuffer)) ;
+      ACE_ERROR((LM_ERROR,
+                ACE_TEXT("y (expected:\n%s, observed:\n%s)\n"),
+                ebuffer, obuffer
+              ));
+      ACE::format_hexdump( (char*)&(my_foo.xcolor), sizeof(ACE_CDR::UShort), ebuffer, sizeof(ebuffer)) ;
+      ACE::format_hexdump( (char*)&(ss_foo.xcolor), sizeof(ACE_CDR::UShort), obuffer, sizeof(obuffer)) ;
+      ACE_ERROR((LM_ERROR,
+                ACE_TEXT("xcolor (expected:\n%s, observed:\n%s)\n"),
+                ebuffer, obuffer
+              ));
+      ACE::format_hexdump( (char*)&(my_foo.octer), sizeof(ACE_CDR::Octet), ebuffer, sizeof(ebuffer)) ;
+      ACE::format_hexdump( (char*)&(ss_foo.octer), sizeof(ACE_CDR::Octet), obuffer, sizeof(obuffer)) ;
+      ACE_ERROR((LM_ERROR,
+                ACE_TEXT("octer (expected:\n%s, observed:\n%s)\n"),
+                ebuffer, obuffer
+              ));
+    }
+
+  if (ss_foo.key != my_foo.key)
+    {
+      ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize key\n")));
+      failed = true;
+    }
+  else if (ss_foo.x != my_foo.x)
+    {
+      ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize x\n")));
+      failed = true;
+    }
+  else if (ss_foo.y != my_foo.y)
+    {
+      ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize y\n")));
+      failed = true;
+    }
+  else if (ss_foo.xcolor != my_foo.xcolor)
+    {
+      ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize xcolor\n")));
+      failed = true;
+    }
+  else if (ss_foo.octer != my_foo.octer)
+    {
+      ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize octer\n")));
+      failed = true;
+    }
+  else if (0 != strcmp(ss_foo.theString.in (), my_foo.theString.in ()))
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("Failed to serialize theString \"%C\" => \"%C\"\n"),
+        my_foo.theString.in (), ss_foo.theString.in ()));
+      failed = true;
+    }
+  else if (ss_foo.ooo[0] != my_foo.ooo[0]
+        || ss_foo.ooo[1] != my_foo.ooo[1]
+        || ss_foo.ooo[2] != my_foo.ooo[2])
+    {
+      ACE_ERROR((LM_ERROR, "Failed to serialize ooo\n"));
+      failed = true;
+    }
+
+  mb->release(); // don't leak memory!
+
+  if (failed)
+    ACE_ERROR((LM_ERROR, "%s FAILED!\n", argv[0]));
+  else
+    ACE_DEBUG((LM_ERROR, "%s PASSED\n", argv[0]));
+
+  return failed; // let the test framework know it failed
+}
diff -Naur DDS.old//tests/DCPS/Compiler/idl_test3_main/main.cpp DDS/tests/DCPS/Compiler/idl_test3_main/main.cpp
--- DDS.old//tests/DCPS/Compiler/idl_test3_main/main.cpp	2012-01-09 10:56:18.899375000 -0300
+++ DDS/tests/DCPS/Compiler/idl_test3_main/main.cpp	2012-01-09 10:58:16.008750000 -0300
@@ -166,7 +166,7 @@
       {
         for (CORBA::ULong ii =0; ii < ARRAY_LEN;ii++)
           {
-            if (strcmp(val.f[ii], val_out.f[ii]))
+            if (ACE_OS::strcmp(val.f[ii], val_out.f[ii]))
               {
                 ACE_ERROR((LM_ERROR,
                   ACE_TEXT("Xyz::StructOfArrayOfString: marshaling comparison failure\n")));
@@ -328,7 +328,7 @@
       {
         for (CORBA::ULong ii =0; ii < SEQ_LEN;ii++)
           {
-            if (strcmp(val[ii], val_out[ii]))
+            if (ACE_OS::strcmp(val[ii], val_out[ii]))
               {
                 ACE_ERROR((LM_ERROR,
                   ACE_TEXT("Xyz::SeqOfString: marshaling comparison failure\n")));
@@ -499,7 +499,7 @@
     if (try_marshaling<Xyz::StructAUnion>(val, val_out,
                             DONT_CHECK_MS, SEQ_LEN_SIZE+4+3, "Xyz::StructAUnion"))
       {
-         if (strcmp(val.sau_f1.rv (), val_out.sau_f1.rv ()))
+         if (ACE_OS::strcmp(val.sau_f1.rv (), val_out.sau_f1.rv ()))
            {
              ACE_ERROR((LM_ERROR,
                ACE_TEXT("Xyz::StructAUnion: marshaling comparison failure\n")));
@@ -517,7 +517,7 @@
     if (try_marshaling<Xyz::SeqOfString>(val, val_out,
                             DONT_CHECK_MS, 21, "Xyz::SeqOfString"))
       {
-         if (strcmp(val[1], val_out[1]))
+         if (ACE_OS::strcmp(val[1], val_out[1]))
            {
              ACE_ERROR((LM_ERROR,
                ACE_TEXT("Xyz::SeqOfString: marshaling comparison failure\n")));
@@ -650,7 +650,7 @@
           ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize octer\n")));
           failed = true;
         }
-      else if (0 != strcmp(ss_foo.theString.in (), my_foo.theString.in ()))
+      else if (0 != ACE_OS::strcmp(ss_foo.theString.in (), my_foo.theString.in ()))
         {
           ACE_ERROR((LM_ERROR,
             ACE_TEXT("Failed to serialize theString \"%C\" => \"%C\"\n"),
@@ -672,7 +672,7 @@
         }
 */
 /*
-      //else if (0 != strcmp(ss_foo.theSeqOfUnion[0].rv(), my_foo.theSeqOfUnion[0].rv()))
+      //else if (0 != ACE_OS::strcmp(ss_foo.theSeqOfUnion[0].rv(), my_foo.theSeqOfUnion[0].rv()))
       //  {
       //    ACE_ERROR((LM_ERROR, "Failed to serialize foo.theSeqOfUnion[0].rv()\n"));
       //    failed = true;
diff -Naur DDS.old//tests/DCPS/Compiler/idl_test3_main/main.cpp.orig DDS/tests/DCPS/Compiler/idl_test3_main/main.cpp.orig
--- DDS.old//tests/DCPS/Compiler/idl_test3_main/main.cpp.orig	1969-12-31 20:00:00.000000000 -0400
+++ DDS/tests/DCPS/Compiler/idl_test3_main/main.cpp.orig	2010-08-17 14:49:01.000000000 -0400
@@ -0,0 +1,699 @@
+#include "../idl_test3_lib/FooDefTypeSupportImpl.h"
+#include "ace/ACE.h"
+#include "ace/Log_Msg.h"
+#include <map>
+#include "tao/CDR.h"
+
+int failed = false;
+bool dump_buffer = false;
+
+#define DONT_CHECK_CS 0
+#define DONT_CHECK_MS 0
+
+template<typename FOO>
+int try_marshaling(const FOO &in_foo, FOO &out_foo,
+                   size_t expected_ms,
+                   size_t expected_cs,
+                   const char* name)
+{
+  CORBA::Boolean bounded = OpenDDS::DCPS::gen_is_bounded_size(in_foo);
+  size_t ms = OpenDDS::DCPS::gen_max_marshaled_size(in_foo);
+  size_t cs = OpenDDS::DCPS::gen_find_size(in_foo);
+
+  ACE_DEBUG((LM_DEBUG,
+    ACE_TEXT("%C: OpenDDS::DCPS::gen_is_bounded_size(foo) => %d\n"),
+    name, bounded));
+  ACE_DEBUG((LM_DEBUG,
+    ACE_TEXT("%C: _max_marshaled_size(my_foo) => %d\n"),
+    name, ms));
+  ACE_DEBUG((LM_DEBUG,
+    ACE_TEXT("%C: OpenDDS::DCPS::gen_find_size(my_foo) => %d\n"),
+    name, cs));
+
+  // NOTE:_max_marshaled_size is not always > for unbounded.
+  if (bounded && ms < cs)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("%C: OpenDDS::DCPS::gen_max_marshaled_size(foo) %d < OpenDDS::DCPS::gen_find_size(foo) %d\n"),
+        name, ms, cs));
+      failed = true;
+      return false;
+    }
+
+  if (expected_cs != DONT_CHECK_CS && cs != expected_cs)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("%C: OpenDDS::DCPS::gen_find_size(foo) got %d but expected %d\n"),
+        name, cs, expected_cs ));
+      failed = true;
+      return false;
+    }
+
+  if (expected_ms != DONT_CHECK_MS && ms != expected_ms)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("%C: OpenDDS::DCPS::gen_max_marshaled_size(foo) got %d but expected %d\n"),
+        name, ms, expected_ms ));
+      failed = true;
+      return false;
+    }
+
+  // testing with OpenDDS::DCPS::gen_find_size is a stronger test
+  const size_t buff_size = cs; // bounded ? ms : cs;
+  ACE_Message_Block *mb = new ACE_Message_Block(buff_size);
+
+  TAO_OutputCDR cdr;
+  if (false == (cdr << in_foo))
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("%C: TAO_OutputCDR << failed\n"), name));
+      failed = true;
+    }
+
+
+  ACE_TCHAR ebuffer[51200] ; ebuffer[0] = ACE_TEXT('\0') ;
+  ACE_TCHAR obuffer[51200] ; obuffer[0] = ACE_TEXT('\0') ;
+
+  OpenDDS::DCPS::Serializer ss(mb);
+
+  if (dump_buffer)
+    {
+      ACE::format_hexdump( mb->rd_ptr(), mb->length(), ebuffer,
+        sizeof(ebuffer)) ;
+      ACE_DEBUG((LM_DEBUG,
+        ACE_TEXT("%C: BEFORE WRITING, LENGTH: %d, BUFFER:\n%s\n"),
+        name, mb->length(), ebuffer));
+    }
+
+  if (false == ss << in_foo)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("%C: Serializing failed\n"), name));
+      failed = true;
+      return false;
+    }
+
+  if (dump_buffer)
+    {
+      ACE::format_hexdump( mb->rd_ptr(), mb->length(), ebuffer,
+        sizeof(ebuffer)) ;
+      ACE_DEBUG((LM_DEBUG,
+        ACE_TEXT("%C: AFTER WRITING, LENGTH: %d, BUFFER:\n%s\n"),
+        name, mb->length(), ebuffer));
+    }
+
+  // Reset the chain back to the beginning.
+  // This is needed when the buffer size = find_size(my_foo) because
+  // the the serialize method set current_ the next block in the chain
+  // which is nil; so deserializing will fail.
+  ss.add_chain(mb) ;
+
+  if (false == ss >> out_foo)
+    {
+      ACE_ERROR((LM_ERROR,
+        ACE_TEXT("%C: Deserializing failed\n"), name));
+      failed = true;
+      mb->release(); // don't leak memory!
+      return false;
+    }
+
+  mb->release(); // don't leak memory!
+
+  ACE_DEBUG((LM_DEBUG,
+    ACE_TEXT("%C: try_marshaling PASSED\n"), name));
+  return true;
+}
+
+// this test tests the -Gdcps generated code for type XyZ::Foo from foo_test1_lib.
+int ACE_TMAIN (int argc, ACE_TCHAR *argv[])
+{
+
+  if (argc > 1) dump_buffer = true;
+
+  // ARRAYS
+  const CORBA::ULong ARRAY_LEN = 5;
+  { //=====================================================================
+    Xyz::StructOfArrayOfBoolean val;
+    for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+      {
+        val.f[ii] = (ii % 2 == 0) ? true : false;
+      }
+    Xyz::StructOfArrayOfBoolean val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfBoolean>(val, val_out,
+                            DONT_CHECK_MS, ARRAY_LEN, "Xyz::ArrayOfBoolean"))
+      {
+        for (CORBA::ULong ii =0; ii < ARRAY_LEN;ii++)
+          {
+            if (val_out.f[ii] != ((ii % 2 == 0) ? true : false))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::ArrayOfBoolean: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::StructOfArrayOfString val;
+    val.f[0] = CORBA::string_dup("I");
+    val.f[1] = CORBA::string_dup("hope");
+    val.f[2] = CORBA::string_dup("this");
+    val.f[3] = CORBA::string_dup("works");
+    val.f[4] = CORBA::string_dup("");
+    Xyz::StructOfArrayOfString val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfString>(val, val_out,
+                            DONT_CHECK_MS, ARRAY_LEN*4+14, "Xyz::StructOfArrayOfString"))
+      {
+        for (CORBA::ULong ii =0; ii < ARRAY_LEN;ii++)
+          {
+            if (strcmp(val.f[ii], val_out.f[ii]))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::StructOfArrayOfString: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::StructOfArrayOfChar val;
+    for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+      {
+        val.f[ii] = static_cast<char>(65+ii);
+      }
+    Xyz::StructOfArrayOfChar val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfChar>(val, val_out,
+                            DONT_CHECK_MS, ARRAY_LEN, "Xyz::StructOfArrayOfChar"))
+      {
+        for (CORBA::ULong ii =0; ii < ARRAY_LEN;ii++)
+          {
+            if (val_out.f[ii] != static_cast<char>(65+ii))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::StructOfArrayOfChar: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::StructOfArrayOfOctet val;
+    for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+      {
+        val.f[ii] = ii;
+      }
+    Xyz::StructOfArrayOfOctet val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfOctet>(val, val_out,
+                            DONT_CHECK_MS, ARRAY_LEN, "Xyz::StructOfArrayOfOctet"))
+      {
+        for (CORBA::Octet ii =0; ii < ARRAY_LEN;ii++)
+          {
+            if (val_out.f[ii] != ii)
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::StructOfArrayOfOctet: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::StructOfArrayOfLong val;
+    for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+      {
+        val.f[ii] = static_cast<CORBA::Long>(ii);
+      }
+    Xyz::StructOfArrayOfLong val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfLong>(val, val_out,
+                            DONT_CHECK_MS, 4*ARRAY_LEN, "Xyz::StructOfArrayOfLong"))
+      {
+        for (CORBA::ULong ii =0; ii < ARRAY_LEN;ii++)
+          {
+            if (val_out.f[ii] != static_cast<CORBA::Long>(ii))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::StructOfArrayOfLong: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::StructOfArrayOfAnEnum val;
+    for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+      {
+        val.f[ii] = (ii % 2 == 0) ? Xyz::greenx : Xyz::bluex;
+      }
+    Xyz::StructOfArrayOfAnEnum val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfAnEnum>(val, val_out,
+                            DONT_CHECK_MS, 4*ARRAY_LEN, "Xyz::StructOfArrayOfAnEnum"))
+      {
+        for (CORBA::ULong ii =0; ii < ARRAY_LEN;ii++)
+          {
+            if (val_out.f[ii] != ((ii % 2 == 0) ? Xyz::greenx : Xyz::bluex))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::StructOfArrayOfAnEnum: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+
+  // ARRAYS OF ARRAYS
+  const CORBA::ULong AofA_LEN = 7;
+  { //=====================================================================
+    Xyz::StructOfArrayOfArrayOfLong val;
+    for (CORBA::ULong jj =0; jj < AofA_LEN; jj++)
+      for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+        {
+          val.f[jj][ii] = ii+jj*ARRAY_LEN;
+        }
+    Xyz::StructOfArrayOfArrayOfLong val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfArrayOfLong>(val, val_out,
+                            DONT_CHECK_MS, 4*ARRAY_LEN*AofA_LEN, "Xyz::ArrayOfArrayOfLong"))
+      {
+        for (CORBA::ULong jj =0; jj < AofA_LEN; jj++)
+          for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+            {
+            if (val_out.f[jj][ii] != CORBA::Long(ii+jj*ARRAY_LEN))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::ArrayOfArrayOfLong: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+
+
+  // SEQUENCES
+
+  const CORBA::ULong SEQ_LEN = 5;
+  const CORBA::ULong SEQ_LEN_SIZE = 4;
+
+  { //=====================================================================
+    Xyz::SeqOfBoolean val;
+    val.length (SEQ_LEN);
+    for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+      {
+        val[ii] = (ii % 2 == 0) ? true : false;
+      }
+    Xyz::SeqOfBoolean val_out;
+    if (try_marshaling<Xyz::SeqOfBoolean>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+SEQ_LEN, "Xyz::SeqOfBoolean"))
+      {
+        for (CORBA::ULong ii =0; ii < SEQ_LEN;ii++)
+          {
+            if (val_out[ii] != ((ii % 2 == 0) ? true : false))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfBoolean: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::SeqOfString val;
+    val.length (SEQ_LEN);
+    val[0] = CORBA::string_dup("I");
+    val[1] = CORBA::string_dup("hope");
+    val[2] = CORBA::string_dup("this");
+    val[3] = CORBA::string_dup("works");
+    val[4] = CORBA::string_dup("");
+    Xyz::SeqOfString val_out;
+    if (try_marshaling<Xyz::SeqOfString>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+SEQ_LEN*4+14, "Xyz::SeqOfString"))
+      {
+        for (CORBA::ULong ii =0; ii < SEQ_LEN;ii++)
+          {
+            if (strcmp(val[ii], val_out[ii]))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfString: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::SeqOfChar val;
+    val.length (SEQ_LEN);
+    for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+      {
+        val[ii] = static_cast<char>(65+ii);
+      }
+    Xyz::SeqOfChar val_out;
+    if (try_marshaling<Xyz::SeqOfChar>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+SEQ_LEN, "Xyz::SeqOfChar"))
+      {
+        for (CORBA::ULong ii =0; ii < SEQ_LEN;ii++)
+          {
+            if (val_out[ii] != static_cast<char>(65+ii))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfChar: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::SeqOfOctet val;
+    val.length (SEQ_LEN);
+    for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+      {
+        val[ii] = ii;
+      }
+    Xyz::SeqOfOctet val_out;
+    if (try_marshaling<Xyz::SeqOfOctet>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+SEQ_LEN, "Xyz::SeqOfOctet"))
+      {
+        for (CORBA::Octet ii =0; ii < SEQ_LEN;ii++)
+          {
+            if (val_out[ii] != ii)
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfOctet: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::SeqOfLong val;
+    val.length (SEQ_LEN);
+    for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+      {
+        val[ii] = ii;
+      }
+    Xyz::SeqOfLong val_out;
+    if (try_marshaling<Xyz::SeqOfLong>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+4*SEQ_LEN, "Xyz::SeqOfLong"))
+      {
+        for (CORBA::ULong ii =0; ii < SEQ_LEN;ii++)
+          {
+            if (val_out[ii] != CORBA::Long(ii))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfLong: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+  { //=====================================================================
+    Xyz::SeqOfAnEnum val;
+    val.length (SEQ_LEN);
+    for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+      {
+        val[ii] = (ii % 2 == 0) ? Xyz::greenx : Xyz::bluex;
+      }
+    Xyz::SeqOfAnEnum val_out;
+    if (try_marshaling<Xyz::SeqOfAnEnum>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+4*SEQ_LEN, "Xyz::SeqOfAnEnum"))
+      {
+        for (CORBA::ULong ii =0; ii < SEQ_LEN;ii++)
+          {
+            if (val_out[ii] != ((ii % 2 == 0) ? Xyz::greenx : Xyz::bluex))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfAnEnum: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+
+  // ARRAYS OF SEQUENCES
+  const CORBA::ULong AofS_LEN = 6;
+  { //=====================================================================
+    Xyz::StructOfArrayOfSeqOfLong val;
+    for (CORBA::ULong jj =0; jj < AofS_LEN; jj++)
+      {
+        val.f[jj].length (SEQ_LEN);
+        for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+            {
+              val.f[jj][ii] = ii+jj*ARRAY_LEN;
+            }
+      }
+    Xyz::StructOfArrayOfSeqOfLong val_out;
+    if (try_marshaling<Xyz::StructOfArrayOfSeqOfLong>(val, val_out,
+                            DONT_CHECK_MS, 4*ARRAY_LEN*AofS_LEN + 4*AofS_LEN, "Xyz::ArrayOfSeqOfLong"))
+      {
+        for (CORBA::ULong jj =0; jj < AofS_LEN; jj++)
+          for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+            {
+            if (val_out.f[jj][ii] != CORBA::Long(ii+jj*ARRAY_LEN))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::ArrayOfSeqOfLong: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+
+  // SEQUENCE OF SEQUENCES
+  const CORBA::ULong SofS_LEN = 4;
+  { //=====================================================================
+    Xyz::SeqOfSeqOfLong val;
+    val.length(SofS_LEN);
+    for (CORBA::ULong jj =0; jj < SofS_LEN; jj++)
+      {
+        val[jj].length (SEQ_LEN);
+        for (CORBA::ULong ii =0; ii < SEQ_LEN; ii++)
+            {
+              val[jj][ii] = CORBA::Long(ii+jj*ARRAY_LEN);
+            }
+      }
+    Xyz::SeqOfSeqOfLong val_out;
+    if (try_marshaling<Xyz::SeqOfSeqOfLong>(val, val_out,
+                            DONT_CHECK_MS,
+                            // longs + inner lengths + outter length
+                            4*SEQ_LEN*SofS_LEN + 4*SofS_LEN + 4,
+                            "Xyz::SeqOfSeqOfLong"))
+      {
+        for (CORBA::ULong jj =0; jj < SofS_LEN; jj++)
+          for (CORBA::ULong ii =0; ii < ARRAY_LEN; ii++)
+            {
+            if (val_out[jj][ii] != CORBA::Long(ii+jj*ARRAY_LEN))
+              {
+                ACE_ERROR((LM_ERROR,
+                  ACE_TEXT("Xyz::SeqOfSeqOfLong: marshaling comparison failure\n")));
+                failed = true;
+              }
+          }
+      }
+  }
+
+  // OTHER
+
+  { //=====================================================================
+    Xyz::StructAUnion val;
+    val.sau_f1._d(Xyz::redx);
+    val.sau_f1.rv(CORBA::string_dup("joe"));
+    // size = union descr/4 + string length/4 + string contents/3
+    Xyz::StructAUnion val_out;
+    if (try_marshaling<Xyz::StructAUnion>(val, val_out,
+                            DONT_CHECK_MS, SEQ_LEN_SIZE+4+3, "Xyz::StructAUnion"))
+      {
+         if (strcmp(val.sau_f1.rv (), val_out.sau_f1.rv ()))
+           {
+             ACE_ERROR((LM_ERROR,
+               ACE_TEXT("Xyz::StructAUnion: marshaling comparison failure\n")));
+             failed = true;
+           }
+      }
+  }
+
+  { //=====================================================================
+    Xyz::SeqOfString val;
+    val.length(2); //4 for seq length
+    val[0] = CORBA::string_dup("four"); //4+4 strlen & string
+    val[1] = CORBA::string_dup("five5"); //4+5 strlen + string
+    Xyz::SeqOfString val_out;
+    if (try_marshaling<Xyz::SeqOfString>(val, val_out,
+                            DONT_CHECK_MS, 21, "Xyz::SeqOfString"))
+      {
+         if (strcmp(val[1], val_out[1]))
+           {
+             ACE_ERROR((LM_ERROR,
+               ACE_TEXT("Xyz::SeqOfString: marshaling comparison failure\n")));
+             failed = true;
+           }
+      }
+  }
+
+  Xyz::Foo my_foo;
+
+  // greenx < redx < bluex
+  const Xyz::AnEnum orig_color = Xyz::greenx;
+
+  // -- //+# is keeping track of the find_size
+  my_foo.key = 99; //4
+  my_foo.x = 0.99f; //+4 > 8
+  my_foo.y = 0.11f; //+4 > 12
+  my_foo.octer = 0x13; //+1 > 13
+  my_foo.xcolor = orig_color; //+4 > 17
+  // syntax error my_foo.ooo = {0xff, 0x80, 0x3d};
+  my_foo.ooo[0] = 0xff; //+3 > 20
+  my_foo.ooo[1] = 0x80;
+  my_foo.ooo[2] = 0x3d;
+  my_foo.theString = CORBA::string_dup("four");
+  //  ACE_DEBUG((LM_DEBUG, "thestruct.f60.length() = %d\n",
+  //           my_foo.thestruct.f60.length()));
+  my_foo.theUnion._d(Xyz::bluex); // !!!! Unions are invalid unless set!!!
+  Xyz::SeqOfLong asol;
+  asol.length(2);
+  asol[0] = 77;
+  asol[1] = 88;
+  my_foo.theUnion.bv(asol);// !!!! Unions are invalid unless set!!!
+  my_foo.theSeqOfUnion.length(2);
+  my_foo.theSeqOfUnion[0]._d(Xyz::redx);
+  my_foo.theSeqOfUnion[0].rv(CORBA::string_dup("Berkley"));
+  my_foo.theSeqOfUnion[1]._d(Xyz::greenx);
+  Xyz::AStruct as;
+  as.f2 = 3.14F;
+  my_foo.theSeqOfUnion[1].gv(as);
+
+  // seq lenghts theStruct +4+4 theStructSeq +4 theString +4 + structArray3*8 = 40
+  // theUnion defaults to short so +4+2 = 6
+
+  //const size_t expected_max_marshaled_size = 135;
+  //const size_t expected_find_size = 28+40+6 + 4 /*string assigned */;
+  //const CORBA::Boolean expected_bounded = false;
+
+  Xyz::Foo foo2;
+  foo2.key = 99;
+  foo2.x = 0.99f;
+  foo2.y = 0.11f;
+  foo2.octer = 0x13;
+  foo2.xcolor = orig_color;
+  // syntax error foo2.ooo = {0xff, 0x80, 0x3d};
+  foo2.ooo[0] = 0xff;
+  foo2.ooo[1] = 0x80;
+  foo2.ooo[2] = 0x3d;
+  foo2.theString = CORBA::string_dup("four");
+
+
+  std::map<Xyz::Foo, Xyz::Foo*, Xyz::OpenDDSGenerated::Foo_KeyLessThan> foomap;
+
+  if (OpenDDS::DCPS::gen_has_key(my_foo))
+    {
+      foomap[my_foo] = &my_foo;
+      foomap[foo2] = &foo2;
+      // foo2 and my_foo should have mapped to the same place
+      if (foomap[my_foo] != &foo2)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map\n"));
+          failed = true;
+        }
+
+      my_foo.key = 77;
+      my_foo.xcolor = Xyz::redx;
+      foomap[my_foo] = &my_foo;
+      if (foomap[foo2] != &foo2)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 2\n"));
+          failed = true;
+        }
+
+      if (foomap[my_foo]->key != 77)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 3a\n"));
+          failed = true;
+        }
+      if (foomap[my_foo]->xcolor != Xyz::redx)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 3b\n"));
+          failed = true;
+        }
+      if (foomap[foo2]->xcolor != orig_color)
+        {
+          ACE_ERROR((LM_ERROR, "FooKeyLessThan failed with map - 4\n"));
+          failed = true;
+        }
+    }
+  else
+    ACE_DEBUG((LM_DEBUG, "NOTE: _dcps_has_key(foo) returned false\n"));
+
+
+  Xyz::Foo ss_foo;
+  if (try_marshaling<Xyz::Foo>(my_foo, ss_foo,
+                           DONT_CHECK_MS, DONT_CHECK_CS, "Xyz::Foo"))
+    {
+
+      if (ss_foo.key != my_foo.key)
+        {
+          ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize key\n")));
+          failed = true;
+        }
+      else if (ss_foo.x != my_foo.x)
+        {
+          ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize x\n")));
+          failed = true;
+        }
+      else if (ss_foo.y != my_foo.y)
+        {
+          ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize y\n")));
+          failed = true;
+        }
+      else if (ss_foo.xcolor != my_foo.xcolor)
+        {
+          ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize xcolor\n")));
+          failed = true;
+        }
+      else if (ss_foo.octer != my_foo.octer)
+        {
+          ACE_ERROR((LM_ERROR, ACE_TEXT("Failed to serialize octer\n")));
+          failed = true;
+        }
+      else if (0 != strcmp(ss_foo.theString.in (), my_foo.theString.in ()))
+        {
+          ACE_ERROR((LM_ERROR,
+            ACE_TEXT("Failed to serialize theString \"%C\" => \"%C\"\n"),
+            my_foo.theString.in (), ss_foo.theString.in ()));
+          failed = true;
+        }
+      else if (ss_foo.ooo[0] != my_foo.ooo[0]
+            || ss_foo.ooo[1] != my_foo.ooo[1]
+            || ss_foo.ooo[2] != my_foo.ooo[2])
+        {
+          ACE_ERROR((LM_ERROR, "Failed to serialize ooo\n"));
+          failed = true;
+        }
+/*
+      else if (ss_foo.theUnion.bv()[1] != my_foo.theUnion.bv()[1])
+        {
+          ACE_ERROR((LM_ERROR, "Failed to serialize foo.theUnion.bv()[1]\n"));
+          failed = true;
+        }
+*/
+/*
+      //else if (0 != strcmp(ss_foo.theSeqOfUnion[0].rv(), my_foo.theSeqOfUnion[0].rv()))
+      //  {
+      //    ACE_ERROR((LM_ERROR, "Failed to serialize foo.theSeqOfUnion[0].rv()\n"));
+      //    failed = true;
+      //  }
+      //else if (ss_foo.theSeqOfUnion[1].gv().f2 != my_foo.theSeqOfUnion[1].gv().f2)
+      //  {
+      //    ACE_ERROR((LM_ERROR, "Failed to serialize foo.theSeqOfUnion[1].gv().f2\n"));
+      //    failed = true;
+        }
+      else if (ss_foo.theSeqOfUnion[1].gv().f2 != my_foo.theSeqOfUnion[1].gv().f2)
+        {
+          ACE_ERROR((LM_ERROR, "Failed to serialize foo.theSeqOfUnion[1].gv().f2\n"));
+          failed = true;
+        }
+*/
+    }
+
+  if (failed)
+    ACE_ERROR((LM_ERROR, "%s FAILED!\n", argv[0]));
+  else
+    ACE_DEBUG((LM_ERROR, "%s PASSED\n", argv[0]));
+
+  return failed; // let the test framework know it failed
+}
