<html>

<head>

<meta http-equiv=Content-Type content="text/html; charset=windows-1252">

<link rel=Edit-Time-Data href="FeaturesComponent_files/editdata.mso">

<title>FeaturesComponent</title>

<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"



 name="PlaceName"/> <o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"



 name="PlaceType"/> <o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"



 name="City"/> <o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"



 name="place"/> 

<style><!--

.Normal

	{font-size:12.0pt;

	font-family:"Times New Roman";}

-->

</style>

<meta name=Template content="C:\Program Files\MSOffice\Office\html.dot">

</head>

<body lang=EN-US link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">

<h2><a name=DistributedObjectConcept>ACS Component</a></h2>

<p>The requirements document <a href="ReferenceDocuments.html#RD01">[RD01]</a> 

  specifies as a basic design requirement the adoption of an Object Oriented architecture 

  based on distributed objects <a href="ReferenceDocuments.html#RD01">[RD01 - 

  13.1.1 Distributed Objects and commands]</a>. </p>

<p>The Technical Architecture in the ALMA Software Architecture document <a href="ReferenceDocuments.html#RD33">[RD33]</a>  

  identifies a Container-Component model for software organization and development 

  as our primary instrument for achieving separation of functional from technical 

  concerns.</p>

<p>This concept is the basis for the architecture and all services provided by 

  ACS are designed around Components. </p>

<h3>Every Component must implement the ComponentLifeCycle interface. This interface 

  foresees the following basic lifecycle operations:</h3>

<ul type=disc>

  <li>initialize – called to give the component time to initialize itself, e.g. 

    retrieve connections, read configuration parameters, build up in-memory tables…..</li>

  <li>execute – called after initialize() to tell the component that it has to 

    be ready to accept incoming functional calls any time</li>

  <li>cleanup – the component should release resources in an orderly manner, because 

    shutdown is imminent</li>

  <li>aboutToAbort – the component will be forcibly removed due to some error 

    condition.</li>

</ul>

<h3>The Container passes to each Component a ContainerServices object (in C++ 
  this occurs at construction time, while in Java at initialize() time, because 
  of the different traditional ways of using constructors and destructors in the 
  two languages). At that point, the Component can assume that all infrastuctural 
  services it may need have been properly set up by the Container and are available 
  via the ContainerServices object.</h3>

<h3>The architecture of the system is based on CORBA. Component and Container 

  interfaces are described in IDL, and Components and Container are implemented 

  as CORBA objects. The impact of CORBA on component implementation classes is 

  very low or none, varying among languages. For exceptional cases, a component 

  can explicitly ask the container to create an associated CORBA object (called 

  an &quot;OffShoot&quot;) and then pass it around in the system. </h3>

<h3>ORB independence and interoperability <a href="ReferenceDocuments.html#RD01">[RD01 

  - 10.4.2 ORB Independence]</a> is ensured by basing the Distributed Object implementation 

  on CORBA Inter-ORB Protocol (IIOP) and Portable Object Adapter (POA) and by 

  not allowing the use of any ORB-specific feature. Interoperability between ORBs 

  has been demonstrated with the the <st1:place><st1:PlaceName>Kitt</st1:PlaceName> 

  <st1:PlaceType>Peak</st1:PlaceType></st1:place> Test and with the previous releases 

  of ACS, where we have changed ORBs a number of times. The selection of the final 

  ORBs needed for ACS is not part of this Architecture document. The current baseline 

  includes TAO<a



href="ReferenceDocuments.html#RD07">[RD07]</a> 

  for C/C++, JacORB<a



href="ReferenceDocuments.html#RD34">[RD34]</a> 

  for Java, omniORB<a



href="ReferenceDocuments.html#RD15">[RD15]</a> 

  for Python bindings, OpenOrb <a



href="ReferenceDocuments.html#RD16">[RD16]</a>for 

  some code generation tools.</h3>

<h3>ACS provides a C++, a Java, and a Python Container Implementation. The three 
  implementations differ in the features offered because C++, Java and Python 
  applications have different requirements, as described in <a



href="ReferenceDocuments.html#RD33">[RD33]</a>. Features from one type of component 
  can be implemented also for the other type, if the requirement arises. </h3>

<h3>ContainerSercices and ComponentLifeCycle interfaces are NOT defined as IDL 

  interfaces, since they are used only in the internal communication between Components 

  and Containers and there are language specific differences.</h3>

<h3>Basic functionality provided by ContainerServices is:</h3>

<ul>

  <li>getName()</li>

  <li>getComponent(name)</li>

  <li>findComponent(type)</li>

  <li>releaseComponent(name)</li>

  <li>getCDB()</li>

  <li>getThreadManager() </li>

</ul>

<p>For more details see the implementation and detailed design documentation. 
  In particular there are various flavours of the getComponent() interface, some 
  described here after.</p>
<h3>Specific Containers can provide specialised subclasses of ContainerServices 

  with additional features. Components aware of this additional functionality 

  can make use of it, while other Components would ignore it transparently.</h3>

<h3>Normally a Container will provide each Component with a specific instance 

  of ContainerServices that contains specific context information, but this is 

  left to the responsibility of the Container. Therefore the life cycle of the 

  ContainerServices objects is left to the complete control of the Container.</h3>

<p>--------------------------------------------------</p>

<h3>Characteristic Components are a subclass of Components tailored to the implementation 
  of objects that describe collections of numerical (typically physical) quantities. 
  They have been designed in particular to represent Control System objects with 
  monitor and control points or objects with state and configurable parameters. 
  In particular Characteristic Components are described using a 3 tier naming 
  for the logical model <a href="ReferenceDocuments.html#RD03">[RD03]</a> <a href="ReferenceDocuments.html#RD04">[RD04]</a> 
  <a



href="ReferenceDocuments.html#RD05">[RD05]</a>: </h3>

<ul type=disc>

  <li style='     '>Characteristic Component</li>

  <li style='     '>Property </li>

  <li style='     '>Characteristic</li>

</ul>

<h4>Characteristic Component - Instances of classes identified at design level 

  in the <st1:City><st1:place>ALMA</st1:place></st1:City> system, with which other 

  components of the system interact, are implemented as Characteristic Components. 

  In particular, at control system level, Characteristic Component is the base 

  class used for the representation of any physical (a temperature sensor, a motor) 

  or logical device in the control system. Higher level applications can use Characteristic 

  Components to implement any Component that has configurable values representing 

  numerical quantities.</h4>

<h4>Property - Each Characteristic Component has 0..n Properties that are monitored 

  and controlled, for example status, position, velocity and electric current. 

</h4>

<h5>Properties can be read-only or read/write. If a read/write property cannot 

  read its value back (for example it is associated with a write-only physical 

  device), it caches the last written value and returns this upon read request. 

  This implementation is mandatory and must be documented in the property documentation. 

</h5>

<h5>Properties can represent values using a limited set of basic data types: </h5>

<ul type=disc>
  <li style='     '><i>long</i>, <i>longLong</i> and <i>uLongLong</i> for integers 
  </li>
  <li style='     '><i>double</i> for floating point numbers </li>
  <li style='     '><i>string</i> for strings. </li>
  <li style='     '><i>pattern</i> to handle patterns of bits, typically from 
    hardware devices </li>
  <li style='     '><i>enum</i> for enumerations like states. This includes a 
    boolean TRUE/FALSE enumeration.</li>
  <li style='     '></li>
  <li style='     '><i>sequence&lt;scalar property&gt;</i> of one of the previously 
    defined scalar property types. A Sequence&lt;scalar property&gt; is a sequence 
    (in CORBA IDL terms) of properties of a given scalar type, i.e. each item 
    in the sequence is a complete property of the given scalar type. It is implemented 
    as an IDL Sequence of the scalar property type. For example a <i>sequence&lt;long&gt;</i> 
    allows manipulating a group of properties of type long. Each item in the list 
    can be assigned to a long property object and manipulated (reading characteristics 
    and value) independently from the others.</li>
  <li style='     '><i>scalarTypeSeq</i> of one of the previously defined scalar 
    types. A <i>scalarTypeSeq</i>is a property type that contains as value an 
    array of values handled by the corresponding scalar type. For example, a <i>longSeq</i> 
    is a property type with a single set of characteristics that apply to an array 
    of integers. It is a single property and its value is an array of values. 
    With respect to <i>sequence&lt;scalar property&gt;</i>, <i>scalarTypeSeq</i> 
    is much more efficient for transporting big tables of data. <b><i>(Not all 
    types implemented for ALMA)</i></b></li>
  <li style='     '><font face="Arial, Helvetica, sans-serif" size="-1">complex 
    for handling complex numbers <b><i>(Implementation not foreseen for ALMA)</i></b></font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1">structures built with 
    properties of the other basic types. Since structures introduce a significant 
    increase of complexity in the handling libraries, they will be implemented 
    last and only if a clear need arises.<b><i>(Implementation not foreseen for 
    ALMA)</i></b></font></li>
</ul>
<h5>The selection of a limited set of type is motivated by the need of avoiding 
  implementing the same code for many different types and conversion problems 
  between similar types (like short, int and long). Also, nowadays saving a couple 
  of bytes using a short instead of a long usually introduces performance problems 
  (CPUs now always works with longs and every operation on a short requires a 
  conversion to long)</h5>

<h4>Characteristic - Static data associated with a Characteristic Component or with 

  a Property, including meta-data such as <i>name, description, version </i>and<i> 

  dimensions</i>, and other data such as <i>units, range</i> or <i>resolution. 

  </i>Each Characteristic Component or each Property has 0..n Characteristics.<br>

  An initial list of Characteristics for Characteristic Components and Properties has 

  been agreed  and more details are given in the design documentation: </h4>

<ul type=disc>

  <li style='     '>Characteristic Components and Properties: Name, Description, Version 

    and URI of extended documentation, where the last is optional and would point 

    to documentation generated automatically from the source code. </li>

  <li style='     '>Read-only and Read/Write Properties: default values, range, 

    units, format, resolution </li>

</ul>

<h4>The following diagram shows an architectural class diagram for the Characteristic 

  Component - Property - Characteristic pattern</h4>

<p><img border=0 width=640 id="_x0000_i1025"



src="Images/Class_Diagram-Distributed_Object-ACS_Simple_CharacteristicComponent-Property-Characteristic_model.png"></p>

<p align=center style='text-align:center'><i>Figure 3.1: Characteristic Component - 

  Property - Characteristic class diagram</i></p>

<ul type=disc>

  <li style='     '>The diagram shows the classes that have an IDL public interface 

    and is not concerned with actual implementation of the servants that realize 

    these interfaces.</li>

  <li style='     '>A <b>CharacteristicModel</b> base interface class groups methods 

    and attributes common to both Property and Characteristic Component. In particular, both have a 

    common set of Characteristics and provide the related access methods. </li>

  <li style='     '>A <b>Characteristic Component</b> can reference other <b>Characteristic Components</b>, to build a hierarchical 

    structure </li>

  <li style='     '><b>Properties</b> are always contained into a <b>Characteristic 

    Component</b>. This means that a <b>Characteristic Component</b> can contain 

    0 or many <b>Property</b> instances, while a property is always contained 

    in one and only one <b>Characteristic Component</b>. The <b>Property</b> class 

    provides a method to retrieve the reference to the Characteristic Component 

    that contains it. </li>

  <li style='     '>From the base <b>Property</b> class, subclasses for each read 

    only and read/write types are derived. This is represented in the diagram 

    by the ROProperty&lt;type&gt; and RWProperty&lt;type&gt; parametrized classes. 

    From an architectural point of view, RWProperty&lt;type&gt; classes are subclasses 

    of the corresponding ROProperty&lt;type&gt;. </li>

  <li style='     '>The lower part of the diagram (white class boxes) shows how 

    applications will inherit from the base classes provided by ACS. The example 

    shows classes used for the implementation of the control system. </li>

  <li style='     '>This diagram is sufficient and correct at architecture level. 

    At design level, we have introduced some intermediate class levels to improve 

    the modularity of the code. These intermediate classes are in any case hidden 

    to the users, making the actual structure between the Property class and the 

    implementation of RO and RW properties an implementation detail.</li>

</ul>

<h4>At the servant’s implementation level, the classes implementing the Property 

  interfaces are responsible for the actual interfacing with the hardware or, 

  more in general, to retrieve/calculate the value for the numerical entities. 

  In order to decouple as much as possible the implementation of Property classes 

  and the access to different kinds of data sources, we have parametrized the 

  default Property implementation provided by ACS with a DevIO parameter, as shown 

  in the following class diagram. A DevIO implementation is responsible only for 

  reading/writing the Property’s value from a specific device (memory location, 

  CAN bus, Socket connection, serial port, database….), therefore in most cases 

  access to a new kind of device can be implemented just by implementing a new 

  DevIO class. In more complex cases or for performance optimization it may be 

  necessary to re-implement the entire Property interface. </h4>

<p><img border=0 width=640 id="_x0000_i1026"



src="Images/Class_Diagram-Distributed_Object-Property_Servant_Implementation.png"></p>

<p align=center style='text-align:center'><i>Figure 3.2: Property Servant Implementation 

  class diagram</i></p>

<h4>Another common strategy to handle the case where a data source produces simultaneously 

  the values for many Properties consist in mapping the Properties onto memory-based 

  DevIOs and let a parallel execution thread update all memory locations from 

  the data collected with one single access to the data source.</h4>

<h4>The Characteristic Components - Properties - Characteristics 3 tier logical 

  model is very well established in the community of Control Systems for Physics 

  Experiments <a href="ReferenceDocuments.html#RD03">[RD03]</a> <a



href="ReferenceDocuments.html#RD04">[RD04]</a> <a



href="ReferenceDocuments.html#RD05">[RD05]</a>, where the name Device is used 

  to identify what we call here Characteristic Component. We prefer to adopt the 

  more generic name, as specified in <a href="ReferenceDocuments.html#RD01">[RD01 

  - 13.1.1 Characteristic Components and Commands]</a>, because the usage of the 

  ACS is not limited to the realm of the Control System, as in the case of the 

  mentioned references. It provides instead generic services for the development 

  of the whole ALMA software. Proper Device classes are implemented by the Control 

  System development team based on Characteristic Components. </h4>

<h3>The Characteristic Component model is based on CORBA: </h3>

<h4>A Characteristic Component is a CORBA object </h4>

<h4>A Property is a CORBA object. A class hierarchy with Property class as root 

  implements the basic read-only and read/write versions for the predefined types. 

  This hierarchy provides standard IDL interfaces that shall be used by all clients 

  to access Properties. On the implementation (servant) side, specific subclasses 

  will provide polymorphic access to specific implementations like 'logical', 

  'simulated', 'CAN', 'RS232', 'Digital IO' and so on. </h4>

<h4>Public interfaces to Characteristic Components and Properties are defined as CORBA 

  IDL.</h4>

<h4>Characteristics of Characteristic Components and Properties can be accessed through 

  access methods (as shown in figure) and through a generic value = get_characteristic_by_name(name) 

  type of interface at run time. The interface of properties is defined by their 

  IDL and the IDL is the same independently from the implementation (logical, 

  CAN...). But specific implementations will have also specific characteristics. 

  For example a CANLong property has a CANID characteristic. This means that from 

  the property's IDL there is no way to retrieve the CANID using CORBA calls. 

  We provide then a generic interface that can be used to retrieve any characteristic 

  just querying by name. This allows accessing specific Characteristics, like 

  the CAN ID for properties related to CAN monitor points that are not defined 

  in the generic property IDL but are instead implementation specific.</h4>

<h3>The configuration parameters for all Characteristic Components, i.e. the initial 

  values for Properties control values and all Characteristics for Properties, 

  are persistently stored in the Configuration Database <a



href="ReferenceDocuments.html#RD01">[RD01 - 4.2.1. Configuration Database]</a>. 

  See the section on Configuration Database architecture.</h3>

<h3>Characteristic Components may have a state. Specific Characteristic Components 
  can have additional sub-states. <a href="ReferenceDocuments.html#RD01">[RD01 
  - 13.1.2 Standard Methods]</a> <a href="ReferenceDocuments.html#RD01">[RD01 
  - 14.1.13 States]</a>. </h3>
<h3><b><font face="Arial, Helvetica, sans-serif" size="-1">Note: </font></b><font face="Arial, Helvetica, sans-serif" size="-1">A 
  standard state machine and standard state transition commands could be defined. 
  <i><b>(Implementation not foreseen for ALMA).</b></i></font></h3>
<h3>JavaBeans wrap CORBA objects on the client side. Standard Rapid Application 

  Development (RAD) tools like Eclipse<a href="ReferenceDocuments.html#RD35">[RD35]</a> 

  are used to handle them. Given the IDL interface of a Characteristic Component, 

  a code generator automatically produces the corresponding JavaBean. In this 

  way the developer has libraries that provide him direct support for ACS concepts 

  like Characteristic Component/Property/Characteristic, Monitors, and Event and 

  Notification System.</h3>

<h3>ACS also provides a generic IDL simulator (see section IDL Simulator) to simulate 
  an entire Component.</h3>

<h3>If an application wants to provide a more sophisticated level of simulation 
  (for example simulating interrelations between the values of properties), a 
  specific simulated device should be implemented in parallel to the real device. 
  Switching from the real to the simulated device is handled in the configuration 
  of the Manager (see Management and Access Control section), telling it to start 
  a different implementation of the same device's CORBA interface.</h3>
<h3><font face="Arial, Helvetica, sans-serif" size="-1"><b>Note: </b>As an extension, 
  ACS could provide support for simulation<a href="ReferenceDocuments.html#RD01">[RD01 
  - 3.3.4. Simulation]</a> at Property level. All properties that access hardware 
  can be switched in simulation by setting TRUE a simulation characteristic in 
  the configuration database. After this, they behave like &quot;logical properties&quot;. 
  This provides basic simulation capabilities. <i>(Implementation not foreseen 
  for ALMA).</i></font></h3>

<h3><a name=CommandHandling>Direct Value Retrieval</a></h3>

<h4>The Property classes provide get() and, in case of writeable Properties, set() 

  methods that can be used to directly access the value of the property from clients 

  <a href="ReferenceDocuments.html#RD01">[RD01 - 4.1.1 Direct value retrieval]</a>. 

  Both synchronous and asynchronous get() and set() methods are provided.</h4>

<h4>Value setting is done using set() property methods. These methods can be called 

  by applications or by specifically designed GUIs. CORBA Dynamic Invocation Interface 

  allows to write generic applications and GUIs (like the <i>Object Explorer</i>) 

  that are capable of resolving dynamically at run time the structure of Characteristic Components and call set() methods to set the value of Properties <a



href="ReferenceDocuments.html#RD01">[RD01 - 3.2.3. Value setting]</a>.</h4>

<h4>DevIO specialization is used to implement properties accessing specific hardware 

  devices, like CAN, RS232, GPIB. CAN properties will always directly access the 

  hardware on the CAN bus at direct value retrieval and not use cached values.</h4>

<h3><a name=Events></a>Value Retrieval by Event</h3>

<h4>The Characteristic Component provides a method to create a monitor object 

  for a Property, able to trigger events on Property change or periodically. A 

  callback will be connected to the event and will be called by the monitor object 

  when the specified event occurs<a



href="ReferenceDocuments.html#RD01">[RD01 - 13.1.4. Events]</a>. Triggered events 

  are delivered directly to the registered object via the callback mechanism in 

  a point-to-point fashion. The value retrieval by event is then very well suited 

  for providing timely feedback to control applications.</h4>

<h4>Events can be generated on any change of value<a



href="ReferenceDocuments.html#RD01">[RD01 - 4.1.3 Rate]</a>. </h4>
<h4><b><font face="Arial, Helvetica, sans-serif" size="-1">Note:</font></b> <font face="Arial, Helvetica, sans-serif" size="-1">Other 
  conditions, for example any write, value increase/decrease, value less or greater 
  than set-point could also be included at a later stage. <i>(Implementation not 
  foreseen for ALMA)</i></font></h4>

<h4>Timed or periodic events can be generated as follows:</h4>

<ul type=disc>

  <li>Periodic, at a specific interval rate <a href="ReferenceDocuments.html#RD01">[RD01 

    - 4.1.3 Rate]</a> </li>

  <li>Periodic, at a specific interval rate, synchronized with an absolute array 

    time <a href="ReferenceDocuments.html#RD01">[RD01 - 4.1.5 Values at given time]</a>. 

    This also allows periodic events aligned with the monitoring rate. For example, 

    a 1-second rate generates events on the 1-second mark, 5-second rate on the 

    5-second mark and so on.</li>

</ul>

<p align=center style='text-align:center'><img border=0



width=636 height=614 id="_x0000_i1027" src="Images/Class_Diagram-Event_System-Event_Architecture.png"></p>

<p align=center style='text-align:center'><i>Figure 3.3: Value Retrieval by Event: 

  ACS Monitors</i></p>

<h4>All events will be time stamped with the time at which the value has been 

  acquired (as opposed to the time of delivery of the event). Timed events will 

  be triggered &quot;timers&quot; such that the requested time is the time of 

  acquisition of the value, and not the time of delivery which depends on the 

  network characteristics.</h4>

<h4>The monitor class provides methods to suspend, resume and destroy the monitor 

  itself. </h4>

<h4><b><font face="Arial, Helvetica, sans-serif" size="-1">Note: </font></b><font face="Arial, Helvetica, sans-serif" size="-1">CAN-Properties 
  will have to implement notification on change also for CAN monitor points although 
  CAN monitor points do not provide a specific support via HW or in the drivers. 
  This can/should be done via polling. If there are clients registered on events 
  on change, an ACS monitor is used to poll and to generate events in case of 
  change of the value of the monitor point. The poll rate is defined by the characteristic 
  change frequency. The polling frequency determines the time resolution of the 
  event-on-change.<i> (implementation not foreseen for ALMA)</i></font></h4>
<h4><font face="Arial, Helvetica, sans-serif" size="-1"><b>Note: </b>For performance 
  optimization, the final implementation will not leave to the single Characteristic 
  Component Properties the responsibility of managing timers, but a local centralized 
  manager will take care of that, transparently to client applications. More details 
  will be given in the ACS design. <i>(implementation not foreseen for ALMA)</i></font></h4>
<h4><font face="Arial, Helvetica, sans-serif" size="-1"><b>Note: </b>A particular 
  case is a Characteristic Component State Machine. A State Machine class is a 
  Characteristic Component and the current state is represented by a State Property. 
  This State Property can fire events whenever the state changes to allow external 
  objects to monitor it. <i>(implementation not foreseen for ALMA)</i></font></h4>

<h3>Supported implementation languages</h3>

<p>&nbsp;The Characteristic Component / Property /characteristic pattern is implemented 
  in C++ and in Java and Python</p>
<p><i><b><font face="Arial, Helvetica, sans-serif" size="-1">Note: Java and Python 
  implementations are not complete and contain now all and only the features used 
  in ALMA.</font></b></i></p>

<p>--------------------------------------------------</p>

<h3>ACS Java Components provide explicit support for the transparent serialization 

  of instances of entity classes <a



href="ReferenceDocuments.html#RD01">[RD01 - 3.3.2. Serialization]</a>. See the 

  section on “Serialization”.</h3>

</body>

</html>

