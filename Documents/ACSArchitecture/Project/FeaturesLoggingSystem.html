<html>

<head>

<meta http-equiv=Content-Type content="text/html; charset=windows-1252">

<link rel=Edit-Time-Data href="FeaturesLoggingSystem_files/editdata.mso">

<title>FeaturesLogging</title>

<style><!--

.Normal

	{font-size:12.0pt;

	font-family:"Times New Roman";}

.SpellE

	{}

.GramE

	{}

-->

</style>

</head>

<body lang=EN-US link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">

<h2><a name=LoggingSystem>Logging System</a></h2>

<p>Logging is a general mechanism used to store any kind of status and diagnostic 

  information in an archive, so that it is possible to retrieve and analyze it 

  at a later time. </p>

<h3>ACS Logging System is based on CORBA Telecom Log <span class=GramE>Service</span><a



href="ReferenceDocuments.html#RD14">[RD14]</a> and on the ACS Event

and Notification System architecture</h3>

<h3>Applications can log information at run time according to specific formats 

  in order to <span class=GramE>record</span><a



href="ReferenceDocuments.html#RD01">[RD01 - 6.2.1 Logging]</a>: </h3>

  <ul type=circle>

    <li>The execution of actions </li>

    <li>The status of the system </li>

    <li>Anomalous conditions</li>

  </ul>

<h3>Logging includes for example: </h3>

 <ul type=circle>

    <li>Device commands - reception and execution of commands from devices <a



      href="ReferenceDocuments.html#RD01">[RD01 - 14.1.1 Logging of commands]</a> 

    </li>

    <li>Debugging - Optional debugging messages, like notification of entering/leaving 

      specific code sections. </li>

    <li>Unrecoverable programmatic errors </li>

    <li>Alarms - change of status in alarm points </li>

    <li>Miscellaneous log messages. Applications can log events regarded as important 

      to archive, for example receivers changing frequency, antennas set to new 

      targets etc.</li>

  </ul>

<h3>Each log consists of an XML string with <span class=GramE>timestamp</span><a



href="ReferenceDocuments.html#RD01">[RD01 - 6.2.1 Logging]</a>, information on 
  the object sending the log and its location in the system, a formatted log message. 
   Context specific information is entered as (name, value) pairs. The XML format 
  is defined in the Log Markup Language (<span class=SpellE>logMl</span>) XML 
  Schema.</h3>
<h3>High level logs (for example logs directed to operators) are &quot;type safe 
  logs&quot; defined in XML files, in a way analogous to error code specifications.</h3>
<ul>
  <li>The XML specification files allow to define context value pairs.</li>
  <li>Code generation is used generate type safe helper classes in all supported 
    languages from the XML specification files. </li>
  <li>Getters and setters are generated for all context value pairs. </li>
  <li>Each  type safe log specification is associated in the XML specification 
    files to documentation providing help description of the error and of the 
    recovery procedures to be taken<a



href="file:///G:\Eso\Alma\Acs\Acs\acsdoc\Model\Project\ReferenceDocuments.html#RD01">[RD01 
    - 6.3.5 Configuration]</a>.</li>
  <li>Help handling is implemented as links to XML help pages. </li>
</ul>
<h3></h3>
<h3>Low level logs can be free format and are not required to be specified in 
  XML type safe definitions.</h3>
<h3>The logging system is centralized so that eventually the logs are archived 

  in a central log.</h3>

<h3>Log clients can subscribe to the Log Notification Channel. The permanent Log Archive 

  <a href="ReferenceDocuments.html#RD01">[RD01 - 6.2.2 Persistency]</a> (an RDBMS) 

  is essentially such a client and its implementation is left to the application.</h3>

<h3>Applications log data using the API provided by ACS. This API provides methods 

  for logging information of the different kinds specified above. A C++, Java 

  and Python APIs are provided. The APIs are based on the standard logging facilities 

  provided by the implementation language, <span class=SpellE>when</span> available:</h3>

<ul type=disc>

  <li>the C++ API is based on the ACE Log</li>

  <li>the Java API is based on the J2SE Java Logging</li>

  <li>the Python API uses a generic ACS CORBA Logging service</li>

</ul>

<h3>Logs can be cached locally on the machine where they are generated by a logging 

  proxy and transmitted to the central log on demand or when the local buffer 

  reaches a predefined size. High priority logs are not cached but are transmitted 

  to the central log immediately. The main purpose of caching is to reduce network 

  traffic.</h3>

<p align=center style='text-align:center'><img border=0 width=640 id="_x0000_i1025" src="Images/Class_Diagram-Logging_System-Logging_Architecture.png"></p>

<p align=center style='text-align:center'><i>Figure 3.9: Logging System</i></p>

<h3>In particular the C++ API is optimized for performance and reduced network 
  traffic and implements caching.</h3>
<h3>Up to ACS 6.0.3, logs are directly generated in XML format on the publishing 
  side and transported as XML strings inside the logging service. With respect 
  to a binary transport based on IDL structures, this has the advantage of transporting 
  logs in a human readable format. But there is a performance price to pay: XML 
  strings are normally much bigger than the binary representation of the fields 
  and there is the need to process them to generate the XML representation on 
  the publisher side and to parse it on the consumer side.</h3>
<h3>We have therefore implemented a binary transport, where logs are propagated 
  as IDL structures:</h3>
<ul>
  <li>No parsing is done on the publishing side</li>
  <li>Consumers can generate exactly the same XML as from the previous implementation, 
    in a way transparent to the user.</li>
  <li>The Archive can store the logs without having to parse their XML representation.</li>
</ul>
<h3>The new binary transport can now coexist with the XML transport. We are measuring 
  and comparing the performance of the two implementations to quantify the advantages 
  coming from the binary transport. Once this assessment will be complete we will 
  phase out the worst mechanism (that should be XML transport, unless we hit unexpected 
  situations). </h3>
<h3>The log API allows for filtering based on the log level, so that log entries 
  with low priority do not get logged. The filter can for example be set to log 
  or not log debug messages. The filter level is determined at run time and can 
  be set through a command or through external configuration files.</h3>

<h3>The API includes support classes (logging guards) to prevent message flooding. 
  It allows the application developers to control the logging of repeated error 
  messages. We have decided NOT to implement an automatic mechanism capable of 
  detecting if the same message is being logged at too high rate, because we think 
  that a reliable implementation is very difficult to achieve and would in any 
  case heavily impact performance. But this means that still unaware developers 
  can flood the system with logs. We will have to assess later if it will be necessary 
  to implement a more sophisticated mechanism.</h3>

<h3>A generic CORBA ACS Logging Service is available for any CORBA application 
  to log even if no specific API is available. The IDL interface of the CORBA 
  ACS Logging Service provides, on top of the standard CORBA Telecom Logging Service, 
  methods for each type of log defined in ACS. Values for the relevant log fields 
  are passed as parameters and the Service takes the responsibility of formatting 
  them in appropriate transport structures and sending them to the CORBA Telecom 
  Logging.</h3>

<h3>A user interface (logging GUI client) allows to monitor the logs while they 
  are produced, in quasi-real-time, and to browse the historical database off-line. 
  It provides filtering and sorting capabilities <a



href="ReferenceDocuments.html#RD01">[RD01 - 6.2.3 Filtering]</a>. It provides 
  searching capabilities. It is useful to filter logs by inclusion and exclusion 
  and logical combinations based on any logging field, like: </h3>

<ul type=disc>

    <li>time </li>

    <li>process that generated the log </li>

    <li>name of item logged </li>

    <li>all things from a device node down to the leaves </li>

    <li>type of item logged</li>

</ul>

<h3>The log monitor is implemented as a Java application and it uses the ALMA 
  Archive interfaces for accessing the historical logs in the ALMA Archive.</h3>

<h3>If the Logging System crashes or cannot keep up with log requests, subsystem 

  performance should not be affected but the log system should record that logs 

  have been lost. The log system will run with lower priority than normal application 

  processes, in particular on the control system.</h3>

<h3>The logging system is NOT meant to allow &quot;re-run&quot; observing sequences 

  from log messages, but to allow analyzing a posteriori the exact behavior of 

  the system. Since the system will never be the same twice, it will never be 

  possible to execute twice exactly the same set of actions. The task of making 

  observing sequences reproducible must be assigned to the higher level observation 

  scheduler and the logging system has to be used to understand what eventually 

  did not go as planned in the observing sequence and to fix the identified problems.</h3>

<h3>Debugging logs are always present in code. Multi-level output of debugging 

  logs can be switched on/off by setting the priority for log filtering. No compile 

  time debugging flags are necessary, except when strict real time concerns apply.</h3>

</body>

</html>

