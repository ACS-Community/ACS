<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> 

<html>

<head>

<meta http-equiv=Content-Type content="text/html; charset=windows-1252">

<link rel=Edit-Time-Data href="FeaturesCDB_files/editdata.mso">

<title>FeaturesCDB</title>

<style>

</style>

<meta name=Template content="C:\Program Files\MSOffice\Office\html.dot">

</head>

<body lang=EN-US link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">

<h2><a name=DistributedObjectConcept>Configuration Database</a></h2>

<h3>The configuration parameters for all Components and, in particular, for all 

  Characteristic Components, i.e. the initial values for Properties values and 

  all Characteristics for Properties, are persistently stored in the Configuration 

  Database <a href="ReferenceDocuments.html#RD01">[RD01 - 4.2.1. <span



class=GramE>Configuration Database]</span></a><span class=GramE>.</span> Any application 

  can make use of the Configuration Database to get access to configuration information. 

</h3>

<h3>There are 4 different issues related to the problems addressed by the CDB:</h3>

<p> 1) <span class=GramE>input</span> of data by the user<br>

  System configurators define the structure of the system and enter the configuration 

  data. Easy and intuitive data entry methods are needed.</p>

<p> 2)<span>&nbsp;</span><span class=GramE>storage</span> of 

  the data<br>

  The configuration data is kept into a database.</p>

<p> 3) <span class=GramE>maintenance</span> and management of the data (e.g. 

  versioning)<br>

  Configuration data changes because the system structure and/or the implementation 

  of the system’s components changes  with time and has to be maintained under 

  configuration control.</p>

<p> 4) <span class=GramE>loading</span> data into the ACS Containers<br>

  At run-time, the data has to be retrieved and used to initialize and configure 

  the Components.</p>

<p>The main objective of the CDB Architecture is to keep these 

  4 issues as decoupled as possible so that:</p>

<ul>

  <li> We can develop them separately, in space and time, according to the project 

    priorities and the availability of resources.</li>

  <li> We can eventually use different technologies</li>

  <li> We can, in particular, support multiple data storage mechanisms (like ALMA 

    Archive, RDBMS and XML files) in different environments (development, testing, 

    final running system).</li>

</ul>

<h3>The high-level architecture is based on three layers:</h3>

<p> 1) The Database Itself<br>

  <span class=GramE>It</span> is the database engine we use to store and retrieve 

  data.</p>

<p> 2) The Database Access Layer (DAL) is used to hide the actual database 

  implementation from applications, so that it is possible to use the same interfaces 

  to access different database engines, as described in the requirements and discussed 

  in the following sections.</p>

<p> 3) The Database <span class=GramE>Clients,</span> store and retrieve data 

  from the database using only the interfaces provided by the DAL.<br>

  Data Clients, like containers, Managers and Components retrieve their configuration 

  information from the Database and are involved in issue 4.<br>

  On the other hand, CDB Administration applications are used to configure, maintain 

  and load data in the database using again interfaces provided by the DAL layer. 

  They are involved in issue 1 and 3 and will be possibly using DAL interfaces 

  different from the ones used by the Data Clients, as will be discussed later 

  on.<br>

  <b><i>Notice that Data Clients need only data retrieving and not data change 

  functions.</i></b></p>

<p><img border=0 width=640 id="_x0000_i1025"



src="Images/CDBLayers.png"></p>

<p align=center style='text-align:center'><i>Figure 3.4: Configuration Database 

  architectural layers</i></p>

<h3>A Database Loader application is used to manipulate database description files 

  and load them into the Database using the DAL administrator interfaces. Database 

  Description Files are XML files and XML Schemas are used to define classes of 

  database entities, allowing to use inheritance and to define default values. 

  The Database Loader also takes care of validating the data, to make sure that 

  only valid and consistent data is actually loaded into the database. For example, 

  the following inconsistencies should be spotted and reported:</h3>

<ul>

  <li> missing property or characteristic</li>

  <li> undefined values, default will be used</li>

  <li> defined values that are not used elsewhere</li>

</ul>

<h3>When a Characteristic Component is instantiated, it configures itself according 

  to the configuration stored in the Configuration <span class=GramE>Database</span><a



href="ReferenceDocuments.html#RD01">[RD01 - 3.3.2. <span class=GramE>Serialization]</span></a><span



class=GramE>.</span></h3>

<h3>The implementation of the Configuration Database is hidden in a Configuration 

  Database Access API to allow switching among alternative <span



class=GramE>implementations</span><a href="ReferenceDocuments.html#RD01">[RD01 

  - 4.2.2 Database Design]</a>. </h3>

<h3>The reference implementation is based on XML files and a Java application 

  loads and parses the XML files. Files are validated at run time and a separate 

  CDB checker can be used to validate offline CDB XML files without the need of 

  loading them in a &quot;live&quot; database.</h3>

<h3>In ALMA, configuration information is stored in the Telescope and Monitoring 
  Configuration Data Base (TMCDB). This is based on the Oracle RDBMS. Archive, 
  Control and ACS subsystems are responsible for the implementation of the Configuration 
  Database Access API on top of the TMCDB, throught the implementation of a specific 
  Component. This implementation includes round-trip tools to convert CDB instances 
  between the XML reference implementation and the TMCDB. In this way it is possible 
  to develop locally with the XML implementation and transparently migrate to 
  the final system based on the ALMA Archive and TMCBD. <i>(Being implemented).</i></h3>

<h3>All Components have access to the Configuration Database during construction/initialization 

  and later during their operational life. While accessing the CDB is optional 

  for normal components, <span class=SpellE>Characteristic Components</span> must 

  retrieve their configuration information from there.<br>

  At a higher level, the Container responsible for the Components (see Container 

  package) provides an interface to set the reference to the configuration database 

  used. In this way it is also easy to switch between different databases at startup 

  time. </h3>

<ul>

  <li> In order to allow switching between different instances of Configuration 

    Database, the reference to the DAL used by each Component is provided as a 

    common service by the Container inside which the Component lives.</li>

  <li> Whenever a Container is started, it gets in touch with a specified DAL 

    instance.</li>

  <li> By default, if nothing else is specified, this is the DAL for Central Configuration 

    Database and is obtained by requesting the reference to the Manager.</li>

  <li> Otherwise, the container can be instructed to use explicitly another DAL 

    instance, apt to work with a Configuration Database Engine of one of the supported 

    types.</li>

</ul>

<p><img border=0 width=640 id="_x0000_i1026"



src="Images/Class_Diagram-Configuration_Database-Configuration_Database.png"></p>

<p align=center style='text-align:center'><i>Figure 3.5: Configuration Database</i></p>

<h4>We define Characteristics as statically defined in the Configuration Database. 
  This means that is possible to change their value only by changing the configuration 
  database and reloading just the corresponding <span



class=GramE>Characteristic Components</span><a href="ReferenceDocuments.html#RD01">[RD01 
  - 14.1.9 Dynamic configuration]</a>. This means that they cannot be used for, 
  e.g., calibrations that change at run time. With this definition, calibration 
  values that change at run time should be implemented as Properties, not as Characteristics. 
  &quot;Static&quot; calibration values, for example measured by <span class=GramE>an 
  engineer and</span> not supposed to change for months can be Characteristics. 
  Characteristics can change with time or can change with the context. </h4>
<h4><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF">Note: 
  It is possible to implement also a more dynamic mechanism, but we have not identified 
  a requirement for ALMA. This can be done transparently at a later time extending 
  the Property class with methods to change the value of characteristics but this 
  has not been considered in the first design to avoid increasing the complexity 
  of the system.<b> (Implementation not foreseen for ALMA)</b></font></h4>
<h3><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF">Note: 
  A Visual Configuration Tool (CT) can be implemented on top of the Database Loader. 
  This can be completely independent of all other aspects of CDB and therefore 
  can be implemented at a later stage. ALMA configuration data is edited using 
  the TMCDB tools and therefore no requirement for such Visual Configuration Tool 
  has been recognized. The basic features are described hereafter for a possible 
  future implementation <i>(Implementation not foreseen for ALMA)</i></font></h3>
<ul>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> The 
    CT allows to visually edit the structure/schema of the configuration database 
    and to fill in the values inside the instantiated database.</font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> The 
    CT supports expressions and variables.  </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> Allows 
    switching between different views (think of Eclipse): source, members, hierarchy, 
    editions, and visual composition. Like in Eclipse, there should be wizards 
    that help create new structures, but the structures can be created also manually. 
    Structures can be changed using connections and <span class=SpellE>drag&amp;drop</span>. 
    </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> An 
    existing CDB can be parsed and displayed visually, for easier re-engineering. 
    </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> There 
    is a tree view in CT that uses <span



class=SpellE>colour</span> codes and icons to define classes or properties that 
    are abstract, inherited, calculated (from expressions) and imported from templates.</font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> A “spreadsheet 
    view” is used for mass population of configuration data. The normal approach 
    is to define the structure with the tools just described, and then to write 
    a substitution file, which contains data in compact form in a table that is 
    similar to a spreadsheet. Ideally, it should be straightforward to create 
    such a substitution file in a spreadsheet program and use it from there directly. 
    </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="-1" color="#0000FF"> The 
    development of CT will be based on existing tools. For example it could be 
    an Eclipse <span class=SpellE>plugin</span>.</font></li>
</ul>

</body>

</html>

