#!/bin/bash

#################################################################################
#
# This script is used to monitor the performance of the ACS logging system
#
# @author Steve Harrington
# @date 04-11-2007
#################################################################################

##########################################################################################
# Function definitions used later in this script.
##########################################################################################

# definition of a function to print the usage statement for this script
printUsageAndExit ()
{
	echo ""
	echo "Usage: $0 [OPTIONS] <numLogsToSend> <numComponents> <delayBetweenLogs>";
	echo "  where: "
	echo "";
	echo "   <numLogsToSend> is the number of logs to publish per component.";
	echo "   <numComponents> is the number of publishing components to use.";
	echo "   <delayBetweenLogs> is the number of milliseconds to pause between sending each log.";
	echo "Options: "
	echo "   -j | --jlog: indicates whether to profile the jlog GUI (default if not specified is true)";
	echo "   -h | --help: print this usage message and exit."
	echo "   -d | --debug: print additional debugging info about this script to stdout."
	echo ""
	exit -1;
}
# definition of a function to echo (print to stdout) based on debug settings
debugPrint ()
{
	stringToPrint=$1

	if [ "$DEBUG_MODE" ] ;
	then
		echo " DEBUG: $1"
	fi;
}

# definition of a function to plot (using gnuplot) the data produced by the unix 'sar' command
genplot () 
{
	LOG_FILE_NAME=$1
	X_AXIS_POSITION=$2	
	Y_AXIS_POSITION=$3	
   ACS_TEMP=$4
	
	cat ./gnuplot.template | sed -e s@CHANGE_PNG@../doc/$LOG_FILE_NAME@g | sed -e s@CHANGE_LOGFILE@$ACS_TEMP/$LOG_FILE_NAME@g \
		| sed -e s@CHANGE_X_LOCATION@$X_AXIS_POSITION@g | sed -e s@CHANGE_Y_LOCATION@$Y_AXIS_POSITION@g \
		| sed -e s@CHANGE_GRAPH_TITLE@$LOG_FILE_NAME@g > $ACS_TEMP/gplot.tmp;
	gnuplot $ACS_TEMP/gplot.tmp;
}

# definition of a function to generate an html file summarizing the test results
genhtml () 
{
	if [ $PROFILE_JLOG ]
	then
		cat ./index.html.template | sed -e s/CHANGE_NUMBER_OF_LOGS/$1/g \
		 | sed -e s/CHANGE_HOST_NAME/$2/g \
		 | sed -e s/CHANGE_NUMBER_OF_SUPPLIERS/$3/g \
		 > ../doc/loggingPerformance.html;
	else
		cat ./index.html.template | sed -e s/CHANGE_NUMBER_OF_LOGS/$1/g \
		 | sed -e s/CHANGE_HOST_NAME/$2/g \
		 | sed -e s/CHANGE_NUMBER_OF_SUPPLIERS/$3/g \
		 | sed -e /jlog/d \
		 > ../doc/loggingPerformance.html;
	fi
}

##########################################################################################
# Script logic starts here...                                                            #
##########################################################################################

ORIGINAL_CMD_LINE=$@

#
# These will contain the parsing results (CL_XXX, CL = command line)
#
HELP=
DEBUG_MODE=
PROFILE_JLOG=

#
# These options can be recognized (longopts comma-separated. colon means argument is required)
#
LONGOPTS=help,jlog,debug
SHORTOPTS=h,j,d

#
# Run getopt (posixly_correct needed). We run twice:
# First run is simply to check the commandline for correctness
# Second run is does the real work and sets execution flags for this script, as appropriate
export POSIXLY_CORRECT=1

getopt -n `basename $0` -u -a -l $LONGOPTS $SHORTOPTS "$@" || printUsageAndExit;

set -- `getopt -u -a -l $LONGOPTS $SHORTOPTS "$@"` >& /dev/null ; 

#
# Iterate over getopt's output and set CL_XXX variables accordingly
#
while : 
do
	case "$1" in
	--help)  HELP=true ;;
	-h)      HELP=true ;;
	--jlog)  PROFILE_JLOG=true ;;
	-j)      PROFILE_JLOG=true ;;
	--debug) DEBUG_MODE=true ;;
	-d)      DEBUG_MODE=true ;;
	--) break ;;
	esac
	shift
done
shift

# must be unset! otherwise our custom export() function
# that is defined below doesn't get used by the shell
#
export POSIXLY_CORRECT=
unset POSIXLY_CORRECT

if [ "$HELP" ] ; 
then
   printUsageAndExit
fi

# first, verify that the script was invoked w/ the proper number of command-line arguments 
if [ $# -ne 3 ] ;
then 
	printUsageAndExit
fi

NUM_LOGS=$1
NUM_COMPONENTS=$2
DELAY=$3

# 'guesstimate' the amount of time we need to monitor the processes using the unix
# sar command by a rough rule of thumb that 100,000 logs requires ~ 4 minutes (240 secs)
SAR_RUN_TIME=`expr \( $NUM_LOGS / 100000 \) \* 240`
if [ 0 -eq $SAR_RUN_TIME ] ;
then
	SAR_RUN_TIME=240
fi

debugPrint "SAR Run Time will be: $SAR_RUN_TIME"
#read okToContinue

# start acs
export ACS_TMP=`pwd`/tmp
debugPrint "exported ACS_TMP: $ACS_TMP"

rm -rf $ACS_TMP
debugPrint "deleted old ACS_TMP: $ACS_TMP"

mkdir $ACS_TMP
debugPrint "made new ACS_TMP: $ACS_TMP"

export ACS_CDB=`pwd`
debugPrint "exported ACS_CDB: $ACS_CDB"

acsutilTATPrologue -l

# start the container(s)
i=1
while [ "$i" -le $NUM_COMPONENTS ]
do
	echo " Starting Container $i"
	acsutilAwaitContainerStart -cpp cppContainer$i >& $ACS_TMP/cppContainer$i.log
	i=`expr $i + 1`
done

# define some string constants which will be used in several places
ACS_LOG_SVC_LOG_FILE=acsLogSvc
LOGGING_SERVICE_LOG_FILE=loggingService
LOGGING_CLIENT_LOG_FILE=loggingClient
LOGGING_NOTIFY_SERVICE_LOG_FILE=loggingNotifyService
PUBLISHER_LOG_FILE=publisher
JLOG_LOG_FILE=jlog

# find the pids for all the processes that we're interested in monitoring
while [ -z "$logSvcPid" ]
do
	logSvcPid=`ps -ef | grep acsLogSvc | grep -v grep | gawk '{ print $2 }'`
done
debugPrint "logSvcPid is: $logSvcPid"
while [ -z "$loggingServicePid" ]
do
	loggingServicePid=`ps -ef | grep loggingService  | grep -v grep | gawk '{ print $2 }'`
done
debugPrint "loggingServicePid is: $loggingServicePid"
while [ -z "$loggingNotifyServicePid" ]
do
	loggingNotifyServicePid=`ps -ef | grep Notify_Service  | grep -v grep | grep LoggingNotify | gawk '{ print $2 }'`
done
debugPrint "loggingNotifyServicePid is: $loggingNotifyServicePid"
while [ -z "$loggingClientPid" ]
do
	loggingClientPid=`ps -ef | grep loggingClient  | grep -v grep | gawk '{ print $2 }'`
done
debugPrint "loggingClientPid is: $loggingClientPid"

# monitor the relevant processes using the unix 'sar' command
sar -x $logSvcPid 1 $SAR_RUN_TIME >& $ACS_TMP/$ACS_LOG_SVC_LOG_FILE.orig.log &
sar -x $loggingServicePid 1 $SAR_RUN_TIME >& $ACS_TMP/$LOGGING_SERVICE_LOG_FILE.orig.log &
sar -x $loggingNotifyServicePid 1 $SAR_RUN_TIME >& $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE.orig.log &
sar -x $loggingClientPid 1 $SAR_RUN_TIME >& $ACS_TMP/$LOGGING_CLIENT_LOG_FILE.orig.log &
if [ "$PROFILE_JLOG" ] ;
then
	# start jlog - using a separate script so that 'wait' will work later in this script (and not 
	# stall waiting on jlog to finish running) 
	./startJlog.sh $ACS_TMP
	while [ -z "$jlogPid" ]
	do
		jlogPid=`ps -ef | grep LogFrame  | grep -v grep | grep -v acsStartJava | gawk '{ print $2 }'`
	done
	debugPrint "jlogPid is: $jlogPid"
	#read okToContinue
	# start monitoring jlog process with 'sar' command
	sar -x $jlogPid 1 $SAR_RUN_TIME >& $ACS_TMP/$JLOG_LOG_FILE.orig.log &
fi


# start up the client which will send the appropriate number of logs
ClientJavaClass=LogPerformanceTestClient
echo " Sending logs"
acsStartJava -D NumLogs=$NUM_LOGS -D NumComponents=$NUM_COMPONENTS -D Delay=$DELAY \
	alma.perftest.client.$ClientJavaClass >& $ACS_TMP/clientOutput.log &

while [ -z "$publisherPid" ]
do
	publisherPid=`ps -ef | grep $ClientJavaClass  | grep -v grep | grep -v acsStartJava | gawk '{ print $2 }'`
done

debugPrint "publisherPid is: $publisherPid"
#read okToContinue

`sar -x $publisherPid 1 $SAR_RUN_TIME >& $ACS_TMP/$PUBLISHER_LOG_FILE.orig.log` &

# wait until all the background processes are complete; 
echo " Waiting for all logs to be sent..."
wait

# sleep a bit longer to allow things to 'settle'
echo " Sleeping a bit to allow logs to be processed..."
sleep 10

# prep the log files
cat $ACS_TMP/$ACS_LOG_SVC_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$ACS_LOG_SVC_LOG_FILE.log 
cat $ACS_TMP/$LOGGING_SERVICE_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$LOGGING_SERVICE_LOG_FILE.log
cat $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE.log
cat $ACS_TMP/$LOGGING_CLIENT_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$LOGGING_CLIENT_LOG_FILE.log
cat $ACS_TMP/$PUBLISHER_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$PUBLISHER_LOG_FILE.log
if [ "$PROFILE_JLOG" ] ;
then
	cat $ACS_TMP/$JLOG_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
		| grep -v -i pid > $ACS_TMP/$JLOG_LOG_FILE.log
fi

# plot the data from the prepped log files
echo " Generating the plots"
genplot $ACS_LOG_SVC_LOG_FILE 1 6 $ACS_TMP
genplot $LOGGING_SERVICE_LOG_FILE 1 6 $ACS_TMP
genplot $LOGGING_NOTIFY_SERVICE_LOG_FILE 1 6 $ACS_TMP
genplot $LOGGING_CLIENT_LOG_FILE 1 6 $ACS_TMP
genplot $PUBLISHER_LOG_FILE 1 6 $ACS_TMP
if [ "$PROFILE_JLOG" ] ;
then
	genplot $JLOG_LOG_FILE 1 6 $ACS_TMP
fi

# generate the html page summarizing the test results
echo " Generating the html file"
genhtml $NUM_LOGS `hostname -f` $NUM_COMPONENTS

# stop the loggingClient
echo " Stopping the loggingClient"
kill -9 $loggingClientPid

# stop jlog
if [ "$PROFILE_JLOG" ] ;
then
	echo " Stopping jlog"
	kill -9 $jlogPid
fi

# stop acs, containers, etc.
echo " Stopping ACS"
acsStop >& $ACS_TMP/acsStop.log

# verify the proper number of logs were received
totalLogsReceivedByLoggingClient=`grep "msg:" $ACS_TMP/all_logs.xml | wc -l`
if [ $totalLogsReceivedByLoggingClient -ne $NUM_LOGS ]
then
	echo " FAILURE: didn't receive the proper number of logs."
else
	echo " SUCCESS - all logs accounted for."
fi
