#!/bin/bash
. acsstartupAcsPorts

#################################################################################
#
# This script is used to monitor the performance of the ACS logging system
#
# @author Steve Harrington
# @date 04-11-2007
#################################################################################

##########################################################################################
# Function definitions used later in this script.
##########################################################################################

# definition of a function to print the usage statement for this script
printUsageAndExit ()
{
	echo ""
	echo "Usage: $0 [OPTIONS] <numLogsToSend> <numComponents> <delayBetweenLogs>";
	echo "  where: "
	echo "";
	echo "   <numLogsToSend> is the number of logs to publish per component.";
	echo "   <numComponents> is the number of publishing components to use.";
	echo "   <delayBetweenLogs> is the number of milliseconds to pause between sending each log.";
	echo "Options: "
	echo "   -j | --jlog: indicates whether to profile the jlog GUI (default if not specified is true)";
	echo "   -h | --help: print this usage message and exit."
	echo "   -d | --debug: print additional debugging info about this script to stdout."
	echo "   -r | --remoteHost <hostname>: remote host name on which to run the container(s)."
	echo "   -l | --language <py | cpp | java>: the implementation language of the publishing component (cpp, java, python)."
	echo ""
	exit -1;
}
# definition of a function to echo (print to stdout) based on debug settings
debugPrint ()
{
	stringToPrint=$1

	if [ "$DEBUG_MODE" ] ;
	then
		echo " DEBUG: $1"
	fi;
}

# definition of a function to plot (using gnuplot) the data produced by the unix 'sar' and 'top' commands
genplot () 
{
	LOG_FILE_NAME=$1
	X_AXIS_POSITION=$2	
	Y_AXIS_POSITION=$3	
   ACS_TEMP=$4
	
	cat ./gnuplot.template | sed -e s@CHANGE_PNG@../doc/$LOG_FILE_NAME@g | sed -e s@CHANGE_LOGFILE@$ACS_TEMP/$LOG_FILE_NAME@g \
		| sed -e s@CHANGE_X_LOCATION@$X_AXIS_POSITION@g | sed -e s@CHANGE_Y_LOCATION@$Y_AXIS_POSITION@g \
		| sed -e s@CHANGE_GRAPH_TITLE@$LOG_FILE_NAME@g > $ACS_TEMP/gplot.tmp;
	gnuplot $ACS_TEMP/gplot.tmp;
}

# definition of a function to plot (using gnuplot) the data produced by the unix 'sar' command for one or more containers
gencontainerplot () 
{
	LOG_FILE_NAME=$1
	X_AXIS_POSITION=$2	
	Y_AXIS_POSITION=$3	
   ACS_TEMP=$4

	# remove the first plot commands in the template
	cat ./gnuplot.template > $ACS_TEMP/gnuplot.tmp
	cat $ACS_TEMP/gnuplot.tmp | sed -e /using/d > $ACS_TEMP/gnuplot.tmp

	# insert plot commands in the template, for each component
	i=1
	if [ $NUM_COMPONENTS -ge 2 ]
	then
		echo -e "plot \"CHANGE_LOGFILE$i.log\" using CHANGE_X_LOCATION:CHANGE_Y_LOCATION title \"%user cpu: container$i\" with lines, "\\c \
			 >> $ACS_TEMP/gnuplot.tmp
	else
		echo "plot \"CHANGE_LOGFILE$i.log\" using CHANGE_X_LOCATION:CHANGE_Y_LOCATION title \"%user cpu: container$i\" with lines" >> $ACS_TEMP/gnuplot.tmp
	fi
	i=2
	while [ "$i" -le $NUM_COMPONENTS ]
	do
		if [ "$i" -lt $NUM_COMPONENTS ]
		then
			echo -e "\"CHANGE_LOGFILE$i.log\" using CHANGE_X_LOCATION:CHANGE_Y_LOCATION title \"%user cpu: container$i\" with lines, "\\c \
				 >> $ACS_TEMP/gnuplot.tmp
		else
			echo " \"CHANGE_LOGFILE$i.log\" using CHANGE_X_LOCATION:CHANGE_Y_LOCATION title \"%user cpu: container$i\" with lines" \
				 >> $ACS_TEMP/gnuplot.tmp
		fi
		i=`expr $i + 1`
	done

	# replace substitution keywords
	cat $ACS_TEMP/gnuplot.tmp | sed -e s@CHANGE_PNG@../doc/$LOG_FILE_NAME@g | sed -e s@CHANGE_LOGFILE@$ACS_TEMP/$LOG_FILE_NAME@g \
		| sed -e s@CHANGE_X_LOCATION@$X_AXIS_POSITION@g | sed -e s@CHANGE_Y_LOCATION@$Y_AXIS_POSITION@g \
		| sed -e s@CHANGE_GRAPH_TITLE@$LOG_FILE_NAME@g > $ACS_TEMP/gplotFinal.tmp;

	# plot the results
	gnuplot $ACS_TEMP/gplotFinal.tmp;
}

genmemoryplot ()
{
	LOG_FILE_NAME=$1
   ACS_TEMP=$2
	PROCESS_NAME=$3

# Dump gnuplot script
cat <<HERE > $ACS_TEMP/gnuplot.tmp
	set terminal png
	set out "../doc/$LOG_FILE_NAME.png"
	set title "Memory usage for process: $PROCESS_NAME"
	set xlabel "Time"
	set ylabel "Memory Allocated (kB)"
	set xdata time
	set timefmt "%s"
	plot "$ACS_TEMP/$LOG_FILE_NAME" using 1:2 title "Total Memory Requirement" with lines, "$ACS_TEMP/$LOG_FILE_NAME" using 1:3 title "Resident Memory Size" with lines
HERE

	# plot the results
	gnuplot $ACS_TEMP/gnuplot.tmp;
}

# definition of a function to plot (using gnuplot) the memory information for 1-n containers
gencontainermemoryplot () 
{
	LOG_FILE_NAME=$1
   ACS_TEMP=$2
	NUM_COMPONENTS=$3

# Dump gnuplot script
cat <<HERE > $ACS_TEMP/gnuplot.tmp
	set terminal png
	set out "../doc/$LOG_FILE_NAME.png"
	set title "Container memory usage"
	set xlabel "Time"
	set ylabel "Memory Allocated (kB)"
	set xdata time
	set timefmt "%s"
HERE

	i=1
	if [ $NUM_COMPONENTS -ge 2 ]
	then
		echo -e "plot \"$ACS_TEMP/$LOG_FILE_NAME$i\" using 1:2 title \"Total Memory Requirement container: $i\" with lines, \"$ACS_TEMP/$LOG_FILE_NAME$i\" \
			 using 1:3 title \"Resident Memory Size container: $i\" with lines, "\\c >> $ACS_TEMP/gnuplot.tmp
	else
		echo -e "plot \"$ACS_TEMP/$LOG_FILE_NAME$i\" using 1:2 title \"Total Memory Requirement container: $i\" with lines, \"$ACS_TEMP/$LOG_FILE_NAME$i\" \
			 using 1:3 title \"Resident Memory Size container: $i\" with lines "\\c >> $ACS_TEMP/gnuplot.tmp
	fi
	i=2
	while [ "$i" -le $NUM_COMPONENTS ]
	do
		if [ "$i" -lt $NUM_COMPONENTS ]
		then
			echo -e "\"$ACS_TEMP/$LOG_FILE_NAME$i\" using 1:2 title \"Total Memory Requirement container: $i\" with lines, \
				\"$ACS_TEMP/$LOG_FILE_NAME$i\" using 1:3 title \"Resident Memory Size\" with lines, "\\c >> $ACS_TEMP/gnuplot.tmp
		else
			echo -e "\"$ACS_TEMP/$LOG_FILE_NAME$i\" using 1:2 title \"Total Memory Requirement container: $i\" with lines, \
				\"$ACS_TEMP/$LOG_FILE_NAME$i\" using 1:3 title \"Resident Memory Size container: $i\" with lines " >> $ACS_TEMP/gnuplot.tmp
		fi
		i=`expr $i + 1`
	done

	# plot the results
	gnuplot $ACS_TEMP/gnuplot.tmp;
}

# definition of a function to generate an html file summarizing the test results
genhtml () 
{
	if [ $PROFILE_JLOG ]
	then
		cat ./index.html.template | sed -e s/CHANGE_NUMBER_OF_LOGS/$1/g \
		 | sed -e s/CHANGE_HOST_NAME/$2/g \
		 | sed -e s/CHANGE_NUMBER_OF_SUPPLIERS/$3/g \
		 > ../doc/loggingPerformance.html;
	else
		cat ./index.html.template | sed -e s/CHANGE_NUMBER_OF_LOGS/$1/g \
		 | sed -e s/CHANGE_HOST_NAME/$2/g \
		 | sed -e s/CHANGE_NUMBER_OF_SUPPLIERS/$3/g \
		 | sed -e /jlog/d \
		 > ../doc/loggingPerformance.html;
	fi
}

##########################################################################################
# Script logic starts here...                                                            #
##########################################################################################

ORIGINAL_CMD_LINE=$@

#
# These will contain the command line arguments and/or options
#
HELP=
DEBUG_MODE=
PROFILE_JLOG=
REMOTE_HOST=
COMPONENT_LANGUAGE=

#
# These options can be recognized (longopts comma-separated. colon means argument is required)
#
LONGOPTS=help,jlog,debug,remoteHost:,language:
SHORTOPTS=h,j,d,r:,l:

#
# Run getopt (posixly_correct needed). We run twice:
# First run is simply to check the commandline for correctness
# Second run is does the real work and sets execution flags for this script, as appropriate
export POSIXLY_CORRECT=1

getopt -n `basename $0` -u -a -l $LONGOPTS $SHORTOPTS "$@" || printUsageAndExit;

set -- `getopt -u -a -l $LONGOPTS $SHORTOPTS "$@"` >& /dev/null ; 

#
# Iterate over getopt's output and set CL_XXX variables accordingly
#
while : 
do
	case "$1" in
		--help)       HELP=true ;;
		-h)           HELP=true ;;
		--jlog)       PROFILE_JLOG=true ;;
		-j)           PROFILE_JLOG=true ;;
		--debug)      DEBUG_MODE=true ;;
		-d)           DEBUG_MODE=true ;;
		-r)           REMOTE_HOST=$2 ; shift ;;
		--remoteHost) REMOTE_HOST=$2 ; shift ;;
		-l)           COMPONENT_LANGUAGE=$2 ; shift ;;
		--language)   COMPONENT_LANGUAGE=$2 ; shift ;;
		--) break ;;
	esac
	shift
done
shift

# must be unset! otherwise our custom export() function
# that is defined below doesn't get used by the shell
#
export POSIXLY_CORRECT=
unset POSIXLY_CORRECT

if [ "$HELP" ] ; 
then
   printUsageAndExit
fi

# first, verify that the script was invoked w/ the proper number of command-line arguments 
if [ $# -ne 3 ] ;
then 
	printUsageAndExit
fi

case "$COMPONENT_LANGUAGE" in
	"cpp")	CONTAINER_GREP_STRING="maciContainer cppContainer"
				COMPONENT_NAME=LOGSTRESSCPP;;
	"java")  CONTAINER_GREP_STRING="containerName javaContainer"
				COMPONENT_NAME=LOGSTRESSJAVA;;
	"py") CONTAINER_GREP_STRING="ACSStartContainerPy pyContainer"
				COMPONENT_NAME=LOGSTRESSPYTHON;;
	*) printUsageAndExit;;
esac

debugPrint "Component type will be: $COMPONENT_LANGUAGE and name will be: $COMPONENT_NAME"

NUM_LOGS=$1
NUM_COMPONENTS=$2
DELAY=$3

# 'guesstimate' the amount of time we need to monitor the processes using the unix
# sar command by a rough rule of thumb that 100,000 logs requires ~ 4 minutes (240 secs)
debugPrint "NUM_LOGS was: $NUM_LOGS"
SAR_RUN_TIME=`expr \( $NUM_LOGS / 100000 \) \* 240 + 100 \* $DELAY`
debugPrint "SAR_RUN_TIME was calculated as: $SAR_RUN_TIME"
if [ "$SAR_RUN_TIME" -le "240" ] ;
then
	SAR_RUN_TIME=240
fi

debugPrint "SAR Run Time will be: $SAR_RUN_TIME"

# start acs
export ACS_TMP=`pwd`/tmp
debugPrint "exported ACS_TMP: $ACS_TMP"

rm -rf $ACS_TMP
debugPrint "deleted old ACS_TMP: $ACS_TMP"

mkdir $ACS_TMP
debugPrint "made new ACS_TMP: $ACS_TMP"

export ACS_CDB=`pwd`
debugPrint "exported ACS_CDB: $ACS_CDB"

# start ACS
acsutilTATPrologue -l

# define some string constants which will be used in several places
ACS_LOG_SVC_LOG_FILE=acsLogSvc
LOGGING_SERVICE_LOG_FILE=loggingService
LOGGING_CLIENT_LOG_FILE=loggingClient
LOGGING_NOTIFY_SERVICE_LOG_FILE=loggingNotifyService
JLOG_LOG_FILE=jlog
PUBLISHER_LOG_FILE=publisher

# start the container(s)
i=1
while [ "$i" -le $NUM_COMPONENTS ]
do
	if [ -z $REMOTE_HOST ]
	then
		echo " Starting Container $i"
		acsutilAwaitContainerStart -${COMPONENT_LANGUAGE} ${COMPONENT_LANGUAGE}Container$i >& $ACS_TMP/${COMPONENT_LANGUAGE}Container$i.log
		publisherPid[$i]=`ps -ef | grep "${CONTAINER_GREP_STRING}$i"  | grep -v acsStartJava | grep -v bash | grep -v grep | gawk '{ print $2 }'`
		debugPrint "publisherPid$i is: ${publisherPid[${i}]}"
		`sar -x ${publisherPid[${i}]} 1 $SAR_RUN_TIME >& $ACS_TMP/$PUBLISHER_LOG_FILE$i.orig.log` &
		./monitorPid.sh ${publisherPid[${i}]} 1 $ACS_TMP/$PUBLISHER_LOG_FILE-memory$i
	else
		echo " Starting Remote Container $i"
    	export MANAGER_REFERENCE=corbaloc::`getIP`:`getManagerPort`/Manager
		ssh -f $USER@$REMOTE_HOST -f acsStartContainer -m $MANAGER_REFERENCE -$COMPONENT_LANGUAGE ${COMPONENT_LANGUAGE}Container$i \
			>& $ACS_TMP/${COMPONENT_LANGUAGE}Container$i.log
		debugPrint "waiting for remote container $i to start..."
		sleep 15
		publisherPid[$i]=`ssh -f $USER@$REMOTE_HOST ps -ef | grep "${CONTAINER_GREP_STRING}$i"  | grep -v acsStartJava | grep -v bash \
			 | grep -v grep | gawk '{ print $2 }'`
		debugPrint "publisherPid$i is: ${publisherPid[${i}]}"
		ssh -f $USER@$REMOTE_HOST sar -x ${publisherPid[${i}]} 1 $SAR_RUN_TIME >& $ACS_TMP/$PUBLISHER_LOG_FILE$i.orig.log &
		ssh -f $USER@$REMOTE_HOST remoteMonitorProcess ${publisherPid[${i}]} 1 >& $ACS_TMP/$PUBLISHER_LOG_FILE-memory$i &
	fi
	i=`expr $i + 1`
done

# find the pids for all the processes that we're interested in monitoring
while [ -z "$logSvcPid" ]
do
	logSvcPid=`ps -ef | grep acsLogSvc | grep -v grep | gawk '{ print $2 }'`
done
debugPrint "logSvcPid is: $logSvcPid"
while [ -z "$loggingServicePid" ]
do
	loggingServicePid=`ps -ef | grep loggingService  | grep -v grep | gawk '{ print $2 }'`
done
debugPrint "loggingServicePid is: $loggingServicePid"
while [ -z "$loggingNotifyServicePid" ]
do
	loggingNotifyServicePid=`ps -ef | grep Notify_Service  | grep -v grep | grep LoggingNotify | gawk '{ print $2 }'`
done
debugPrint "loggingNotifyServicePid is: $loggingNotifyServicePid"
while [ -z "$loggingClientPid" ]
do
	loggingClientPid=`ps -ef | grep loggingClient  | grep -v grep | gawk '{ print $2 }'`
done
debugPrint "loggingClientPid is: $loggingClientPid"

# monitor the relevant processes using the unix 'sar' command
sar -x $logSvcPid 1 $SAR_RUN_TIME >& $ACS_TMP/$ACS_LOG_SVC_LOG_FILE.orig.log &
./monitorPid.sh $logSvcPid 1 $ACS_TMP/$ACS_LOG_SVC_LOG_FILE-memory
sar -x $loggingServicePid 1 $SAR_RUN_TIME >& $ACS_TMP/$LOGGING_SERVICE_LOG_FILE.orig.log &
./monitorPid.sh $loggingServicePid 1 $ACS_TMP/$LOGGING_SERVICE_LOG_FILE-memory 
sar -x $loggingNotifyServicePid 1 $SAR_RUN_TIME >& $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE.orig.log &
./monitorPid.sh $loggingNotifyServicePid 1 $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE-memory 
sar -x $loggingClientPid 1 $SAR_RUN_TIME >& $ACS_TMP/$LOGGING_CLIENT_LOG_FILE.orig.log &
./monitorPid.sh $loggingClientPid 1 $ACS_TMP/$LOGGING_CLIENT_LOG_FILE-memory 
if [ "$PROFILE_JLOG" ] ;
then
	# start jlog - using a separate script so that 'wait' will work later in this script (and not 
	# stall waiting on jlog to finish running) 
	./startJlog.sh $ACS_TMP
	while [ -z "$jlogPid" ]
	do
		jlogPid=`ps -ef | grep LogFrame  | grep -v grep | grep -v acsStartJava | gawk '{ print $2 }'`
	done
	debugPrint "jlogPid is: $jlogPid"
	# start monitoring jlog process with 'sar' command
	sar -x $jlogPid 1 $SAR_RUN_TIME >& $ACS_TMP/$JLOG_LOG_FILE.orig.log &
	./monitorPid.sh $jlogPid 1 $ACS_TMP/$JLOG_LOG_FILE-memory 
fi


# start up the client which will send the appropriate number of logs
ClientJavaClass=LogPerformanceTestClient
echo " Sending logs"
acsStartJava -D NumLogs=$NUM_LOGS -D NumComponents=$NUM_COMPONENTS -D Delay=$DELAY -D ComponentName=$COMPONENT_NAME \
	alma.perftest.client.$ClientJavaClass >& $ACS_TMP/clientOutput.log &

# wait until all the background processes are complete; 
echo " Waiting for all logs to be sent..."
wait

# sleep a bit longer to allow things to 'settle'
echo " Sleeping a bit to allow logs to be processed..."
sleep 10

# stop the monitoring
echo " Stopping the monitoring"
killall monitorProcess
if [ ! -z $REMOTE_HOST ] 
then
	ssh -f $USER@$REMOTE_HOST killall remoteMonitorProcess
fi

# prep the log files
echo " Preparing the sar log files"
cat $ACS_TMP/$ACS_LOG_SVC_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$ACS_LOG_SVC_LOG_FILE.log 
cat $ACS_TMP/$LOGGING_SERVICE_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$LOGGING_SERVICE_LOG_FILE.log
cat $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$LOGGING_NOTIFY_SERVICE_LOG_FILE.log
cat $ACS_TMP/$LOGGING_CLIENT_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
	| grep -v -i pid > $ACS_TMP/$LOGGING_CLIENT_LOG_FILE.log

i=1
while [ "$i" -le $NUM_COMPONENTS ]
do
	cat $ACS_TMP/$PUBLISHER_LOG_FILE$i.orig.log | grep -v -i average | grep -v -i linux \
		| grep -v -i pid > $ACS_TMP/$PUBLISHER_LOG_FILE$i.log
	i=`expr $i + 1`
done

if [ "$PROFILE_JLOG" ] ;
then
	cat $ACS_TMP/$JLOG_LOG_FILE.orig.log | grep -v -i average | grep -v -i linux \
		| grep -v -i pid > $ACS_TMP/$JLOG_LOG_FILE.log
fi

# plot the data from the prepped log files
echo " Generating the plots"
genplot $ACS_LOG_SVC_LOG_FILE 1 6 $ACS_TMP
genmemoryplot $ACS_LOG_SVC_LOG_FILE-memory $ACS_TMP acsLogSvc
genplot $LOGGING_SERVICE_LOG_FILE 1 6 $ACS_TMP 
genmemoryplot $LOGGING_SERVICE_LOG_FILE-memory $ACS_TMP loggingService
genplot $LOGGING_NOTIFY_SERVICE_LOG_FILE 1 6 $ACS_TMP
genmemoryplot $LOGGING_NOTIFY_SERVICE_LOG_FILE-memory $ACS_TMP
genplot $LOGGING_CLIENT_LOG_FILE 1 6 $ACS_TMP
genmemoryplot $LOGGING_CLIENT_LOG_FILE-memory $ACS_TMP loggingClient
gencontainerplot $PUBLISHER_LOG_FILE 1 6 $ACS_TMP
gencontainermemoryplot $PUBLISHER_LOG_FILE-memory $ACS_TMP $NUM_COMPONENTS 

if [ "$PROFILE_JLOG" ] ;
then
	genplot $JLOG_LOG_FILE 1 6 $ACS_TMP
	genmemoryplot $JLOG_LOG_FILE-memory $ACS_TMP jlog
fi

# generate the html page summarizing the test results
echo " Generating the html file"
genhtml $NUM_LOGS `hostname -f` $NUM_COMPONENTS

# stop the loggingClient
echo " Stopping the loggingClient"
kill -9 $loggingClientPid

# stop jlog
if [ "$PROFILE_JLOG" ] ;
then
	echo " Stopping jlog"
	kill -9 $jlogPid
fi

# stop the container(s)
i=1
while [ "$i" -le $NUM_COMPONENTS ]
do
	if [ -z $REMOTE_HOST ]
	then
		echo " Stopping Container $i"
		acsStopContainer ${COMPONENT_LANGUAGE}Container$i >& $ACS_TMP/Stop${COMPONENT_LANGUAGE}Container$i.log
	else
		echo " Stopping Remote Container $i"
		ssh -f $USER@$REMOTE_HOST -f acsStopContainer ${COMPONENT_LANGUAGE}Container$i \
			>& $ACS_TMP/Stop${COMPONENT_LANGUAGE}Container$i.log
		debugPrint "waiting for remote container $i to start..."
		sleep 15
	fi
	i=`expr $i + 1`
done

# stop acs
echo " Stopping ACS"
acsStop >& $ACS_TMP/acsStop.log

# verify the proper number of logs were received
totalLogsReceivedByLoggingClient=`grep "msg:" $ACS_TMP/all_logs.xml | wc -l`
totalLogsExpected=`expr $NUM_LOGS \* $NUM_COMPONENTS`
if [ $totalLogsReceivedByLoggingClient -ne $totalLogsExpected ]
then
	echo " FAILURE: didn't receive the proper number of logs."
else
	echo " SUCCESS - all logs accounted for."
fi
