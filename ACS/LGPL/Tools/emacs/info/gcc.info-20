This is Info file gcc.info, produced by Makeinfo-1.54 from the input
file gcc.texi.

   This file documents the use and the internals of the GNU compiler.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1988, 1989, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Protect
Your Freedom--Fight `Look And Feel'" are included exactly as in the
original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License" and "Protect Your Freedom--Fight `Look And Feel'", and this
permission notice, may be included in translations approved by the Free
Software Foundation instead of in the original English.


File: gcc.info,  Node: Scalar Return,  Next: Aggregate Return,  Prev: Register Arguments,  Up: Stack and Calling

How Scalar Function Values Are Returned
---------------------------------------

   This section discusses the macros that control returning scalars as
values--values that can fit in registers.

`TRADITIONAL_RETURN_FLOAT'
     Define this macro if `-traditional' should not cause functions
     declared to return `float' to convert the value to `double'.

`FUNCTION_VALUE (VALTYPE, FUNC)'
     A C expression to create an RTX representing the place where a
     function returns a value of data type VALTYPE.  VALTYPE is a tree
     node representing a data type.  Write `TYPE_MODE (VALTYPE)' to get
     the machine mode used to represent that type.  On many machines,
     only the mode is relevant.  (Actually, on most machines, scalar
     values are returned in the same place regardless of mode).

     If `PROMOTE_FUNCTION_RETURN' is defined, you must apply the same
     promotion rules specified in `PROMOTE_MODE' if VALTYPE is a scalar
     type.

     If the precise function being called is known, FUNC is a tree node
     (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
     makes it possible to use a different value-returning convention
     for specific functions when all their calls are known.

     `FUNCTION_VALUE' is not used for return vales with aggregate data
     types, because these are returned in another way.  See
     `STRUCT_VALUE_REGNUM' and related macros, below.

`FUNCTION_OUTGOING_VALUE (VALTYPE, FUNC)'
     Define this macro if the target machine has "register windows" so
     that the register in which a function returns its value is not the
     same as the one in which the caller sees the value.

     For such machines, `FUNCTION_VALUE' computes the register in which
     the caller will see the value.  `FUNCTION_OUTGOING_VALUE' should be
     defined in a similar fashion to tell the function where to put the
     value.

     If `FUNCTION_OUTGOING_VALUE' is not defined, `FUNCTION_VALUE'
     serves both purposes.

     `FUNCTION_OUTGOING_VALUE' is not used for return vales with
     aggregate data types, because these are returned in another way.
     See `STRUCT_VALUE_REGNUM' and related macros, below.

`LIBCALL_VALUE (MODE)'
     A C expression to create an RTX representing the place where a
     library function returns a value of mode MODE.  If the precise
     function being called is known, FUNC is a tree node
     (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
     makes it possible to use a different value-returning convention
     for specific functions when all their calls are known.

     Note that "library function" in this context means a compiler
     support routine, used to perform arithmetic, whose name is known
     specially by the compiler and was not mentioned in the C code being
     compiled.

     The definition of `LIBRARY_VALUE' need not be concerned aggregate
     data types, because none of the library functions returns such
     types.

`FUNCTION_VALUE_REGNO_P (REGNO)'
     A C expression that is nonzero if REGNO is the number of a hard
     register in which the values of called function may come back.

     A register whose use for returning values is limited to serving as
     the second of a pair (for a value of type `double', say) need not
     be recognized by this macro.  So for most machines, this definition
     suffices:

          #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)

     If the machine has register windows, so that the caller and the
     called function use different registers for the return value, this
     macro should recognize only the caller's register numbers.

`APPLY_RESULT_SIZE'
     Define this macro if `untyped_call' and `untyped_return' need more
     space than is implied by `FUNCTION_VALUE_REGNO_P' for saving and
     restoring an arbitrary return value.


File: gcc.info,  Node: Aggregate Return,  Next: Caller Saves,  Prev: Scalar Return,  Up: Stack and Calling

How Large Values Are Returned
-----------------------------

   When a function value's mode is `BLKmode' (and in some other cases),
the value is not returned according to `FUNCTION_VALUE' (*note Scalar
Return::.).  Instead, the caller passes the address of a block of
memory in which the value should be stored.  This address is called the
"structure value address".

   This section describes how to control returning structure values in
memory.

`RETURN_IN_MEMORY (TYPE)'
     A C expression which can inhibit the returning of certain function
     values in registers, based on the type of value.  A nonzero value
     says to return the function value in memory, just as large
     structures are always returned.  Here TYPE will be a C expression
     of type `tree', representing the data type of the value.

     Note that values of mode `BLKmode' must be explicitly handled by
     this macro.  Also, the option `-fpcc-struct-return' takes effect
     regardless of this macro.  On most systems, it is possible to
     leave the macro undefined; this causes a default definition to be
     used, whose value is the constant 1 for `BLKmode' values, and 0
     otherwise.

     Do not use this macro to indicate that structures and unions
     should always be returned in memory.  You should instead use
     `DEFAULT_PCC_STRUCT_RETURN' to indicate this.

`DEFAULT_PCC_STRUCT_RETURN'
     Define this macro to be 1 if all structure and union return values
     must be in memory.  Since this results in slower code, this should
     be defined only if needed for compatibility with other compilers
     or with an ABI.  If you define this macro to be 0, then the
     conventions used for structure and union return values are decided
     by the `RETURN_IN_MEMORY' macro.

     If not defined, this defaults to the value 1.

`STRUCT_VALUE_REGNUM'
     If the structure value address is passed in a register, then
     `STRUCT_VALUE_REGNUM' should be the number of that register.

`STRUCT_VALUE'
     If the structure value address is not passed in a register, define
     `STRUCT_VALUE' as an expression returning an RTX for the place
     where the address is passed.  If it returns 0, the address is
     passed as an "invisible" first argument.

`STRUCT_VALUE_INCOMING_REGNUM'
     On some architectures the place where the structure value address
     is found by the called function is not the same place that the
     caller put it.  This can be due to register windows, or it could
     be because the function prologue moves it to a different place.

     If the incoming location of the structure value address is in a
     register, define this macro as the register number.

`STRUCT_VALUE_INCOMING'
     If the incoming location is not a register, then you should define
     `STRUCT_VALUE_INCOMING' as an expression for an RTX for where the
     called function should find the value.  If it should find the
     value on the stack, define this to create a `mem' which refers to
     the frame pointer.  A definition of 0 means that the address is
     passed as an "invisible" first argument.

`PCC_STATIC_STRUCT_RETURN'
     Define this macro if the usual system convention on the target
     machine for returning structures and unions is for the called
     function to return the address of a static variable containing the
     value.

     Do not define this if the usual system convention is for the
     caller to pass an address to the subroutine.

     This macro has effect in `-fpcc-struct-return' mode, but it does
     nothing when you use `-freg-struct-return' mode.


File: gcc.info,  Node: Caller Saves,  Next: Function Entry,  Prev: Aggregate Return,  Up: Stack and Calling

Caller-Saves Register Allocation
--------------------------------

   If you enable it, GNU CC can save registers around function calls.
This makes it possible to use call-clobbered registers to hold
variables that must live across calls.

`DEFAULT_CALLER_SAVES'
     Define this macro if function calls on the target machine do not
     preserve any registers; in other words, if `CALL_USED_REGISTERS'
     has 1 for all registers.  This macro enables `-fcaller-saves' by
     default.  Eventually that option will be enabled by default on all
     machines and both the option and this macro will be eliminated.

`CALLER_SAVE_PROFITABLE (REFS, CALLS)'
     A C expression to determine whether it is worthwhile to consider
     placing a pseudo-register in a call-clobbered hard register and
     saving and restoring it around each function call.  The expression
     should be 1 when this is worth doing, and 0 otherwise.

     If you don't define this macro, a default is used which is good on
     most machines: `4 * CALLS < REFS'.


File: gcc.info,  Node: Function Entry,  Next: Profiling,  Prev: Caller Saves,  Up: Stack and Calling

Function Entry and Exit
-----------------------

   This section describes the macros that output function entry
("prologue") and exit ("epilogue") code.

`FUNCTION_PROLOGUE (FILE, SIZE)'
     A C compound statement that outputs the assembler code for entry
     to a function.  The prologue is responsible for setting up the
     stack frame, initializing the frame pointer register, saving
     registers that must be saved, and allocating SIZE additional bytes
     of storage for the local variables.  SIZE is an integer.  FILE is
     a stdio stream to which the assembler code should be output.

     The label for the beginning of the function need not be output by
     this macro.  That has already been done when the macro is run.

     To determine which registers to save, the macro can refer to the
     array `regs_ever_live': element R is nonzero if hard register R is
     used anywhere within the function.  This implies the function
     prologue should save register R, provided it is not one of the
     call-used registers.  (`FUNCTION_EPILOGUE' must likewise use
     `regs_ever_live'.)

     On machines that have "register windows", the function entry code
     does not save on the stack the registers that are in the windows,
     even if they are supposed to be preserved by function calls;
     instead it takes appropriate steps to "push" the register stack,
     if any non-call-used registers are used in the function.

     On machines where functions may or may not have frame-pointers, the
     function entry code must vary accordingly; it must set up the frame
     pointer if one is wanted, and not otherwise.  To determine whether
     a frame pointer is in wanted, the macro can refer to the variable
     `frame_pointer_needed'.  The variable's value will be 1 at run
     time in a function that needs a frame pointer.  *Note
     Elimination::.

     The function entry code is responsible for allocating any stack
     space required for the function.  This stack space consists of the
     regions listed below.  In most cases, these regions are allocated
     in the order listed, with the last listed region closest to the
     top of the stack (the lowest address if `STACK_GROWS_DOWNWARD' is
     defined, and the highest address if it is not defined).  You can
     use a different order for a machine if doing so is more convenient
     or required for compatibility reasons.  Except in cases where
     required by standard or by a debugger, there is no reason why the
     stack layout used by GCC need agree with that used by other
     compilers for a machine.

        * A region of `current_function_pretend_args_size' bytes of
          uninitialized space just underneath the first argument
          arriving on the stack.  (This may not be at the very start of
          the allocated stack region if the calling sequence has pushed
          anything else since pushing the stack arguments.  But
          usually, on such machines, nothing else has been pushed yet,
          because the function prologue itself does all the pushing.)
          This region is used on machines where an argument may be
          passed partly in registers and partly in memory, and, in some
          cases to support the features in `varargs.h' and `stdargs.h'.

        * An area of memory used to save certain registers used by the
          function.  The size of this area, which may also include
          space for such things as the return address and pointers to
          previous stack frames, is machine-specific and usually
          depends on which registers have been used in the function.
          Machines with register windows often do not require a save
          area.

        * A region of at least SIZE bytes, possibly rounded up to an
          allocation boundary, to contain the local variables of the
          function.  On some machines, this region and the save area
          may occur in the opposite order, with the save area closer to
          the top of the stack.

        * Optionally, when `ACCUMULATE_OUTGOING_ARGS' is defined, a
          region of `current_function_outgoing_args_size' bytes to be
          used for outgoing argument lists of the function.  *Note
          Stack Arguments::.

     Normally, it is necessary for the macros `FUNCTION_PROLOGUE' and
     `FUNCTION_EPILOGUE' to treat leaf functions specially.  The C
     variable `leaf_function' is nonzero for such a function.

`EXIT_IGNORE_STACK'
     Define this macro as a C expression that is nonzero if the return
     instruction or the function epilogue ignores the value of the stack
     pointer; in other words, if it is safe to delete an instruction to
     adjust the stack pointer before a return from the function.

     Note that this macro's value is relevant only for functions for
     which frame pointers are maintained.  It is never safe to delete a
     final stack adjustment in a function that has no frame pointer,
     and the compiler knows this regardless of `EXIT_IGNORE_STACK'.

`FUNCTION_EPILOGUE (FILE, SIZE)'
     A C compound statement that outputs the assembler code for exit
     from a function.  The epilogue is responsible for restoring the
     saved registers and stack pointer to their values when the
     function was called, and returning control to the caller.  This
     macro takes the same arguments as the macro `FUNCTION_PROLOGUE',
     and the registers to restore are determined from `regs_ever_live'
     and `CALL_USED_REGISTERS' in the same way.

     On some machines, there is a single instruction that does all the
     work of returning from the function.  On these machines, give that
     instruction the name `return' and do not define the macro
     `FUNCTION_EPILOGUE' at all.

     Do not define a pattern named `return' if you want the
     `FUNCTION_EPILOGUE' to be used.  If you want the target switches
     to control whether return instructions or epilogues are used,
     define a `return' pattern with a validity condition that tests the
     target switches appropriately.  If the `return' pattern's validity
     condition is false, epilogues will be used.

     On machines where functions may or may not have frame-pointers, the
     function exit code must vary accordingly.  Sometimes the code for
     these two cases is completely different.  To determine whether a
     frame pointer is wanted, the macro can refer to the variable
     `frame_pointer_needed'.  The variable's value will be 1 when
     compiling a function that needs a frame pointer.

     Normally, `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' must treat
     leaf functions specially.  The C variable `leaf_function' is
     nonzero for such a function.  *Note Leaf Functions::.

     On some machines, some functions pop their arguments on exit while
     others leave that for the caller to do.  For example, the 68020
     when given `-mrtd' pops arguments in functions that take a fixed
     number of arguments.

     Your definition of the macro `RETURN_POPS_ARGS' decides which
     functions pop their own arguments.  `FUNCTION_EPILOGUE' needs to
     know what was decided.  The variable that is called
     `current_function_pops_args' is the number of bytes of its
     arguments that a function should pop.  *Note Scalar Return::.

`DELAY_SLOTS_FOR_EPILOGUE'
     Define this macro if the function epilogue contains delay slots to
     which instructions from the rest of the function can be "moved".
     The definition should be a C expression whose value is an integer
     representing the number of delay slots there.

`ELIGIBLE_FOR_EPILOGUE_DELAY (INSN, N)'
     A C expression that returns 1 if INSN can be placed in delay slot
     number N of the epilogue.

     The argument N is an integer which identifies the delay slot now
     being considered (since different slots may have different rules of
     eligibility).  It is never negative and is always less than the
     number of epilogue delay slots (what `DELAY_SLOTS_FOR_EPILOGUE'
     returns).  If you reject a particular insn for a given delay slot,
     in principle, it may be reconsidered for a subsequent delay slot.
     Also, other insns may (at least in principle) be considered for
     the so far unfilled delay slot.

     The insns accepted to fill the epilogue delay slots are put in an
     RTL list made with `insn_list' objects, stored in the variable
     `current_function_epilogue_delay_list'.  The insn for the first
     delay slot comes first in the list.  Your definition of the macro
     `FUNCTION_EPILOGUE' should fill the delay slots by outputting the
     insns in this list, usually by calling `final_scan_insn'.

     You need not define this macro if you did not define
     `DELAY_SLOTS_FOR_EPILOGUE'.


File: gcc.info,  Node: Profiling,  Prev: Function Entry,  Up: Stack and Calling

Generating Code for Profiling
-----------------------------

   These macros will help you generate code for profiling.

`FUNCTION_PROFILER (FILE, LABELNO)'
     A C statement or compound statement to output to FILE some
     assembler code to call the profiling subroutine `mcount'.  Before
     calling, the assembler code must load the address of a counter
     variable into a register where `mcount' expects to find the
     address.  The name of this variable is `LP' followed by the number
     LABELNO, so you would generate the name using `LP%d' in a
     `fprintf'.

     The details of how the address should be passed to `mcount' are
     determined by your operating system environment, not by GNU CC.  To
     figure them out, compile a small program for profiling using the
     system's installed C compiler and look at the assembler code that
     results.

`PROFILE_BEFORE_PROLOGUE'
     Define this macro if the code for function profiling should come
     before the function prologue.  Normally, the profiling code comes
     after.

`FUNCTION_BLOCK_PROFILER (FILE, LABELNO)'
     A C statement or compound statement to output to FILE some
     assembler code to initialize basic-block profiling for the current
     object module.  This code should call the subroutine
     `__bb_init_func' once per object module, passing it as its sole
     argument the address of a block allocated in the object module.

     The name of the block is a local symbol made with this statement:

          ASM_GENERATE_INTERNAL_LABEL (BUFFER, "LPBX", 0);

     Of course, since you are writing the definition of
     `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you
     can take a short cut in the definition of this macro and use the
     name that you know will result.

     The first word of this block is a flag which will be nonzero if the
     object module has already been initialized.  So test this word
     first, and do not call `__bb_init_func' if the flag is nonzero.

`BLOCK_PROFILER (FILE, BLOCKNO)'
     A C statement or compound statement to increment the count
     associated with the basic block number BLOCKNO.  Basic blocks are
     numbered separately from zero within each compilation.  The count
     associated with block number BLOCKNO is at index BLOCKNO in a
     vector of words; the name of this array is a local symbol made
     with this statement:

          ASM_GENERATE_INTERNAL_LABEL (BUFFER, "LPBX", 2);

     Of course, since you are writing the definition of
     `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you
     can take a short cut in the definition of this macro and use the
     name that you know will result.

`BLOCK_PROFILER_CODE'
     A C function or functions which are needed in the library to
     support block profiling.


File: gcc.info,  Node: Varargs,  Next: Trampolines,  Prev: Stack and Calling,  Up: Target Macros

Implementing the Varargs Macros
===============================

   GNU CC comes with an implementation of `varargs.h' and `stdarg.h'
that work without change on machines that pass arguments on the stack.
Other machines require their own implementations of varargs, and the
two machine independent header files must have conditionals to include
it.

   ANSI `stdarg.h' differs from traditional `varargs.h' mainly in the
calling convention for `va_start'.  The traditional implementation
takes just one argument, which is the variable in which to store the
argument pointer.  The ANSI implementation of `va_start' takes an
additional second argument.  The user is supposed to write the last
named argument of the function here.

   However, `va_start' should not use this argument.  The way to find
the end of the named arguments is with the built-in functions described
below.

`__builtin_saveregs ()'
     Use this built-in function to save the argument registers in
     memory so that the varargs mechanism can access them.  Both ANSI
     and traditional versions of `va_start' must use
     `__builtin_saveregs', unless you use `SETUP_INCOMING_VARARGS' (see
     below) instead.

     On some machines, `__builtin_saveregs' is open-coded under the
     control of the macro `EXPAND_BUILTIN_SAVEREGS'.  On other machines,
     it calls a routine written in assembler language, found in
     `libgcc2.c'.

     Code generated for the call to `__builtin_saveregs' appears at the
     beginning of the function, as opposed to where the call to
     `__builtin_saveregs' is written, regardless of what the code is.
     This is because the registers must be saved before the function
     starts to use them for its own purposes.

`__builtin_args_info (CATEGORY)'
     Use this built-in function to find the first anonymous arguments in
     registers.

     In general, a machine may have several categories of registers
     used for arguments, each for a particular category of data types.
     (For example, on some machines, floating-point registers are used
     for floating-point arguments while other arguments are passed in
     the general registers.) To make non-varargs functions use the
     proper calling convention, you have defined the `CUMULATIVE_ARGS'
     data type to record how many registers in each category have been
     used so far

     `__builtin_args_info' accesses the same data structure of type
     `CUMULATIVE_ARGS' after the ordinary argument layout is finished
     with it, with CATEGORY specifying which word to access.  Thus, the
     value indicates the first unused register in a given category.

     Normally, you would use `__builtin_args_info' in the implementation
     of `va_start', accessing each category just once and storing the
     value in the `va_list' object.  This is because `va_list' will
     have to update the values, and there is no way to alter the values
     accessed by `__builtin_args_info'.

`__builtin_next_arg (LASTARG)'
     This is the equivalent of `__builtin_args_info', for stack
     arguments.  It returns the address of the first anonymous stack
     argument, as type `void *'. If `ARGS_GROW_DOWNWARD', it returns
     the address of the location above the first anonymous stack
     argument.  Use it in `va_start' to initialize the pointer for
     fetching arguments from the stack.  Also use it in `va_start' to
     verify that the second parameter LASTARG is the last named argument
     of the current function.

`__builtin_classify_type (OBJECT)'
     Since each machine has its own conventions for which data types are
     passed in which kind of register, your implementation of `va_arg'
     has to embody these conventions.  The easiest way to categorize the
     specified data type is to use `__builtin_classify_type' together
     with `sizeof' and `__alignof__'.

     `__builtin_classify_type' ignores the value of OBJECT, considering
     only its data type.  It returns an integer describing what kind of
     type that is--integer, floating, pointer, structure, and so on.

     The file `typeclass.h' defines an enumeration that you can use to
     interpret the values of `__builtin_classify_type'.

   These machine description macros help implement varargs:

`EXPAND_BUILTIN_SAVEREGS (ARGS)'
     If defined, is a C expression that produces the machine-specific
     code for a call to `__builtin_saveregs'.  This code will be moved
     to the very beginning of the function, before any parameter access
     are made.  The return value of this function should be an RTX that
     contains the value to use as the return of `__builtin_saveregs'.

     The argument ARGS is a `tree_list' containing the arguments that
     were passed to `__builtin_saveregs'.

     If this macro is not defined, the compiler will output an ordinary
     call to the library function `__builtin_saveregs'.

`SETUP_INCOMING_VARARGS (ARGS_SO_FAR, MODE, TYPE,'
     PRETEND_ARGS_SIZE, SECOND_TIME) This macro offers an alternative
     to using `__builtin_saveregs' and defining the macro
     `EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous register
     arguments into the stack so that all the arguments appear to have
     been passed consecutively on the stack.  Once this is done, you
     can use the standard implementation of varargs that works for
     machines that pass all their arguments on the stack.

     The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure,
     containing the values that obtain after processing of the named
     arguments.  The arguments MODE and TYPE describe the last named
     argument--its machine mode and its data type as a tree node.

     The macro implementation should do two things: first, push onto the
     stack all the argument registers *not* used for the named
     arguments, and second, store the size of the data thus pushed into
     the `int'-valued variable whose name is supplied as the argument
     PRETEND_ARGS_SIZE.  The value that you store here will serve as
     additional offset for setting up the stack frame.

     Because you must generate code to push the anonymous arguments at
     compile time without knowing their data types,
     `SETUP_INCOMING_VARARGS' is only useful on machines that have just
     a single category of argument register and use it uniformly for
     all data types.

     If the argument SECOND_TIME is nonzero, it means that the
     arguments of the function are being analyzed for the second time.
     This happens for an inline function, which is not actually
     compiled until the end of the source file.  The macro
     `SETUP_INCOMING_VARARGS' should not generate any instructions in
     this case.


File: gcc.info,  Node: Trampolines,  Next: Library Calls,  Prev: Varargs,  Up: Target Macros

Trampolines for Nested Functions
================================

   A "trampoline" is a small piece of code that is created at run time
when the address of a nested function is taken.  It normally resides on
the stack, in the stack frame of the containing function.  These macros
tell GNU CC how to generate code to allocate and initialize a
trampoline.

   The instructions in the trampoline must do two things: load a
constant address into the static chain register, and jump to the real
address of the nested function.  On CISC machines such as the m68k,
this requires two instructions, a move immediate and a jump.  Then the
two addresses exist in the trampoline as word-long immediate operands.
On RISC machines, it is often necessary to load each address into a
register in two parts.  Then pieces of each address form separate
immediate operands.

   The code generated to initialize the trampoline must store the
variable parts--the static chain value and the function address--into
the immediate operands of the instructions.  On a CISC machine, this is
simply a matter of copying each address to a memory reference at the
proper offset from the start of the trampoline.  On a RISC machine, it
may be necessary to take out pieces of the address and store them
separately.

`TRAMPOLINE_TEMPLATE (FILE)'
     A C statement to output, on the stream FILE, assembler code for a
     block of data that contains the constant parts of a trampoline.
     This code should not include a label--the label is taken care of
     automatically.

`TRAMPOLINE_SECTION'
     The name of a subroutine to switch to the section in which the
     trampoline template is to be placed (*note Sections::.).  The
     default is a value of `readonly_data_section', which places the
     trampoline in the section containing read-only data.

`TRAMPOLINE_SIZE'
     A C expression for the size in bytes of the trampoline, as an
     integer.

`TRAMPOLINE_ALIGNMENT'
     Alignment required for trampolines, in bits.

     If you don't define this macro, the value of `BIGGEST_ALIGNMENT'
     is used for aligning trampolines.

`INITIALIZE_TRAMPOLINE (ADDR, FNADDR, STATIC_CHAIN)'
     A C statement to initialize the variable parts of a trampoline.
     aDDR is an RTX for the address of the trampoline; FNADDR is an RTX
     for the address of the nested function; STATIC_CHAIN is an RTX for
     the static chain value that should be passed to the function when
     it is called.

`ALLOCATE_TRAMPOLINE (FP)'
     A C expression to allocate run-time space for a trampoline.  The
     expression value should be an RTX representing a memory reference
     to the space for the trampoline.

     If this macro is not defined, by default the trampoline is
     allocated as a stack slot.  This default is right for most
     machines.  The exceptions are machines where it is impossible to
     execute instructions in the stack area.  On such machines, you may
     have to implement a separate stack, using this macro in
     conjunction with `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE'.

     FP points to a data structure, a `struct function', which
     describes the compilation status of the immediate containing
     function of the function which the trampoline is for.  Normally
     (when `ALLOCATE_TRAMPOLINE' is not defined), the stack slot for the
     trampoline is in the stack frame of this containing function.
     Other allocation strategies probably must do something analogous
     with this information.

   Implementing trampolines is difficult on many machines because they
have separate instruction and data caches.  Writing into a stack
location fails to clear the memory in the instruction cache, so when
the program jumps to that location, it executes the old contents.

   Here are two possible solutions.  One is to clear the relevant parts
of the instruction cache whenever a trampoline is set up.  The other is
to make all trampolines identical, by having them jump to a standard
subroutine.  The former technique makes trampoline execution faster; the
latter makes initialization faster.

   To clear the instruction cache when a trampoline is initialized,
define the following macros which describe the shape of the cache.

`INSN_CACHE_SIZE'
     The total size in bytes of the cache.

`INSN_CACHE_LINE_WIDTH'
     The length in bytes of each cache line.  The cache is divided into
     cache lines which are disjoint slots, each holding a contiguous
     chunk of data fetched from memory.  Each time data is brought into
     the cache, an entire line is read at once.  The data loaded into a
     cache line is always aligned on a boundary equal to the line size.

`INSN_CACHE_DEPTH'
     The number of alternative cache lines that can hold any particular
     memory location.

   Alternatively, if the machine has system calls or instructions to
clear the instruction cache directly, you can define the following
macro.

`CLEAR_INSN_CACHE (BEG, END)'
     If defined, expands to a C expression clearing the *instruction
     cache* in the specified interval.  If it is not defined, and the
     macro INSN_CACHE_SIZE is defined, some generic code is generated
     to clear the cache.  The definition of this macro would typically
     be a series of `asm' statements.  Both BEG and END are both pointer
     expressions.

   To use a standard subroutine, define the following macro.  In
addition, you must make sure that the instructions in a trampoline fill
an entire cache line with identical instructions, or else ensure that
the beginning of the trampoline code is always aligned at the same
point in its cache line.  Look in `m68k.h' as a guide.

`TRANSFER_FROM_TRAMPOLINE'
     Define this macro if trampolines need a special subroutine to do
     their work.  The macro should expand to a series of `asm'
     statements which will be compiled with GNU CC.  They go in a
     library function named `__transfer_from_trampoline'.

     If you need to avoid executing the ordinary prologue code of a
     compiled C function when you jump to the subroutine, you can do so
     by placing a special label of your own in the assembler code.  Use
     one `asm' statement to generate an assembler label, and another to
     make the label global.  Then trampolines can use that label to
     jump directly to your special assembler code.


File: gcc.info,  Node: Library Calls,  Next: Addressing Modes,  Prev: Trampolines,  Up: Target Macros

Implicit Calls to Library Routines
==================================

`MULSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     multiplication of one signed full-word by another.  If you do not
     define this macro, the default name is used, which is `__mulsi3',
     a function defined in `libgcc.a'.

`DIVSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of one signed full-word by another.  If you do not define
     this macro, the default name is used, which is `__divsi3', a
     function defined in `libgcc.a'.

`UDIVSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of one unsigned full-word by another.  If you do not
     define this macro, the default name is used, which is `__udivsi3',
     a function defined in `libgcc.a'.

`MODSI3_LIBCALL'
     A C string constant giving the name of the function to call for the
     remainder in division of one signed full-word by another.  If you
     do not define this macro, the default name is used, which is
     `__modsi3', a function defined in `libgcc.a'.

`UMODSI3_LIBCALL'
     A C string constant giving the name of the function to call for the
     remainder in division of one unsigned full-word by another.  If
     you do not define this macro, the default name is used, which is
     `__umodsi3', a function defined in `libgcc.a'.

`MULDI3_LIBCALL'
     A C string constant giving the name of the function to call for
     multiplication of one signed double-word by another.  If you do not
     define this macro, the default name is used, which is `__muldi3',
     a function defined in `libgcc.a'.

`DIVDI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of one signed double-word by another.  If you do not
     define this macro, the default name is used, which is `__divdi3', a
     function defined in `libgcc.a'.

`UDIVDI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of one unsigned full-word by another.  If you do not
     define this macro, the default name is used, which is `__udivdi3',
     a function defined in `libgcc.a'.

`MODDI3_LIBCALL'
     A C string constant giving the name of the function to call for the
     remainder in division of one signed double-word by another.  If
     you do not define this macro, the default name is used, which is
     `__moddi3', a function defined in `libgcc.a'.

`UMODDI3_LIBCALL'
     A C string constant giving the name of the function to call for the
     remainder in division of one unsigned full-word by another.  If
     you do not define this macro, the default name is used, which is
     `__umoddi3', a function defined in `libgcc.a'.

`INIT_TARGET_OPTABS'
     Define this macro as a C statement that declares additional library
     routines renames existing ones. `init_optabs' calls this macro
     after initializing all the normal library routines.

`TARGET_EDOM'
     The value of `EDOM' on the target machine, as a C integer constant
     expression.  If you don't define this macro, GNU CC does not
     attempt to deposit the value of `EDOM' into `errno' directly.
     Look in `/usr/include/errno.h' to find the value of `EDOM' on your
     system.

     If you do not define `TARGET_EDOM', then compiled code reports
     domain errors by calling the library function and letting it
     report the error.  If mathematical functions on your system use
     `matherr' when there is an error, then you should leave
     `TARGET_EDOM' undefined so that `matherr' is used normally.

`GEN_ERRNO_RTX'
     Define this macro as a C expression to create an rtl expression
     that refers to the global "variable" `errno'.  (On certain systems,
     `errno' may not actually be a variable.)  If you don't define this
     macro, a reasonable default is used.

`TARGET_MEM_FUNCTIONS'
     Define this macro if GNU CC should generate calls to the System V
     (and ANSI C) library functions `memcpy' and `memset' rather than
     the BSD functions `bcopy' and `bzero'.

`LIBGCC_NEEDS_DOUBLE'
     Define this macro if only `float' arguments cannot be passed to
     library routines (so they must be converted to `double').  This
     macro affects both how library calls are generated and how the
     library routines in `libgcc1.c' accept their arguments.  It is
     useful on machines where floating and fixed point arguments are
     passed differently, such as the i860.

`FLOAT_ARG_TYPE'
     Define this macro to override the type used by the library
     routines to pick up arguments of type `float'.  (By default, they
     use a union of `float' and `int'.)

     The obvious choice would be `float'--but that won't work with
     traditional C compilers that expect all arguments declared as
     `float' to arrive as `double'.  To avoid this conversion, the
     library routines ask for the value as some other type and then
     treat it as a `float'.

     On some systems, no other type will work for this.  For these
     systems, you must use `LIBGCC_NEEDS_DOUBLE' instead, to force
     conversion of the values `double' before they are passed.

`FLOATIFY (PASSED-VALUE)'
     Define this macro to override the way library routines redesignate
     a `float' argument as a `float' instead of the type it was passed
     as.  The default is an expression which takes the `float' field of
     the union.

`FLOAT_VALUE_TYPE'
     Define this macro to override the type used by the library
     routines to return values that ought to have type `float'.  (By
     default, they use `int'.)

     The obvious choice would be `float'--but that won't work with
     traditional C compilers gratuitously convert values declared as
     `float' into `double'.

`INTIFY (FLOAT-VALUE)'
     Define this macro to override the way the value of a
     `float'-returning library routine should be packaged in order to
     return it.  These functions are actually declared to return type
     `FLOAT_VALUE_TYPE' (normally `int').

     These values can't be returned as type `float' because traditional
     C compilers would gratuitously convert the value to a `double'.

     A local variable named `intify' is always available when the macro
     `INTIFY' is used.  It is a union of a `float' field named `f' and
     a field named `i' whose type is `FLOAT_VALUE_TYPE' or `int'.

     If you don't define this macro, the default definition works by
     copying the value through that union.

`nongcc_SI_type'
     Define this macro as the name of the data type corresponding to
     `SImode' in the system's own C compiler.

     You need not define this macro if that type is `long int', as it
     usually is.

`nongcc_word_type'
     Define this macro as the name of the data type corresponding to the
     word_mode in the system's own C compiler.

     You need not define this macro if that type is `long int', as it
     usually is.

`perform_...'
     Define these macros to supply explicit C statements to carry out
     various arithmetic operations on types `float' and `double' in the
     library routines in `libgcc1.c'.  See that file for a full list of
     these macros and their arguments.

     On most machines, you don't need to define any of these macros,
     because the C compiler that comes with the system takes care of
     doing them.

`NEXT_OBJC_RUNTIME'
     Define this macro to generate code for Objective C message sending
     using the calling convention of the NeXT system.  This calling
     convention involves passing the object, the selector and the
     method arguments all at once to the method-lookup library function.

     The default calling convention passes just the object and the
     selector to the lookup function, which returns a pointer to the
     method.


File: gcc.info,  Node: Addressing Modes,  Next: Condition Code,  Prev: Library Calls,  Up: Target Macros

Addressing Modes
================

`HAVE_POST_INCREMENT'
     Define this macro if the machine supports post-increment
     addressing.

`HAVE_PRE_INCREMENT'
`HAVE_POST_DECREMENT'
`HAVE_PRE_DECREMENT'
     Similar for other kinds of addressing.

`CONSTANT_ADDRESS_P (X)'
     A C expression that is 1 if the RTX X is a constant which is a
     valid address.  On most machines, this can be defined as
     `CONSTANT_P (X)', but a few machines are more restrictive in which
     constant addresses are supported.

     `CONSTANT_P' accepts integer-values expressions whose values are
     not explicitly known, such as `symbol_ref', `label_ref', and
     `high' expressions and `const' arithmetic expressions, in addition
     to `const_int' and `const_double' expressions.

`MAX_REGS_PER_ADDRESS'
     A number, the maximum number of registers that can appear in a
     valid memory address.  Note that it is up to you to specify a
     value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'
     would ever accept.

`GO_IF_LEGITIMATE_ADDRESS (MODE, X, LABEL)'
     A C compound statement with a conditional `goto LABEL;' executed
     if X (an RTX) is a legitimate memory address on the target machine
     for a memory operand of mode MODE.

     It usually pays to define several simpler macros to serve as
     subroutines for this one.  Otherwise it may be too complicated to
     understand.

     This macro must exist in two variants: a strict variant and a
     non-strict one.  The strict variant is used in the reload pass.  It
     must be defined so that any pseudo-register that has not been
     allocated a hard register is considered a memory reference.  In
     contexts where some kind of register is required, a pseudo-register
     with no hard register must be rejected.

     The non-strict variant is used in other passes.  It must be
     defined to accept all pseudo-registers in every context where some
     kind of register is required.

     Compiler source files that want to use the strict variant of this
     macro define the macro `REG_OK_STRICT'.  You should use an `#ifdef
     REG_OK_STRICT' conditional to define the strict variant in that
     case and the non-strict variant otherwise.

     Subroutines to check for acceptable registers for various purposes
     (one for base registers, one for index registers, and so on) are
     typically among the subroutines used to define
     `GO_IF_LEGITIMATE_ADDRESS'.  Then only these subroutine macros
     need have two variants; the higher levels of macros may be the
     same whether strict or not.

     Normally, constant addresses which are the sum of a `symbol_ref'
     and an integer are stored inside a `const' RTX to mark them as
     constant.  Therefore, there is no need to recognize such sums
     specifically as legitimate addresses.  Normally you would simply
     recognize any `const' as legitimate.

     Usually `PRINT_OPERAND_ADDRESS' is not prepared to handle constant
     sums that are not marked with  `const'.  It assumes that a naked
     `plus' indicates indexing.  If so, then you *must* reject such
     naked constant sums as illegitimate addresses, so that none of
     them will be given to `PRINT_OPERAND_ADDRESS'.

     On some machines, whether a symbolic address is legitimate depends
     on the section that the address refers to.  On these machines,
     define the macro `ENCODE_SECTION_INFO' to store the information
     into the `symbol_ref', and then check for it here.  When you see a
     `const', you will have to look inside it to find the `symbol_ref'
     in order to determine the section.  *Note Assembler Format::.

     The best way to modify the name string is by adding text to the
     beginning, with suitable punctuation to prevent any ambiguity.
     Allocate the new name in `saveable_obstack'.  You will have to
     modify `ASM_OUTPUT_LABELREF' to remove and decode the added text
     and output the name accordingly, and define `STRIP_NAME_ENCODING'
     to access the original name string.

     You can check the information stored here into the `symbol_ref' in
     the definitions of the macros `GO_IF_LEGITIMATE_ADDRESS' and
     `PRINT_OPERAND_ADDRESS'.

`REG_OK_FOR_BASE_P (X)'
     A C expression that is nonzero if X (assumed to be a `reg' RTX) is
     valid for use as a base register.  For hard registers, it should
     always accept those which the hardware permits and reject the
     others.  Whether the macro accepts or rejects pseudo registers
     must be controlled by `REG_OK_STRICT' as described above.  This
     usually requires two variant definitions, of which `REG_OK_STRICT'
     controls the one actually used.

`REG_OK_FOR_INDEX_P (X)'
     A C expression that is nonzero if X (assumed to be a `reg' RTX) is
     valid for use as an index register.

     The difference between an index register and a base register is
     that the index register may be scaled.  If an address involves the
     sum of two registers, neither one of them scaled, then either one
     may be labeled the "base" and the other the "index"; but whichever
     labeling is used must fit the machine's constraints of which
     registers may serve in each capacity.  The compiler will try both
     labelings, looking for one that is valid, and will reload one or
     both registers only if neither labeling works.

`LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)'
     A C compound statement that attempts to replace X with a valid
     memory address for an operand of mode MODE.  WIN will be a C
     statement label elsewhere in the code; the macro definition may use

          GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);

     to avoid further processing if the address has become legitimate.

     X will always be the result of a call to `break_out_memory_refs',
     and OLDX will be the operand that was given to that function to
     produce X.

     The code generated by this macro should not alter the substructure
     of X.  If it transforms X into a more legitimate form, it should
     assign X (which will always be a C variable) a new value.

     It is not necessary for this macro to come up with a legitimate
     address.  The compiler has standard ways of doing so in all cases.
     In fact, it is safe for this macro to do nothing.  But often a
     machine-dependent strategy can generate better code.

`GO_IF_MODE_DEPENDENT_ADDRESS (ADDR, LABEL)'
     A C statement or compound statement with a conditional `goto
     LABEL;' executed if memory address X (an RTX) can have different
     meanings depending on the machine mode of the memory reference it
     is used for or if the address is valid for some modes but not
     others.

     Autoincrement and autodecrement addresses typically have
     mode-dependent effects because the amount of the increment or
     decrement is the size of the operand being addressed.  Some
     machines have other mode-dependent addresses.  Many RISC machines
     have no mode-dependent addresses.

     You may assume that ADDR is a valid address for the machine.

`LEGITIMATE_CONSTANT_P (X)'
     A C expression that is nonzero if X is a legitimate constant for
     an immediate operand on the target machine.  You can assume that X
     satisfies `CONSTANT_P', so you need not check this.  In fact, `1'
     is a suitable definition for this macro on machines where anything
     `CONSTANT_P' is valid.

